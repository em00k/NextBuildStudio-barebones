{
  "ABOUT": {
    "content": "# About\n\n\n## About the ZX BASIC Project\n\nZX BASIC is a [BASIC](http://en.wikipedia.org/wiki/BASIC) ''cross compiler''.\nIt will compile BASIC programs (in your PC) for your [ZX Spectrum](http://en.wikipedia.org/wiki/Sinclair_ZX_Spectrum).\nZX BASIC is an <abbr title=\"Software Development Kit\">SDK</abbr> entirely written in [python](http://www.python.org).\nThe SDK is implemented using the [PLY](http://www.dabeaz.com/ply/) (Python Lex/Yacc) compiler tool.\nIt translates BASIC to Z80 assembler code, so it is easily portable to other Z80 platforms (Amstrad, MSX).\nOther non Z80 targets could also be available in the future.\n\nZX BASIC syntax tries to maintain compatibility as much as possible with\n[Sinclair BASIC](http://en.wikipedia.org/wiki/Sinclair_BASIC), it also have many new features, mostly taken from\n[FreeBASIC](http://www.freebasic.net/wiki) dialect.\n\n### Platform Availability\nSince it is written in python, it is available for many platforms, like Windows, Linux and Mac.\nYou only need to have python installed on these. For windows, there also is an installable (.MSI) _compiled_\nversion, which does not need python previously installed.\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "F_OPEN": {
    "content": "### M_GETSETDRV ($89)\r\n\r\nGet or set the default drive.\r\n\r\n|:Entry|\r\n|------|\r\n|A=0, get the default drive|\r\n|A<>0, set the default drive to A|\r\n|bits 7..3=drive letter (0=A...15=P)|\r\n|bits 2..0=ignored (use 1 to ensure A<>0)|\r\n| Exit (success)|\r\n| Fc=0|\r\n| A=default drive, encoded as|\r\n| bits 7..3=drive letter (0=A...15=P)|\r\n| bits 2..0=0|\r\n| Exit (failure):|\r\n| Fc=1|\r\n| A=error code|\r\n\r\n**NOTE:**\r\nThis call isn't often useful, as it is not necessary to provide a specific drive to calls which need a drive/filename.\r\n\r\nFor such calls, you can instead provide:\r\n\r\n|A='*' use the default drive|\r\n|A='$' use the system drive (C:, where the NEXTZXOS and BIN dirs are)|\r\n|Any drive provided in such calls is also overridden by any drive letter that is specified in the filename (eg “D:/myfile.txt\\0”).|\r\n\r\n**NOTE:**\r\nWhen setting a drive, this call only affects the default drive seen by other esxDOS and NextZXOS API calls. It does *not* change the default LOAD/SAVE drives used by NextBASIC, which are stored in the LODDRV and SAVDRV system variables.\r\n\r\n### Links \r\n\r\nhttps://gitlab.com/thesmog358/tbblue/-/tree/master/docs/nextzxos\r\n\r\n",
    "category": "esxdos",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "F_READ": {
    "content": "### F_READ ($9d)\r\n\r\nRead bytes from file.\r\n\r\n|:Entry|\r\n|--|\r\n|A=file handle|\r\n|IX [HL from dot command]=address|\r\n|BC=bytes to read|\r\n|Exit (success):|\r\n|Fc=0|\r\n|BC=bytes actually read (also in DE)|\r\n|HL=address following bytes read|\r\n|Exit (failure):|\r\n|Fc=1|\r\n|BC=bytes actually read|\r\n|A=error code|\r\n\r\n\r\n**NOTES:**\r\n\r\nEOF is not an error, check BC to determine if all bytes requested were read.\r\n\r\n### Links \r\n\r\nhttps://gitlab.com/thesmog358/tbblue/-/tree/master/docs/nextzxos\r\n\r\n",
    "category": "esxdos",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "F_SEEK": {
    "content": "### F_SEEK ($9f)\r\n\r\nSeek to position in file.\r\n\r\n|:Entry|\r\n|--|\r\n|A=file handle|\r\n|BCDE=bytes to seek|\r\n|IXL [L from dot command]=seek mode:|\r\n|esx_seek_set $00 set the fileposition to BCDE|\r\n|esx_seek_fwd $01 add BCDE to the fileposition|\r\n|esx_seek_bwd $02 subtract BCDE from the fileposition|\r\n|Exit (success):|\r\n|Fc=0|\r\n|BCDE=current position|\r\n|Exit (failure):|\r\n|Fc=1|\r\n|A=error code|\r\n\r\n**NOTE:**\r\nAttempts to seek past beginning/end of file leave BCDE=position=0/filesize\r\n\r\nrespectively, with no error.\r\n\r\n### Links \r\n\r\nhttps://gitlab.com/thesmog358/tbblue/-/tree/master/docs/nextzxos\r\n\r\n",
    "category": "esxdos",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "F_UNLINK": {
    "content": "### F_UNLINK ($ad) \r\n\r\nDelete file.\r\n\r\n|:Entry|\r\n|--|\r\n|A=drive specifier ('*'=default, '$'=system)|\r\n|(overridden if filespec includes a drive)|\r\n|IX [HL from dot command]=filespec, null-terminated|\r\n|Exit (success):|\r\n|Fc=0|\r\n|Exit (failure):|\r\n|Fc=1|\r\n|A=error code|\r\n\r\n**NOTE:**\r\nThis call only deletes the base file, not any associated metadata file.\r\n\r\nUse the +3DOS call DOS_DELETE to ensure any associated metadata file is also deleted.\r\n\r\n### Links \r\n\r\nhttps://gitlab.com/thesmog358/tbblue/-/tree/master/docs/nextzxos\r\n\r\n",
    "category": "esxdos",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "F_WRITE": {
    "content": "### F_WRITE ($9e) \r\n\r\nWrite bytes to file.\r\n\r\n|:Entry|\r\n|--|\r\n|A=file handle|\r\n|IX [HL from dot command]=address|\r\n|BC=bytes to write|\r\n|Exit (success):|\r\n|Fc=0|\r\n|BC=bytes actually written|\r\n|Exit (failure):|\r\n|Fc=1|\r\n|BC=bytes actually written|\r\n\r\n### Links \r\n\r\nhttps://gitlab.com/thesmog358/tbblue/-/tree/master/docs/nextzxos\r\n\r\n",
    "category": "esxdos",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "M_GETSETDRV": {
    "content": "### M_GETSETDRV ($89)\r\n\r\n### M_GETSETDRV ($89) \r\nGet or set the default drive.\r\n\r\n|Entry:|\r\n|------|\r\n|A=0, get the default drive|\r\n|A<>0, set the default drive to A|\r\n|bits 7..3=drive letter (0=A...15=P)|\r\n|bits 2..0=ignored (use 1 to ensure A<>0)|\r\n| Exit (success)|\r\n| Fc=0|\r\n| A=default drive, encoded as|\r\n| bits 7..3=drive letter (0=A...15=P)|\r\n| bits 2..0=0|\r\n| Exit (failure):|\r\n| Fc=1|\r\n| A=error code|\r\n\r\n**NOTE:**\r\nThis call isn't often useful, as it is not necessary to provide a specific drive to calls which need a drive/filename.\r\n\r\nFor such calls, you can instead provide:\r\n\r\n|A='*' use the default drive|\r\n|A='$' use the system drive (C:, where the NEXTZXOS and BIN dirs are)|\r\n|Any drive provided in such calls is also overridden by any drive letter that is specified in the filename (eg “D:/myfile.txt\\0”).|\r\n\r\n**NOTE:**\r\nWhen setting a drive, this call only affects the default drive seen by other esxDOS and NextZXOS API calls. It does *not* change the default LOAD/SAVE drives used by NextBASIC, which are stored in the LODDRV and SAVDRV system variables.\r\n\r\n### Links \r\n\r\nhttps://gitlab.com/thesmog358/tbblue/-/tree/master/docs/nextzxos\r\n\r\n",
    "category": "esxdos",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "_ESXDOS": {
    "content": "# ESXDOS API\r\n\r\n## Introduction\r\n\r\nZX Basic Compiler already comes with an ESXDOS library, and documentation can be found \r\n\r\nThis is the ESXDOS API documentation. THE esxDOS API is a set of functions that allow you to interact with the Next's SD card. A number of wrapper functions are provided to make it easier to use, but for reference the raw API is also documented.\r\n\r\n## Commands \r\n\r\n| Call Code | Command | Description |\r\n|-----------|---------|-------------|\r\n| `$85` (133) | [disk_filemap](disk_filemap.md) | obtain file allocation map |\r\n| `$86` (134) | [disk_strmstart](disk_strmstart.md) | start streaming operation |\r\n| `$87` (135) | [disk_strmend](disk_strmend.md) | end streaming operation |\r\n| `$88` (136) | [m_dosversion](m_dosversion.md) | get NextZXOS version/mode information |\r\n| `$89` (137) | [m_getsetdrv](m_getsetdrv.md) | get/set default drive |\r\n| `$8b` (139) | [m_tapein](m_tapein.md) | tape redirection control (input) |\r\n| `$8c` (140) | [m_tapeout](m_tapeout.md) | tape redirection control (output) |\r\n| `$8d` (141) | [m_gethandle](m_gethandle.md) | get handle for current dot command |\r\n| `$8e` (142) | [m_getdate](m_getdate.md) | get current date/time |\r\n| `$8f` (143) | [m_execcmd](m_execcmd.md) | execute a dot command |\r\n| `$90` (144) | [m_autoload](m_autoload.md) | load a BASIC program from tape or disk |\r\n| `$91` (145) | [m_setcaps](m_setcaps.md) | set additional capabilities |\r\n| `$92` (146) | [m_drvapi](m_drvapi.md) | access API for installable drivers |\r\n| `$93` (147) | [m_geterr](m_geterr.md) | get or generate error message |\r\n| `$94` (148) | [m_p3dos](m_p3dos.md) | execute +3DOS/IDEDOS/NextZXOS call |\r\n| `$95` (149) | [m_errh](m_errh.md) | register dot command error handler |\r\n| `$9a` (154) | [f_open](f_open.md) | open file |\r\n| `$9b` (155) | [f_close](f_close.md) | close file |\r\n| `$9c` (156) | [f_sync](f_sync.md) | sync file changes to disk |\r\n| `$9d` (157) | [f_read](f_read.md) | read file |\r\n| `$9e` (158) | [f_write](f_write.md) | write file |\r\n| `$9f` (159) | [f_seek](f_seek.md) | set file position |\r\n| `$a0` (160) | [f_fgetpos](f_fgetpos.md) | get file position |\r\n| `$a1` (161) | [f_fstat](f_fstat.md) | get open file information |\r\n| `$a2` (162) | [f_ftruncate](f_ftruncate.md) | truncate/extend open file |\r\n| `$a3` (163) | [f_opendir](f_opendir.md) | open directory for reading |\r\n| `$a4` (164) | [f_readdir](f_readdir.md) | read directory entry |\r\n| `$a5` (165) | [f_telldir](f_telldir.md) | get directory position |\r\n| `$a6` (166) | [f_seekdir](f_seekdir.md) | set directory position |\r\n| `$a7` (167) | [f_rewinddir](f_rewinddir.md) | rewind to start of directory |\r\n| `$a8` (168) | [f_getcwd](f_getcwd.md) | get current working directory |\r\n| `$a9` (169) | [f_chdir](f_chdir.md) | change directory |\r\n| `$aa` (170) | [f_mkdir](f_mkdir.md) | make directory |\r\n| `$ab` (171) | [f_rmdir](f_rmdir.md) | remove directory |\r\n| `$ac` (172) | [f_stat](f_stat.md) | get unopen file information |\r\n| `$ad` (173) | [f_unlink](f_unlink.md) | delete file |\r\n| `$ae` (174) | [f_truncate](f_truncate.md) | truncate/extend unopen file |\r\n| `$af` (175) | [f_chmod](f_chmod.md) | change file attributes |\r\n| `$b0` (176) | [f_rename](f_rename.md) | rename/move file |\r\n| `$b1` (177) | [f_getfree](f_getfree.md) | get free space |\r\n\r\n\r\n## Error Codes\r\n\r\n| Code | Constant | Description |\r\n|------|----------|-------------|\r\n| 0 | `esx_ok` | Unknown error |\r\n| 1 | `esx_eok` | OK |\r\n| 2 | `esx_nonsense` | Nonsense in esxDOS |\r\n| 3 | `esx_estend` | Statement end error |\r\n| 4 | `esx_ewrtype` | Wrong file type |\r\n| 5 | `esx_enoent` | No such file or dir |\r\n| 6 | `esx_eio` | I/O error |\r\n| 7 | `esx_einval` | Invalid filename |\r\n| 8 | `esx_eacces` | Access denied |\r\n| 9 | `esx_enospc` | Drive full |\r\n| 10 | `esx_enxio` | Invalid i/o request |\r\n| 11 | `esx_enodrv` | No such drive |\r\n| 12 | `esx_enfile` | Too many files open |\r\n| 13 | `esx_ebadf` | Bad file number |\r\n| 14 | `esx_enodev` | No such device |\r\n| 15 | `esx_eoverflow` | File pointer overflow |\r\n| 16 | `esx_eisdir` | Is a directory |\r\n| 17 | `esx_enotdir` | Not a directory |\r\n| 18 | `esx_eexist` | Already exists |\r\n| 19 | `esx_epath` | Invalid path |\r\n| 20 | `esx_esys` | Missing system |\r\n| 21 | `esx_enametoolong` | Path too long |\r\n| 22 | `esx_enocmd` | No such command |\r\n| 23 | `esx_einuse` | In use |\r\n| 24 | `esx_erdonly` | Read only |\r\n| 25 | `esx_everify` | Verify failed |\r\n| 26 | `esx_eloadingko` | Sys file load error |\r\n| 27 | `esx_edirinuse` | Directory in use |\r\n| 28 | `esx_emapramactive` | MAPRAM is active |\r\n| 29 | `esx_edrivebusy` | Drive busy |\r\n| 30 | `esx_efsunknown` | Unknown filesystem |\r\n| 31 | `esx_edevicebusy` | Device busy |\r\n\r\nTypical usage would involve the following steps:\r\n\r\n### Example 1\r\n```\r\n    ' open a file and get the file handle \r\n    asm \r\n        ld      a, \"$\"\r\n        rst     8 \r\n        db      m_getserdrv\r\n        xor     a \r\n        ld      ix, filename\r\n        ld      b, f_read \r\n        rst     8 \r\n        db      f_open\r\n    end asm \r\n    \r\n```\r\n\r\n## Description\r\n\r\nDESCRIPTION\r\n\r\n## Examples\r\n\r\n```\r\nEXAMPLE\r\n```\r\n\r\n\r\n## Remarks\r\n\r\n## See also\r\n\r\n* [OTHERKEYWORD](OTHERKEYWORD.md)\r\n",
    "category": "esxdos",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "INDEX": {
    "content": "# Welcome to Nextbuild Studio\r\n\r\n| Graphics   | Audio | Input/Output | FileIO | Hardware |\r\n|:----------:|:-----:|:------------:|:------:|:--------:|\r\n|[Layer2](_graphics.md)   | [SoundFX](_audio.md) | [Keyboard](_input.md) | [Load](_fileio.md) | [Registers](_registers.md) |\r\n|[Sprites](_sprites.md)   | [Music](_audio.md)  | [Controllers](_input.md) | [Save](_fileio.md) | [Ports](_ports.md) |\r\n|[TileMaps](_tilemaps.md)   | [Samples](_audio.md)  | [UART](_input.md) | [esxDOS](_esxdos.md)   | [Memory](_memory.md) |\r\n\r\n\r\n- Quick link to : [Manual Pages](#manual-pages)\r\n- Quick link to : [Syntax](syntax.md)\r\n- Quick link to : [Keywords](_keywords.md)\r\n- Quick link to : [Editors](EDITORS_INDEX.md)\r\n\r\n## Table of Contents\r\n\r\n- [Welcome to Nextbuild Studio](#welcome-to-nextbuild-studio)\r\n  - [Table of Contents](#table-of-contents)\r\n- [Welcome to NextBuild](#welcome-to-nextbuild)\r\n  - [The Basics](#the-basics)\r\n  - [Key Features](#key-features)\r\n  - [Getting Started](#getting-started)\r\n    - [Example: Hello World](#example-hello-world)\r\n    - [Example: Drawing a Sprite](#example-drawing-a-sprite)\r\n    - [Example: Simple Loop](#example-simple-loop)\r\n  - [Basic Syntax](#basic-syntax)\r\n  - [Useful Commands](#useful-commands)\r\n  - [More Information](#more-information)\r\n  - [Manual Pages](#manual-pages)\r\n\r\n---\r\n\r\n# Welcome to NextBuild\r\n\r\nNextBuild is a modern, user-friendly programming environment designed for rapid development on the ZX Spectrum Next and compatible systems. It uses the flexible & powerful *[ZX Basic Compiler by Boriel](_zx_index.md)* enhanced with nextlib. It combines familiar BASIC-like syntax with powerful features for graphics, sound, and hardware control similar to AMOS.\r\n\r\nZX Basic Compiler is Copyleft (K) 2008-2025, Jose Rodriguez-Rosa (a.k.a. Boriel) https://zxbasic.readthedocs.io/en/docs/ The [Full Documention](_zx_index.md) is included along with v1.18.1 of the compiler in /NextBuildv9/zxbasic/.\r\n\r\n## The Basics \r\n\r\nAs NextBuild uses ZX Basic Compiler, it's best to familiarise yourself with the documentation, a good place to start is with the [**```Syntax Documentation```**](syntax.md). The help for the F1, and hover help all come from the project which you can find here [Boriel-Basic @ Github](https://github.com/boriel-basic/zxbasic). \r\n\r\n**IMPORTANT** The compiler has been tweaked for optimal operation with the ZX Spectrum Next - using a vanilla release may cause issues. \r\n\r\n## Key Features\r\n- Simple, readable syntax\r\n- Built-in support for sprites, tiles, and graphics\r\n- Easy file and memory access\r\n- Hardware and register access for advanced users\r\n- Modern IDE integration with hover help and documentation\r\n\r\n## Getting Started\r\nA NextBuild program consists of statements and commands, much like traditional BASIC, but with enhancements for modern development.\r\n\r\n### Example: Hello World\r\n\r\nCreate a new file, save it as \"helloworld.bas\", enter the following : \r\n\r\n```nextbuild\r\n#INCLUDE <nextlib.bas>              ' Include the library\r\nPRINT \"Hello, NextBuild!\"           ' Say HELLO!\r\nWaitKey() : END                     ' Wait for keypress then reset\r\n```\r\n\r\nNow Press F6 - pick `Build Source & Run CSpect` and your program should say hello!\r\n\r\n### Example: Drawing a Sprite\r\n```nextbuild\r\n#INCLUDE <nextlib.bas>\r\nLoadSDBank(\"mysprites.spr\",34)      ' Load sprites into RAM\r\nInitSprites2(1,34)                  ' Upload to Sprite RAM \r\nSpritesOn(TRUE)                     ' Enable sprites \r\nUpdateSprite(100, 80, 1, 1, 0, 0)   ' Draw sprite #0 at (100,80) using pattern 1\r\nWaitKey() : END \r\n```\r\n\r\n**SPRITE SECTION** [Sprites](_Sprites.md)\r\n\r\n### Example: Simple Loop\r\n\r\nAs NextBuild uses [ZX Basic Compiler](About.md) under the hood, it follows familiar ZX Spectrum BASIC syntax\r\n\r\n```nextbuild\r\nFOR I = 1 TO 10\r\n    PRINT \"Count: \", I\r\nNEXT I\r\n```\r\n\r\nTo access the ZX Spectrum Next hardware you will need to use the [*Registers*](_registers.md) name: \r\n\r\nAccessing Next Registers :\r\n```\r\n  NextReg($43, %00010000)  ; Pick first Layer2 Palette \r\n```\r\nOr use the [*Register*](_registers.md) name: \r\n```\r\n  NextReg(PALETTE_CONTROL_NR_43,%00010000)\r\n```\r\nSetting the CPU speed: \r\n```\r\n  NextReg(TURBO_CONTROL_NR_07,%11)    ; %11 = 28Mhz\r\n```\r\nDrawing a tile:\r\n```\r\n TBC\r\n```\r\n## Basic Syntax\r\n- Statements are written one per line\r\n- Comments start with `'` or `REM`\r\n- Variables are automatically typed\r\n- Use `LET` for assignment (optional)\r\n\r\n## Useful Commands\r\n- `NextReg(R,N)`        - Set Next register R with value N\r\n- `PRINT`               - Output text to the screen\r\n- `InitLayer2(MODE)`    - Set up Layer2 \r\n- `UpdateSprite()`      - Draw or move a sprite\r\n- `PALETTE`             - Set color palette\r\n- `PEEK`/`POKE`         - Read/write memory\r\n\r\n## More Information\r\n- Use the F1 key or hover over keywords in the editor for instant help.\r\n- Explore the manual pages for details on graphics, sound, and advanced features.\r\n\r\n## Manual Pages\r\n\r\n| Graphics | [Graphics](_graphics.md) |\r\n| Sprites    | [Sprites](_sprites.md) |\r\n| Audio     | [Audio](_audio.md) |\r\n| File IO    | [File IO](_fileio.md) |\r\n| Registers  | [Registers](_registers.md) |\r\n| Constants | [Constants](_constants.md) | \r\n| Templates  | [Templates](_templates.md) |\r\n\r\nHappy coding with NextBuild!\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ABS": {
    "content": "# ABS\r\n\r\n## Syntax\r\n\r\n```\r\nABS(numerical expression)\r\n```\r\n\r\n## Description\r\n\r\nReturns the absolute value of the given argument. Argument must be a numeric expression. Returned value has the same type as the input argument.\r\n\r\n**Example**\r\n\r\n\t'Absolute value\r\n\ta = -1\r\n\tPRINT \"Absolute value if a is \"; ABS(a)\r\n\t'Will print 1\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ACS": {
    "content": "# ACS\r\n\r\n## Syntax\r\n\r\n```\r\nACS(*numerical expression*)\r\n```\r\n\r\n## Description\r\n\r\nReturns the arc cosine value of the given argument. Argument must be a numeric expression. Returned value type is Float.\r\n\r\n**Example**\r\n\r\n\t' Arc cosine value\r\n\ta = -1\r\n\tPRINT \"Arc Cosine value of a is \"; ACS(a)\r\n\t' Will print 1\r\n\r\nRemarks\r\n\r\nThis function is 100% Sinclair BASIC Compatible\r\nIf the given argument type is not float, it will be converted to float before operating with it.\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "AND": {
    "content": "# AND\r\n\r\n## Syntax\r\n\r\n```\r\na AND b\r\n```\r\n\r\n## Description\r\n\r\nAND is a Logical Operator. Performs the Logical Conjunction and returns TRUE if and only if both arguments are TRUE. \r\n\r\n**Example**\r\n\r\n\ta = b AND c\r\n\r\nResult table\r\n\r\n\t| A | B | Result |\r\n\t| F | F | \tF\t |\r\n\t| F | T | \tF\t |\r\n\t| T | F | \tF\t |\r\n\t| T | T | \tT\t |\r\nMore info : https://zxbasic.readthedocs.io/en/docs/operators/#AND\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ASM": {
    "content": "# ASM\r\n\r\n## Syntax\r\n\r\n```\r\nASM ... END ASM\r\n```\r\n\r\n## Description\r\n\r\nStarts immediate inline assembly context using standard z80n opcodes. Use with caution.\r\n\r\n**Syntax**\r\n\r\n\tasm\r\n\t\t; (Z80n assembly code)\r\n\t\tld\ta, 10\r\n\t\tout ($fe), a \r\n\tend asm\r\n    \r\n    ... rest of program \r\n\r\nMore info https://zxbasic.readthedocs.io/en/docs/asm/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ASN": {
    "content": "# ASN\n\n\n## Syntax\n\n```\nASN(numericExpression)\n```\n\n## Description\n\nReturns the arc sine value of the given argument.\nArgument must be a numeric expression. Returned value type is [float](types.md#Float).\n\n## Examples\n\n```\nREM Arc sine value\nPRINT \"Arc Sine value of a is \"; ASN(a)\n```\n\n\n## Remarks\n\n*  This function is 100% Sinclair BASIC Compatible\n*  If the given argument type is not float, it will be [converted](cast.md) to float before operating with it.\n\n## See also\n\n* [COS](cos.md) and [ACS](acs.md)\n* [TAN](tan.md) and [ATN](atn.md)\n* [SIN](sin.md)\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "AT": {
    "content": "# AT\r\n\r\n## Syntax\r\n\r\n```\r\nAT\r\n```\r\n\r\n## Description\r\n\r\nAT is not a statement, but a modifier.\r\n\r\nIt can be used both as a PRINT modifier and a variable declaration modifier.\r\n\r\n\tPRINT AT y,x;\r\n\r\n\tDIM var AS UINTEGER AT 32000\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ATN": {
    "content": "# ATN\r\n\r\n## Syntax\r\n\r\n```\r\nATN(*numericExpression*)\r\n```\r\n\r\n## Description\r\n\r\nReturns the arc tangent value of the given argument. Argument must be a numeric expression. Returned value type is float. \r\n\r\n**Example**\r\n\r\n\tPRINT \"Arc Tangent value of a is \"; ATN(a)\r\n\r\nRemarks\r\n\r\n- This function is 100% Sinclair BASIC Compatible\r\n- If the given argument type is not float, it will be converted to float before operating with it.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/atn/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "BEEP": {
    "content": "# BEEP\r\n\r\n## Syntax\r\n\r\n```\r\nBEEP *duration,pitch*\r\n```\r\n\r\n## Description\r\n\r\nEmits a sound using the ZX Spectrum speaker. The \"duration\" is given in seconds, and the \"pitch\" is given in semitones above middle C using negative numbers for notes below middle C. \r\n\r\n**Example**\r\n\r\n\tBEEP .01,3\r\n\r\nRemarks\r\n\r\n- This function is 100% Sinclair BASIC Compatible\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/atn/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "BOLD": {
    "content": "# BOLD\r\n\r\n## Syntax\r\n\r\n```\r\nBOLD *n* or PRINT BOLD *n*;\r\n```\r\n\r\n## Description\r\n\r\nWhere n is either 0 (false) or 1 (true), then the subsequent print statements will have their INK pixels emphasized, making text appear bolder.\r\n\r\n**Example**\r\n\r\n\tPrint INK 0;PAPER 7; BOLD 1; \"This is BOLD BLACK text on WHITE\"\r\n\r\nRemarks\r\n\r\n- This statement is NOT Sinclair BASIC compatible\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/bold/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "BORDER": {
    "content": "# BORDER\r\n\r\n## Syntax\r\n\r\n```\r\nBORDER n ubyte\r\n```\r\n\r\n## Description\r\n\r\nThis can be used to change the border colour. Where n is a number  between 0 and 7.\r\n\r\n**Example**\r\n\r\n\tBORDER 2\r\n- 0 - Black\r\n- 1 - Blue\r\n- 2 - Red\r\n- 3 - Magenta\r\n- 4 - Green\r\n- 5 - Cyan\r\n- 6 - Yellow\r\n- 7 - White\r\n\r\nRemarks\r\n\r\n- This statement is Sinclair BASIC compatible\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/border/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "BRIGHT": {
    "content": "# BRIGHT\r\n\r\n## Syntax\r\n\r\n```\r\nBRIGHT *n* or PRINT BRIGHT *n*;\r\n```\r\n\r\n## Description\r\n\r\nWhere n is either 0 (false) or 1 (true), where n is either 0 (false) or 1 (true), then the subsequent print statements will have both their INK and PAPER values set to the higher intensity BRIGHT mode.\r\n\r\n**Example**\r\n\r\n\tPrint INK 0;PAPER 7; BRIGHT 1; \"This is BLACK text on BRIGHT WHITE background\"\r\n\r\nRemarks\r\n\r\n- This statement is Sinclair BASIC compatible\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/bright/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "BYREF": {
    "content": "# BYREF\r\n\r\n## Syntax\r\n\r\n```\r\nByRef\r\n```\r\n\r\n## Description\r\n\r\nUsed when passing values to subroutines and functions. ByRef will instruct a passing\r\nof the variables location in memory.\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "BYTE": {
    "content": "# BYTE\r\n\r\n## Syntax\r\n\r\n```\r\nBYTE\r\n```\r\n\r\n## Description\r\n\r\nBYTE is an Integral Type.\r\n\r\nBYTE are 1 byte in size not signed. -128-127 - 8 bits signed\r\n\r\nMore info https://zxbasic.readthedocs.io/en/docs/types/#types_1\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "BYVAL": {
    "content": "# BYVAL\r\n\r\n## Syntax\r\n\r\n```\r\nByRef\r\n```\r\n\r\n## Description\r\n\r\nThe normal way values are passed to sub routines and functions. For instance \r\n\r\n\tsub print_image(byval addresss as uinterger)\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CAST": {
    "content": "# CAST\r\n\r\n## Syntax\r\n\r\n```\r\nCAST (*type,numeric value*), CAST (*type*,*variable*), CAST (*type*,function(*data*))\r\n```\r\n\r\n## Description\r\n\r\nReturns a value of the type specified with a value equivalent to the item specified, if that is possible.\r\n\r\n**Example**\r\n\r\n\tdim a as uinteger\r\n\tdim b,c as ubyte\r\n\ta = 32768\r\n\tb = 10\r\n\tc = b+cast(ubyte,a)\r\n\r\nFor most cases it can prove useful : \r\n\r\n\tadd = 32750 \r\n\tfor x = 0 100\r\n\t\tprint peek (add+cast(x,uinteger))\t\t\r\n\t\t' in this case x will be cast as a ubyte by the compiler\r\n\t\t' which means when it is added add with being recast it \r\n\t\t' will roll over 0-255\r\n\tnext x \r\n    \r\nRemarks\r\n\r\n- This function can lose precision if used indiscriminately. For example, CAST(Integer,PI) returns 3, losing precision on the value of PI.\r\n- This function is NOT Sinclair Compatible.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/cast/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CHR": {
    "content": "# CHR\r\n\r\n## Syntax\r\n\r\n```\r\nCHR(*value*), CHR(*value*,[*valueN*]), CHR$(*value*), CHR$(*value*,[*valueN*])\r\n```\r\n\r\n## Description\r\n\r\nReturns a string containing the ASCII characters whose codes are the given values. The arguments must be a numeric expression and, unlike Sinclair BASIC, parenthesis are mandatory. Returned value type is string.\r\n\r\n**Example**\r\n\r\n\t'Char for ASCII code 65 is 'A'\r\n\tPRINT \"CHR(65) is \"; CHR(65)\r\n\r\nThis function is extended, and several values can be given at once. The result is a concatenation of all the given values:\r\n\r\n\t'Chars for ASCII codes from 65 to 67 ('A' to 'C')\r\n\tPRINT \"CHR(65, 66, 67) is \"; CHR(65, 66, 67)\r\n\r\nThe following lines are both equivalent, but the 2nd is faster and takes less memory:\r\n\r\n\t'These two sentences are equivalent\r\n\tPRINT \"CHR(65, 66, 67) is \"; CHR(65) + CHR(66) + CHR(67)\r\n\tPRINT \"CHR(65, 66, 67) is \"; CHR(65, 66, 67)\r\n\r\nIn fact, if the compiler detects the programmer is using CHR(x) + CHR(y), it might compile it as CHR(x, y) to perform such optimization.\r\n\r\nRemarks\r\n\r\n- This function is 100% Sinclair BASIC Compatible, but parenthesis are mandatory\r\n- This function is expanded comparing to the original Sinclair BASIC\r\n- As with other functions and variables, the trailing $ can be omitted.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/chr/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CIRCLE": {
    "content": "# CIRCLE\r\n\r\n## Syntax\r\n\r\n```\r\nCIRCLE *x, y, radius*, CIRCLE *Attribute Modifiers*,*x, y, radius*\r\n```\r\n\r\n## Description\r\n\r\nDraws a circle centered on coordinates (x, y) (see PLOT) with the given radius. Coordinate (0, 0) designates bottom-left screen corner. Drawing coordinates are updated to the last plotted position.\r\nCIRCLE is enhanced in ZX BASIC to allow drawing on the last two screen rows (this was not possible in Sinclair BASIC). So now we have 16 lines more (192 in total). Sinclair BASIC only used top 176 scan lines. This means if in Sinclair BASIC you write:\r\n\r\n\tCIRCLE x,y,r\r\n\r\nYou must translate it to ZX BASIC as:\r\n\r\n\tCIRCLE x, y + 16, r\r\n\r\nIf you want both drawings to show at exactly the same vertical screen position. Also maximum circle radius size is 96, not 86.\r\n\r\nRemarks\r\n\r\n- his function is not strictly Sinclair BASIC compatible since it uses all 192 screen lines instead of top 176. If you translate ***PLOT***, ***DRAW*** & ***CIRCLE***, commands from Sinclair BASIC *as is* your drawing will be *shifted down* 16 pixels.\r\n- This primitive uses Bresenham's algorithm for faster drawing instead of ROMs implementation.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/circle/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CLS": {
    "content": "# CLS\r\n\r\n## Syntax\r\n\r\n```\r\nCLS\r\n```\r\n\r\n## Description\r\n\r\nCLS clears the ULA screen to the current PAPER and INK values\r\n\r\nTo clear Layer user CLS256(n)\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CODE": {
    "content": "# CODE\r\n\r\n## Syntax\r\n\r\n```\r\nCODE *string*\r\n```\r\n\r\n## Description\r\n\r\nCODE is applied to a string, and gives the code of the first character in the string (or 0 if the string is empty).\r\n\r\n**Example**\r\n\r\n\tPRINT CODE \"a\" : ' Will print ASCII code 97\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/circle/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CONST": {
    "content": "# CONST\r\n\r\n## Syntax\r\n\r\n```\r\nCONST *var* [AS *type*] = *value*\r\n```\r\n\r\n## Description\r\n\r\nCONST declares a non-modifiable variable.\r\n\r\n*type* can be something like Integer, Byte, Float, etc. See the list of available types. If type is not specified, Float will be used, unless you use a modifier like $ or %.\r\n\r\n**Example**\r\n\r\n\tCONST screenAddress as uInteger = 16384\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/const/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CONTINUE": {
    "content": "# CONTINUE\r\n\r\n## Syntax\r\n\r\n```\r\nCONTINUE, CONTINUE DO, CONTINUE WHILE\r\n```\r\n\r\n## Description\r\n\r\nRestarts the current loop at the initial control statement immediately, as though the CONTINUE was an end of loop. While conditions are checked again, and FOR variables are incremented or decremented as appropriate as would be normal for entering the next loop.\r\n\r\n**Example**\r\n\r\n\tCONST screenAddress as uInteger = 16384\r\n\r\n**Remarks**\r\n- This statement is NOT Sinclair compatible, and is NOT related to the Sinclair BASIC CONTINUE statement.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/continue/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "COS": {
    "content": "# COS\r\n\r\n## Syntax\r\n\r\n```\r\nCOS(*numericExpression*)\r\n```\r\n\r\n## Description\r\n\r\nReturns the cosine value of the given argument. Argument must be a numeric expression in radians units. Returned value type is float.\r\n\r\n**Example**\r\n\r\n\t'Cosine value\r\n\tPRINT \"Cosine value of a is \"; COS(a)\r\n\r\n**Remarks**\r\n- This function is 100% Sinclair BASIC Compatible\r\n- If the given argument type is not float, it will be converted to float before operating with it.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/cos/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DATA": {
    "content": "# DATA\n\n## Syntax\n```\n DATA <expression>[, <expression>, <expression>...]\n```\n\n**DATA** statement stores values to be retrieved using the [READ](read.md) sentence. These can be numerical or string expressions.\nInstead of using INPUT() function or [LET](let.md) assignments, you can write a sequence (or several of them) of **DATA**\nwhich might result in a compact and more readable code to initialize data variables.\n\n**DATA** statements can be placed anywhere in the code, but they're usually located at the end for better readability.\n\n## Example\n\n```\nFOR i = 1 TO 2\n    READ a, b, c$\n\n    PRINT \"a: \"; a\n    PRINT \"b: \"; b\n    PRINT \"c: \"; c\nNEXT i\n\nREM notice the a * a expression\nDATA 2, a * a, \"Hello\"\nDATA b * 5, 32, \"World\"\n```\n\nThis will output:\n\n```\n a: 2\n b: 4\n c: Hello\n a: 20\n b: 32\n c: World\n\n```\nExpressions are read and evaluated one by one. When a **DATA** line is finished, the next one in the listing will be read.\nTraditionally if there's no more data to read, an _OUT of Data_ error happened. In ZX Basic, the read sequence restarts from the beginning.\n\n## Remarks\n* This statement is Sinclair BASIC compatible.\n\n## See also\n* [READ](read.md)\n* [RESTORE](restore.md)\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DECLARE": {
    "content": "# DECLARE\r\n\r\n## Syntax\r\n\r\n```\r\nDECLARE *function_name* [(*parameter_list*)] AS *return_type*\r\n```\r\n\r\n## Description\r\n\r\nUsed to define a FUNCTION as ZX BASIC is a single pass compiler.\r\n\r\n**Example**\r\n\r\n\tDeclare Function myFunction(n As Ubyte) As Ubyte\r\n\t'Now you can call myFunction\r\n\tPRINT myFunction(32): ' This print 33\r\n\t'Now implements myFunction\r\n\tFunction myFunction(n As Ubyte) As UByte\r\n\t\tReturn n + 1\r\n\tEnd Function      \r\n\r\n**Details**\r\n\r\nZX BASIC is a single pass compiler - that means it goes through your source code once and only once when reading your program code and compiling. \r\nUnfortunately, this method does lead to some issues when calling SUB and FUNCTION code. \r\nIf a FUNCTION is not defined prior to being called, the compiler neither knows what its return type nor knows parameter types,\r\nor whether you are calling the SUB/FUNCTION correctly. The compiler, in this case, assumes the function returns the\r\ncompiler's largest type: a float. This is often incorrect and suboptimal.\r\n\r\nTraditionally, in compiler design, there are several ways to fix this problem. One is to have the compiler run two passes through the code; \r\npicking up the SUB/FUNCTION definitions as it goes, then a second pass to compile. \r\nOn the original ZX spectrum, most BASIC compilers were multipass to allow for this information gathering.\r\n\r\nZX BASIC remains single pass, which means there are two options open to you the programmer.\r\nThe first is to define all functions before they are used; for example, at the start of the code.\r\nThis method does work fine, but perhaps limits where you want to put functions in memory.\r\n\r\nThe second option is to use the DECLARE keyword. \r\nThis way, the programmer can tell the compiler about a function in advance before it is used, and before it is fully defined with the FUNCTION keyword.\r\nPutting a DECLARE statement at the start of your code tells the compiler about the function that is defined later on.\r\nIn essence, you are making a promise to define it later. This fully defines the return type for the function, so the receiving code can be built to work with that.\r\nIt also, in theory, allows the compiler to have information about the function and enable it to trap errors in use of the function.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/declare/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DEFINE": {
    "content": "# DEFINE\r\n\r\n## Syntax\r\n\r\n```\r\n#DEFINE *def*\r\n```\r\n\r\n## Description\r\n\r\nSets a compiler DEFINE. nextlibs.bas make use of DEFINES in the following way.\r\n\r\n\t#DEFINE IM2 : REM Using the AYFX & Music player routines\r\n\t#DEFINE NEX : REM Producing a final NEX (disables LoadSDBank code)\r\n\t#DEFINE DEBUG : REM Displays warnings when loadsd fails\r\n\r\n**Examples**\r\n\r\nOutput a final NEX\r\n\r\n\t#DEFINE NEX\r\n\t#INCLUDE \\<nextlib.bas\\>\r\n\r\nYou are using your own interrupt & final NEX\r\n\r\n\t#DEFINE IM2\r\n\t#DEFINE NEX\r\n\t#INCLUDE <nextlib.bas>\r\n\r\n**NB** The DEFINE needs to be set before \t#INCLUDE \\<nextlib.bas\\>\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DIM": {
    "content": "# DIM\r\n\r\n## Syntax\r\n\r\n```\r\nDIM variable_name[,variable_name...] [AS type] [= value]\r\n```\r\n\r\n## Description\r\n\r\nDIM is used in Sinclair BASIC to declare arrays. In ZX BASIC, its usage has been extended to declare any variable and its type. A type is a name for the kind of data (Integer, Byte, String, etc.) it holds.\r\n\r\nWhere can be one of INTEGER, BYTE, FLOAT, etc. See the list of available types. If type is not specified, FLOAT will be used, unless you use a suffix (usually called sigil) like $ or %.\r\n\r\n**Default variable values**\r\n\r\nZX BASIC will initialize any numeric variable to 0 (like most BASIC flavors), and any string variable to an empty string, so you don't need to initialize them, though it's recommended.\r\n\r\n***Undeclared variables***\r\n\r\nZX BASIC allows you to use undeclared variables. In Sinclair BASIC, using an unassigned variable triggered the error Variable not found, but in ZX BASIC it will default to 0 value.\r\n\r\nYou can enforce variable declaration using the *--explicit* command line option. When it's used, the compiler will require every variable to be declared with DIM before being used for the 1st time.\r\nYou can also enforce explicit type declaration using the --strict command line option. This way, if you use DIM you will be required to declare also the type needed.\r\n\r\n\t'Declares 'a' as a 16 bit signed integer variable\r\n\tDIM a AS INTEGER\r\n\r\n\t'Declares 'b' as a Float because no type is specified\r\n\tDIM b\r\n\r\n\t'Declares 'c' as String, because of the '$' suffix\r\n\tDIM c$\r\n\r\n\t'Declares d as String, using an explicit type\r\n\tDIM d as STRING\r\n\r\n\t'Declares x, y as 32bit unsigned integers in a single line\r\n\tDIM x, y as ULONG\r\n\r\n\t'Here S is declared as String, because R has a $\r\n\tDIM R$, S\r\n\r\n\t'initialize an unsigned byte with 5\r\n\tDIM b as UBYTE = 5\r\n\r\n\t'warning: Using default implicit type float for a\r\n\r\n\tDIM a = 5\r\n\r\n\t'No warning here, because the compiler knows it is an integer (% suffix)\r\n\r\n\tDIM c% = 5\r\n\r\n**Variable mapping**\r\n\r\nYou can declare a variable at a fixed memory address. This is called *variable mapping.*\r\nE.g. in ZX Spectrum Sinclair's ROM address 23675 contains a system variable which points to UDG address. You could traditionally read this content by doing:\r\n\r\n\tPRINT \"UDG memory address is \"; PEEK 23675 + 256 * PEEK 23676\r\n\r\nIt is a 16 bit unsigned integer value (Uinteger). We can map a variable on that address:\r\n\r\n\tDIM UDGaddr AS Uinteger AT 23675\r\n\tPRINT \"UDG memory address is \"; UDGaddr\r\n\r\nThis is more readable. Also, setting a value to this variable changes UDG address.\r\n\r\n**Variable aliasing**\r\n\r\nA variable is just a memory position containing data. In same cases you might find useful a variable having more than one name, for the sake of code readability:\r\n\r\n\tDIM a AS Float = PI\r\n\t'REM Now let's declare an alias of 'a', called 'radians'\r\n\tDIM radians AS Float AT @a\r\n\tPRINT \"radians = \"; radians\r\n\tLET radians = 1.5\r\n\tPRINT \"a = \"; a\r\n\r\nAs you can see, both *radians* and a can be used interchangeably.\r\n\r\n***Array Declaration***\r\n\r\n**DIM a([*lower_bound* TO] *upper_bound* [, ...]) AS *type***\r\n\r\n**Description**\r\n\r\nBy default, array indexes starts from 0, not from 1 as in Sinclair BASIC. You can change this behavior setting a different array base index using either a #pragma option or a command line option.\r\n\r\n**Examples**\r\n\r\n\t'REM 'a' is an array of 11 floats, from a(0) to a(10)\r\n\tDIM a(10)\r\n\r\n\t''b' has the same size\r\n\tDIM b(0 TO 10)\r\n\r\n**Initialized arrays**\r\n\r\nYou can also use DIM to declare an array, and promptly fill it with data. At the moment, this is not valid for string arrays, only numerical arrays. One handy way to use this would be to use an array to store a table, such as user defined graphics:\r\n\r\n\t'udg will be an array of 8 UBytes\r\n\t'Remember, the default in ZX Basic is for arrays to begin at zero, so 0-7 is 8 bytes\r\n\tDIM udg(7) AS uByte => {0,1,3,7,15,31,63,127}\r\n\r\n\t'This sets the System UDG variable to point to the 1st array element:\r\n\tPOKE UINTEGER 23675,@udg(0): ' udg(0) is the 1st array element\r\n\r\nArrays of 2 or more dimensions can be initialized using this syntax:\r\n\r\n\tDIM udg(1, 7) AS uByte => {{0,1,3,7,15,31,63,127}, _\r\n\t\t\t\t\t\t\t\t{1,2,4,7,15,31,63,127}}\r\n\r\nEach row contains an UDG. All bytes are stored in a continuous memory block\r\n\r\nNote the usage of @variable to denote the location in memory the variable is stored into. Also see the extensions to POKE.\r\n\r\nmore info : https://zxbasic.readthedocs.io/en/docs/dim\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DO": {
    "content": "# DO\r\n\r\n## Syntax\r\n\r\n```\r\nDO ... LOOP\r\n```\r\n\r\n## Description\r\n\r\nDO ... LOOP is a compound statement used to perform loops. The code within the DO ... LOOP statement will be repeated if the given condition is true\r\n\r\n**Syntax**\r\n\r\nThe DO ... LOOP construct is a very powerful sentence and can be used in up to 5 different ways: \r\n\r\n**Infinite loops**\r\n\r\nSometimes we want a loop to repeat forever, no matter what, because we need to exit the loop when an external event happens. For example, we want to repeat forever waiting for a key press. Traditionally we use GOTO for this in Sinclair BASIC. Other languages use WHILE (1), etc. The best way to do this in ZX BASIC is this one:\r\n\r\n\tDO\r\n\t\tsentences\r\n\tLOOP : 'This loop repeats forever.\r\n\r\nThis form **loops forever**. It's better to use this form instead of using **STEP** 0 in a **FOR** loop, or a **WHILE** 1 condition loop. The generated code is more efficient.\r\n\r\n**Looping UNTIL**\r\n\r\n\tDO\r\n\t\tsentences\r\n\tLOOP UNTIL condition\r\n\r\nYou can also put the condition at the beginning, this way:\r\n\r\n\tDO UNTIL condition\r\n\t\tsentences\r\n\tLOOP\r\n\r\nIn this case, the condition is checked first, and the program won't enter to the inner sentences if the condition is not satisfied at first.\r\n\r\n**Example of using UNTIL**\r\n\r\nExample: *Loop until the user press a Key*\r\n\r\n\t'in a single line!\r\n\tDO LOOP UNTIL INKEY$ <> \"\"\r\n\r\n**Looping WHILE**\r\n\r\n\tDO\r\n\t\tsentences\r\n\tLOOP WHILE condition\r\n\r\nThis form repeats *while* the given condition is true. The difference with the WHILE sentence is the latter won't execute the inner sentences if condition is false at the start. Remember: **DO...LOOP** will execute sentences at least once regardless of the condition upon entry to the loop - it is only evaluated at the end of the first loop.\r\n\r\nYou can also put the condition at the beginning, this way:\r\n\r\n\tDO WHILE condition\r\n\t\t\tsentences\r\n\tLOOP\r\n\r\nIn this case, the condition is checked first, and the program won't enter to the inner sentences if the condition is not satisfied at first.\r\n\r\n**Example using WHILE**\r\n\r\nExample: *Loop while there is no key pressed*\r\n\r\n\t'in a single line!\r\n\tDO LOOP WHILE INKEY$ = \"\"\r\n\r\n**Remarks**\r\n- This statement does not exist in Sinclair Basic.\r\n- **WHILE** can also be used with WHILE ... END WHILE loops.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/do/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DRAW": {
    "content": "# DRAW\r\n\r\n## Syntax\r\n\r\n```\r\nDRAW dx, dy [, arc] OR  DRAW *Attribute Modifiers*; dx, dy [, arc]\r\n```\r\n\r\n## Description\r\n\r\nDraws a straight line starting from the current drawing coordinates (x, y) (see PLOT) to (x + dx, y + dy) position. Coordinate (0, 0) designates bottom-left screen corner. Drawing coordinates are updated to the last position.\r\n\r\nDRAW is enhanced in ZX BASIC to allow drawing on the last two screen rows (this was not possible in Sinclair BASIC). So now we have 16 lines more (192 in total). Sinclair BASIC only used top 176 scan lines. This means that in Sinclair BASIC\r\n\r\n\tPLOT x0, y0: DRAW x, y\r\n\r\nis equivalent in ZX BASIC to\r\n\r\n\tPLOT x0, y0 + 16: DRAW x, y\r\n\r\n**Remark This primitive uses Bresenham's algorithm for faster drawing instead of ROMs implementation.\r\n\r\n**Drawing Arcs**\r\n\r\nWhen used with 3 parameters it draws arcs the same way the Sinclair BASIC version does, but again the 192 scan-lines are available.\r\n\r\n\tDRAW dx, dy, arc\r\n\r\nThe above will draw an arc from the current position to (x + dx, y + dy) position, with a curve of ''arc'' radians. This routine also have some strange behaviors. High values of arc draws strange patterns.\r\n\r\n**Remarks**\r\n- This function is not strictly Sinclair BASIC compatible since it uses all 192 screen lines instead of top 176. If you translate **PLOT**, **DRAW** & **CIRCLE**, commands from Sinclair BASIC *as is* your drawing will be *shifted down* 16 pixels.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/draw/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ELSE": {
    "content": "# ELSE\r\n\r\n## Syntax\r\n\r\n```\r\nIF ...ELSE... END IF\r\n```\r\n\r\n## Description\r\n\r\nSee *IF* [IF](https://zxnext.uk/docs/if)\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/if/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "END": {
    "content": "# END\r\n\r\n## Syntax\r\n\r\n```\r\nEND, END SUB, END ASM, END FUNCTION\r\n```\r\n\r\n## Description\r\n\r\nUsed for ending a program, an asm block, sub or function\r\n\r\n**Syntax**\r\n\r\nTo END the program\r\n\r\n\tEND\r\n\r\nTo end an asm block\r\n\r\n\tasm\r\n\t\t; Z80n assembly code\r\n\tend asm\r\n\r\nAnd similar is used after a SUB or FUNCTION\r\n\r\n\tsub mysub()\r\n\t\t'..code\r\n\tend sub\r\n\r\n\tfunction hello()\r\n\t\t'..code\r\n\tend function\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/if/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ENDIF": {
    "content": "# ENDIF\r\n\r\n## Syntax\r\n\r\n```\r\nIF ...ELSE... END IF\r\n```\r\n\r\n## Description\r\n\r\nSee *IF* [IF](https://zxnext.uk/docs/if)\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/if/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "END_IF": {
    "content": "# END IF\r\n\r\n## Syntax\r\n\r\n```\r\nIF ...ELSE... END IF\r\n```\r\n\r\n## Description\r\n\r\nSee https://zxnext.uk/docs/if\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/if/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "EXIT": {
    "content": "# EXIT\r\n\r\n## Syntax\r\n\r\n```\r\nEXIT, EXIT DO, WHILE\r\n```\r\n\r\n## Description\r\n\r\nTerminates the current loop structure immediately and carries on execution from after the corresponding LOOP, NEXT or END WHILE statement.\r\n\r\n**Remarks**\r\n- This is NOT compatible with Sinclair Basic\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/exit/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "EXP": {
    "content": "# EXP\r\n\r\n## Syntax\r\n\r\n```\r\nEXP\r\n```\r\n\r\n## Description\r\n\r\nEXP\r\n\r\n**Remarks**\r\n- This is compatible with Sinclair Basic\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "FASTCALL": {
    "content": "# FASTCALL\r\n\r\n## Syntax\r\n\r\n```\r\nFASTCALL\r\n```\r\n\r\n## Description\r\n\r\nFastcall is used to indicate that an assembly function should be jumped into with registers already set.\r\n\r\n- If the function takes a Byte (or uByte) parameter, then the A register will be set with this parameter.\r\n- If it takes an Integer (or uInteger) parameter, then the HL register will be set with the value of that parameter on entry to the function.\r\n- If it takes a Long (or uLong), or fixed parameter, then the DE and HL registers will hold the 32 bit value of the parameter.\r\n- If it takes a float type parameter, then the registers C, DE and HL will hold the five bytes for that value.\r\n\r\nReturn is automatic based on the function return type in the same way: * 8 bit returns should be in the A register * 16 bit returns should be in HL * 32 bit returns should be in DEHL * 40 bit FLOAT returns should be in CDEHL.\r\n\r\nFastcall should ONLY be used with functions that take a single parameter. If you use more than one parameter, you'll have to deal with the stack (SP register) and restore it to the previous it had before your function was called.\r\n\r\n**Example**\r\n\r\n\tFUNCTION FASTCALL whatLetter (A as uByte) as uByte\r\n\t\tasm\r\n\t\t\tjp start\r\n\t\tdata:\tdefb \"A Man, A, Plan, A Canal, Panama\"\r\n\t\tstart:\tld hl,data\r\n\t\t\tld e,a\r\n\t\t\tld d,0\r\n\t\t\tadd hl,de\r\n\t\t\tld a,(hl)\r\n\t\tend asm\r\n\tend function\r\nThe above function, when called with whatLetter(*value*) will return the nth-th letter of the phrase \"A Man, A Plan, A Canal, Panama\".  \r\n\r\n**Notes**\r\n- Note that the A register already contains when the inline assembly is reached.\r\n- Note that we do NOT need to put a ret opcode on the end of the assembly. The compiler will do that for us.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/fastcall/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "FIXED": {
    "content": "# FIXED\r\n\r\n## Syntax\r\n\r\n```\r\nFIXED\r\n```\r\n\r\n## Description\r\n\r\nFIXED is an Decimal Type.\r\n\r\nFIXED are 4 bytes in size signed. -32767.9999847 - 32767.9999847 - 32 bits signed\r\n\r\nMore info https://zxbasic.readthedocs.io/en/docs/types/#types_1\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "FLASH": {
    "content": "# FLASH\n\n## Syntax\n```\nFLASH <value>\n```\nor\n```\nPRINT FLASH <value>;\n```\nThis can be used to change the permanent print settings, or the temporary ones.\nWhen used as a direct command:\n\n```\nFLASH n\n```\nbeing `n` either 0 (false) or 1 (true), then the subsequent print statements will print characters that have\ntheir `INK` and `PAPER` values swapped at regular intervals automatically by the Spectrum's ULA.\n\nJust as in Sinclair Basic, this command can be used as temporary colours by combining them with a print statement:\n\n```\nPrint INK 0;PAPER 7; FLASH 1; \"This is flashing black and white text\"\n```\nThis format does not change the permanent colour settings and only affects the characters printed within that print statement.\n\n## Remarks\n* This function is 100% Sinclair BASIC compatible.\n\n## See also\n\n* [PRINT](print.md)\n* [PAPER](paper.md)\n* [BORDER](border.md)\n* [BOLD](bold.md)\n* [INK](ink.md)\n* [ITALIC](italic.md)\n* [OVER](over.md)\n* [INVERSE](inverse.md)\n* [BRIGHT](bright.md)\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "FLOAT": {
    "content": "# FLOAT\r\n\r\n## Syntax\r\n\r\n```\r\nFLOAT\r\n```\r\n\r\n## Description\r\n\r\nFLOAT is an Decimal Type.\r\n\r\nFLOAT are 5 bytes in size not signed. 0-255 - 8 bits unsigned\r\n\r\nMore info https://zxbasic.readthedocs.io/en/docs/types/#types_1\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "FOR": {
    "content": "# FOR\r\n\r\n## Syntax\r\n\r\n```\r\nFOR n = n1 to n3 [ STEP n4 ] ... NEXT n\r\n```\r\n\r\n## Description\r\n\r\nA For...Next loop initializes iterator to startvalue, then executes the sentences, incrementing iterator by stepvalue until it reaches or exceeds endvalue. If stepvalue is not explicitly given it will set to 1.\r\n\r\n**Examples**\r\n\r\n\tFOR i = 1 TO 10: PRINT i: NEXT\r\n\r\n**Differences From Sinclair Basic**\r\n\r\n- The variable name after the NEXT statement is not required.\r\n- Note that variable types can cause issues with ZX Basic For...Next Loops. If the upper limit of the iterator exceeds the upper limit of the variable type, the loop may not complete. For example\r\n\r\n\r\n\tDIM i as UByte\r\n\r\n\tFOR i = 1 to 300\r\n\t\tPRINT i\r\n\tNEXT i\r\n\r\nClearly, since the largest value a byte can hold is 255, it's not possible for i in the above example to exceed 300. The variable will \"wrap around\" to 0 and as a result, the loop will not ever terminate. This can happen in much more subtle ways when STEP is used. There has to be \"room\" within the variable type for the iterator to exceed the terminator when it is being incremented by \"STEP\" amounts. \r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/for/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "FUNCTION": {
    "content": "# FUNCTION\n\nZX Basic allows function and subroutines declarations. This feature is new to ZX Basic.\nSinclair BASIC allowed limited function definitions using `DEF FN`.\n\nA function is a subroutine (like GO SUB) that is invoked directly.\nThe subroutine returns a value than can be used later.\nBASIC language already has some predefined functions, like `SIN`, `COS`, `PEEK` or `LEN`.\nThe user is now allowed to define his/her own functions.\n\n## Syntax\nBasic function declaration is:\n\n```\n FUNCTION <function name>[(<paramlist>)] [AS <type>]\n     <sentences>\n     ...\n END FUNCTION\n```\n## Example\nA simple function declaration:\n\n```\nREM This function receives and returns a byte\nFUNCTION PlusOne(x AS Byte) AS Byte\n    RETURN x + 1\nEND FUNCTION\n\nREM Using the function\nPRINT x; \" plus one is \"; PlusOne(x)\n```\n\nIf `AS` _type_ is omitted, the function is supposed to return a `Float`.\n\n```\nREM This function returns a float number because its type has been omitted.\nREM Also, the 'x' parameter will be converted to float,\nREM because it's type has been omitted too\n\nFUNCTION Square(x)\n    RETURN x^2\nEND FUNCTION\n\nREM Using the function\nPRINT \"Square of \"; x; \" is \"; Square(x)\n```\n\n## Recursion\nRecursion is a programming technique in which a function calls itself. A classical recursion example is the factorial function:\n\n```\nFUNCTION Factorial(x)\n    IF x < 2 THEN RETURN 1\n    RETURN Factorial(x - 1) * x\nEND FUNCTION\n```\n\nHowever, not using types explicitly might have a negative impact on performance.\nBetter redefine it using data types. Factorial is usually defined on unsigned integers and also returns an unsigned\ninteger. Also, keep in mind that factorial numbers tends to _grow up very quickly_ (e.g. Factorial of 10 is 3628800),\nso `ULong` [type](types.md) (32 bits unsigned) seems to be the most suitable for this function.\n\nThis version is faster (just the 1st line is changed):\n\n```\nFUNCTION Factorial(x AS Ulong) AS Ulong\n    IF x < 2 THEN RETURN x\n    RETURN Factorial(x - 1) * x\nEND FUNCTION\n```\n\n## Memory Optimization\nIf you invoke zxbasic using `-O1` (or higher) optimization flag the compiler will detect and ignore unused functions\n(thus saving memory space). It will also issue a warning (perhaps you forgot to call it?),\nthat can be ignored.\n\n## See Also\n\n* [SUB](sub.md)\n* [ASM](asm.md)\n* [END](end.md)\n* [RETURN](return.md)\n* [ByREF](byref.md)\n* [ByVAL](byval.md)\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "GETSCANCODE": {
    "content": "# GETKEYSCANCODE\r\n\r\n## Syntax\r\n\r\n```\r\n*scancode*=GETKEYSCANCODE()\r\n```\r\n\r\n## Description\r\n\r\nDetects if a single key has been pressed\r\n\r\n**Example**\r\n\r\n\tdo\r\n\t\tif GetKeyScanCode()=KEYA\r\n\t\t\tEND ' quits if A is pressed\r\n\t\tend if\r\n\tloop\r\n\r\n**Remarks**\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <keys.bas>\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "GOSUB": {
    "content": "# GO SUB\n\n\n## Syntax\n```\nGO SUB <label>\nGOSUB <label>\n```\nContinues the execution at the given label or line number.\nThe current execution point is pushed (stored) onto the stack,\nto be recovered later.\n\nWhen a [RETURN](return.md) is found and executed, the previous\nexecution point is popped out (recovered) from the stack and\ncontinues just after the GO SUB. This is a way to create simple\nsubroutines.\n\nThis sentence exists just for compatibility with legacy BASIC\ndialects. You should use [SUB](sub.md) or [FUNCTION](function.md) instead.\n\nGO SUB cannot be used within neither subroutines nor functions.\nYou can't GOSUB into a function or sub. So GOSUB is limited to\nglobal [scope](scope.md)\n\n> **WARNING**: Using GO SUB continuously without returning with\n> RETURN will eventually fill the stack (stack overflow) and crash\n> your program.\n\n### Example with GO SUB\n\n```\n10 LET number = 10\n20 GOSUB 1000 : REM calls the subroutine\n30 LET number = 20\n40 GOSUB 1000 : REM calls the subroutine again\n100  END : REM the program must end here to avoid entering the subroutine without using GOSUB\n1000 REM Subroutine that prints number + 1\n1010 PRINT \"number + 1 is \"; number + 1\n1020 RETURN : REM return to the caller\n```\n\nThis will output:\n\n```\nnumber + 1 is 11\nnumber + 1 is 21\n```\n\n\n## Remarks\n* This statement is Sinclair BASIC compatible.\n* GO SUB cannot be used within subrutines nor functions.\n\n## See also\n* [RETURN](return.md)\n* [FUNCTION](function.md)\n* [SUB](sub.md)\n* [GO TO](goto.md)\n* [ON ... GO TO](on_goto.md)\n* [ON ... GO SUB](on_gosub.md)\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "GOTO": {
    "content": "# GOTO\r\n\r\n## Syntax\r\n\r\n```\r\nGOTO *label*\r\n```\r\n\r\n## Description\r\n\r\nJump to GO TO label\r\n\r\n**Example**\r\n\r\n\tIF A = 10 GOTO APPLES\r\n\tIF A = 0 GOTO NOAPPLE\r\n\tAPPLES:\r\n\t\tPRINT \"WE HAVE APPLES\" : STOP\r\n\tNOAPPLES:\r\n\t\tPRINT \"NO APPLES\"\r\n\r\n**Remarks**\r\n- This is compatible with Sinclair Basic\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "HELP": {
    "content": "# HELP\r\n\r\n## Syntax\r\n\r\n```\r\nHELP\r\n```\r\n\r\n## Description\r\n\r\nHELP is not a keyword but a link to : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "IF": {
    "content": "# IF\r\n\r\n## Syntax\r\n\r\n```\r\nIF ... END IF\r\n```\r\n\r\n## Description\r\n\r\nIF is a very powerful control flow sentence that allows you to make decisions under specified conditions.\r\n\r\n**Syntax**\r\n\r\n\tIF expression [THEN] sentences [: END IF]\r\n\r\nOr\r\n\r\n\tIF expression [THEN]\r\n\t\tsentences\r\n\t [ELSEIF expression [THEN] sentences]\r\n\t [ELSEIF expression [THEN] sentences]\r\n\t ...\r\n\t [ELSE sentences]\r\n\tEND IF\r\n\r\n**Examples**\r\n\r\n\tIF a < 5 THEN PRINT \"A is less than five\" ELSE PRINT \"A is greater than five\"\r\n\r\nSentences might be in multiple lines:\r\n\r\n\tIf a < 5 Then\r\n        Print \"A is less than five\"\r\n\t\t\ta = a + 5\r\n\tElse\r\n        Print \"A is greater than five\"\r\n\r\nSince **IF** is a *sentence*, it can be nested; however, remember that *every* **IF** *must be closed with* **END IF** when the line is split after **THEN** (multiline **IF**):\r\n\r\n\tIf a < 5 Then\r\n        Print \"A is less than five\"\r\n\t\tIf a > 2 Then\r\n\t\t\tPrint \"A is less than five but greater than 2\"\r\n\t\tEnd If\r\n\tElse If a < 7 Then\r\n\t\t\tPrint \"A is greater or equal to five, but lower than 7\"\r\n\t\tElse\r\n\t\t\tPrint \"A is greater than five\"\r\n\t\tEnd if\r\n\tEnd if\r\n\r\n**Using ELSEIF**\r\n\r\nIn the example above, you see that nesting an IF inside another one could be somewhat verbose and error prone. It's better to use the ELSEIF construct. So the previous example could be rewritten as:\r\n\r\n\tIf a < 5 Then\r\n\t\tPrint \"A is less than five\"\r\n\t\tIf a > 2 Then\r\n\t\t\tPrint \"A is less than five but greater than 2\"\r\n\t\tElseIf a < 7 Then\r\n\t\t\tPrint \"A is greater or equal to five, but lower than 7\"\r\n\t\tElse\r\n\t\t\tPrint \"A is greater than five\"\r\n\tEnd If\r\n\r\n**Remarks**\r\n- This sentence is extended allowing now multiline IFs and also compatible with the Sinclair BASIC version.\r\n- Starting from version 1.8 onwards the trailing END IF is not mandatory for single-line IFs, for compatibility with Sinclair BASIC\r\n\r\n- The THEN keyword can be omitted, but keep in mind this might reduce code legibility.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/if/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "IN": {
    "content": "# IN\r\n\r\n## Syntax\r\n\r\n```\r\nIN *port*\r\n```\r\n\r\n## Description\r\n\r\nRead ports into variable\r\n\r\n**Example**\r\n\r\n\ta = IN $df\r\n\r\n**Remarks**\r\n- This is compatible with Sinclair Basic\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INCLUDE": {
    "content": "# INCLUDE\r\n\r\n## Syntax\r\n\r\n```\r\n#INCLUDE \\<library\\>\r\n```\r\n\r\n## Description\r\n\r\nInstructs ZXBasic to include an external .bas file which contains additional functions.\r\n\r\n**Syntax**\r\n\r\n\t#INCLUDE <keys.bas> : REM includes the keys.bas library required for GetKeyScanCode\r\n\t#INCLUDE <nextbuild.bas> : REM includes the nextlib.bas library\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INK": {
    "content": "# INK\r\n\r\n## Syntax\r\n\r\n```\r\nINK *value*, PRINT INK *value*;\r\n```\r\n\r\n## Description\r\n\r\nThis can be used to change the permanent print settings, or the temporary ones. When used as a direct command:\r\n\r\n**Example**\r\n\r\n\tINK 2\r\n- 0 - Black\r\n- 1 - Blue\r\n- 2 - Red\r\n- 3 - Magenta\r\n- 4 - Green\r\n- 5 - Cyan\r\n- 6 - Yellow\r\n- 7 - White\r\n- 8 - Transparent (Does not change paper value in square being printed)\r\n- 9 - Contrast\r\n\r\nJust as in Sinclair basic, this command can be used as temporary colours by combining them with a print statement:\r\n\r\n\tPrint ink 2; \"This is red text\"\r\n\r\nThis format does not change the permanent colour settings and only affects the characters printed within that print statement.\r\n\r\n**Remarks**\r\n\r\n- This function is Near Sinclair BASIC compatible.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/ink/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INKEY": {
    "content": "# INKEY\r\n\r\n## Syntax\r\n\r\n```\r\nINKEY *expression*, INKEY$ *expression*;\r\n```\r\n\r\n## Description\r\n\r\nThe INKEY function is used to return a value of a keypress at the moment the function is accessed. Inkey does not wait for user input. It returns a single character string containing the key pressed. Use of Shift or Caps-Lock makes the character upper case. In some cases, a non-printable string may be returned; for example if cursor keys are pressed at the time the function is run.\r\n\r\nIf no key is pressed, it returns a null string (\"\").\r\n\r\nFor compatibility with Sinclair Basic, INKEY$ is also a valid synonym.\r\n\r\n\tWHILE INKEY <> CHR(13) : ' CHR(13) is the code for the ENTER key\r\n\t\tPRINT INKEY; : ' PRINTS A KEYPRESS\r\n\r\n\t\tWHILE INKEY<>\"\"\r\n\t\t\t' WAIT Until the key isn't pressed any more.\r\n\t\tEND WHILE\r\n\r\n\tEnd WhILE\r\n\r\nThe above code will echo keys pressed to the screen. Note that the loop has to be held up to wait until the key is no longer pressed, in order to prevent the same character being reprinted many times.\r\n\r\n**Remarks**\r\n\r\n- This sentence is 100% Sinclair BASIC Compatible.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/inkey/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INPUT": {
    "content": "# INPUT\r\n\r\n## Syntax\r\n\r\n```\r\nvariable = INPUT(max_length)\r\n```\r\n\r\n## Description\r\n\r\nIssues a cursor to the screen, waits for the user to type and returns the user's input when the user presses ENTER.\r\n\r\n\tvariable$ = INPUT(32)\r\n\tPRINT variable$\r\n\r\nMax_length is the number of characters the INPUT function will accept as a maximum.\r\n\r\n**Requirements**\r\n\r\nINPUT is a library function that must be included before it can be used. Use the following directive:\r\n\r\n\t#include <input.bas>\r\n\r\n**Remarks**\r\n\r\n- This function is similar, but not equivalent to the INPUT statement available in Sinclair BASIC.\r\n- Note that this function ALWAYS RETURNS A STRING, which is very different from Sinclair BASIC's INPUT statement.\r\n- This function places the Input cursor at the last print position, not at the bottom of the screen. Remember that ZX Basic allows access to all 24 screen lines, so PRINT AT 24,0; sets the PRINT cursor to the bottom of the screen.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/input/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INT": {
    "content": "# INT\r\n\r\n## Syntax\r\n\r\n```\r\nINT *expression*\r\n```\r\n\r\n## Description\r\n\r\nConverts a non-integer value into an integer type.\r\n\r\n\ta = 3.14 : ' a float\r\n\tb = int (a) : ' b = 3\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INTEGER": {
    "content": "# INTEGER\r\n\r\n## Syntax\r\n\r\n```\r\nINTEGER\r\n```\r\n\r\n## Description\r\n\r\nINTEGER is an Integral Type.\r\n\r\nINTEGER are 2 bytes in size not signed. -32768-32768 - 16 bits signed\r\n\r\nMore info https://zxbasic.readthedocs.io/en/docs/types/#types_1\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INVERSE": {
    "content": "# INVERSE\r\n\r\n## Syntax\r\n\r\n```\r\nINVERSE *value*,PRINT INVERSE *value*;\r\n```\r\n\r\n## Description\r\n\r\nThis can be used to change the permanent print settings, or the temporary ones. When used as a direct command:\r\n\r\n\tINVERSE n\r\n\r\nwhere n is either 0 (false) or 1 (true), then the subsequent print statements will have their INK and PAPER values swapped from the current settings for INK and PAPER.\r\n\r\nJust as in Sinclair basic, this command can be used as temporary colours by combining them with a print statement:\r\n\r\n\tPrint INK 0;PAPER 7; INVERSE 1; \"This WHITE text on BLACK background\"\r\n\r\nNote that the INK and PAPER are swapped because of the INVERSE 1 This format does not change the permanent colour settings and only affects the characters printed within that print statement.\r\n\r\n**Remarks**\r\n\r\n- This function is 100% Sinclair BASIC compatible.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/inverse/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ITALIC": {
    "content": "# ITALIC\r\n\r\n## Syntax\r\n\r\n```\r\nITALIC *value*, PRINT ITALIC *value*;\r\n```\r\n\r\n## Description\r\n\r\nThis can be used to change the permanent print settings, or the temporary ones. When used as a direct command:\r\n\r\n**Example**\r\n\r\n\tITALIC n\r\n\r\nwhere n is either 0 (false) or 1 (true), then the subsequent print statements will have their INK pixels slewed left at the top, and right at the bottom, making text appear italicized.\r\n\r\nThis command can be used as temporary colours by combining them with a print statement:\r\n\r\n\tPrint INK 0;PAPER 7; ITALIC 1; \"This is ITALIC BLACK text on WHITE\"\r\n\r\nThis format does not change the permanent colour settings and only affects the characters printed within that print statement.\r\n\r\n**Remarks**\r\n\r\n- This statement is NOT Sinclair BASIC compatible.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/ink/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LABELS": {
    "content": "# Labels\n\nLabels are [identifiers](identifier.md) where the program execution flow can _jump_ into using either [GO TO](goto.md) or [GO SUB](gosub.md).\nUnlike [variables](variable.md) identifiers, their [scope](scope.md) is **always global** (even if declared inside\nfunctions or subroutines). Usage of labels is discouraged.\n\nIn ZX BASIC, line numbers are treated as labels:\n\n```\n10 REM An endless print loop\n20 PRINT \"Hello world!\"\n30 GO TO 20\n```\n\nSince line numbers are _just labels_, the order sequence is irrelevant.\nThe following listing is equivalent to the above one. Notice the\nout-of-order line sequence:\n\n```\n10 REM An endless print loop\n30 PRINT \"Hello world!\"\n20 GO TO 30\n```\n\n\n### Declaring labels\n\nIdentifiers can be used as labels.\nA label identifier is declared by writing it at the beginning of a line, followed by a colon:\n\n```\nREM Declaring a label\nmylabel:\n```\n\nYou can _use_ the label with [GO TO](goto.md) and [GO SUB](gosub.md) sentences,\nand with the [@ operator](addroperator.md): the previous example can be rewritten using labels instead of line numbers:\n\n```\nendlessloop:\n  PRINT \"Hello world!\"\n  GO TO endlessloop\n```\n\nA label can also be referred before it has been declared:\n\n```\n  GO TO EndOfRoutine\n  REM Instructions here are skipped\n\nEndOfRoutine:\n  PRINT \"End Of Routine\"\n```\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LBOUND": {
    "content": "# LBOUND\r\n\r\n## Syntax\r\n\r\n```\r\nLBOUND (*array variable*), LBound(*array variable*, *dimension*)\r\n```\r\n\r\n## Description\r\n\r\nReturns the array lower bound of the given . If the is not specified, it defaults to 1. If the specified is 0, then total number of dimensions is returned.\r\n\r\n**Examples**\r\n\r\n\tDIM a(3 TO 5, 2 TO 8)\r\n\tPRINT LBound(a, 2) : ' Prints 2\r\n\tPRINT Lbound(a) : ' Prints 3, because dimension defaults to 1\r\n\r\nThe result is always a 16bit integer value.\r\n\r\nIf the is 0, then the number of dimension in the array is returned (useful to guess the number of dimensions of an array):\r\n\r\n\tDIM a(3 TO 5, 2 TO 8)\r\n\tPRINT LBound(a, 0): ' Prints 2, since 'a' has 2 dimensions\r\n\r\n**Remarks**\r\n\r\n- This function does not exists in Sinclair BASIC.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/lbound/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LEN": {
    "content": "# LEN\r\n\r\n## Syntax\r\n\r\n```\r\nLEN string\r\n```\r\n\r\n## Description\r\n\r\nReturns the length of *string\r\n\r\n\ta$ = \"NextBuild\"\r\n\tPRINT LEN a$ : ' Will print 9\r\n\r\n\t a = 5\r\n\r\n**Remarks**\r\n\r\n- This is almost compatible with ZX Basic\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/len/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LET": {
    "content": "# LET\r\n\r\n## Syntax\r\n\r\n```\r\nLET *variable* = *expression*\r\n```\r\n\r\n## Description\r\n\r\nLet sentence is used to assign a value to a variable or array element. It can be omitted. E.g.:\r\n\r\n\tLET a = 5\r\n\r\nWhich cal also be written as:\r\n\r\n\t a = 5\r\n\r\n**Remarks**\r\n\r\n- This function does not exists in Sinclair BASIC.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/let/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LIBRARY": {
    "content": "# Library\n\n## Library of Routines and Functions\n\nThis is a list of additions to the language that have been produced. They extend the functionality of the compiler by\neffectively adding reserved words to the language. At their heart, they are all SUB or FUNCTION sets.\n\nFor the standard library go to the [standard library](library/stdlib.md) page.\n\n\n---\n## Non-standard libraries\n\nThese ones might not be bundled yet with ZX Basic (mostly due to lack of time). If so, you have\nto copy the listing shown in this wiki and create the .bas file yourself, as explained in the following\nsection.\n\n### How to Include a Library Function\nYou can either copy and paste the `SUB` or `FUNCTION` into your code, or, perhaps more easily,\nsave the text as the recommended name (e.g. fSqrt.bas) and use `#include \"fSqrt.bas\"` at the start of the program.\nNote that the file has to be in the same folder or directory as the original in order for the compiler to find it.\nIf the code is included in the ZX Basic standard library, this is mentioned in the description.\nIt's then possible to add the code simply with a `#include` directive.\n\n#### Maths Library\n* [distance.bas](library/distance.bas.md)\n<br />Fast distance calculation - SQR(x<sup>2</sup> + y<sup>2</sup>) - using taylor series expansion.\nAccuracy tends to drop as x and y get large, but is about 5 times faster even than using iSqrt\n(and about 750 times faster than using the ROM sqr function).\n\n* [Faster Trigonometric Functions - fSin, fCos, fTan](library/fsin.bas.md)\n<br />Sin giving you a headache? At the cost of a few bytes, here are faster and less accurate versions for quick and\ndirty games calculations.\n\n* [fSqrt.bas](library/fsqrt.bas.md)\n<br />SQR too slow? Here's a faster (and completely accurate - at least as accurate as Sinclair Basic) replacement for\nthe internal SQR function.\n\n* [iSqrt.bas](library/isqrt.bas.md)\n<br />[fSqrt.bas](library/fsqrt.bas.md) still too slow? Don't need _quite_ so accurate an answer? Try Integer Square roots!\n\n* [randomStream.bas](library/randomstream.bas.md)\n<br />A random stream generator. Fast and efficient. ZX Basic does use this generator, but it's locked to float output.\nHere are some alternative functions using faster integer and fixed output.\n\n#### Graphics Library\n* [attrAddress.bas](library/attraddress.md)\n<br /> Function to get the attribute address for a given X-Y character co-ordinate.\n\n* [clearBox.bas](library/clearbox.md)\n<br /> Sub to clear a subset of the screen - a window defined with a character box.\n\n* [crslin.bas](library/csrlin.md)\n<br /> Function to get the current cursor vertical co-ordinate.\n\n* [fastPlot.bas](library/fastplot.md)\n<br /> Routine to plot a pixel on screen (without attributes - speed optimized)\n\n* [HRPrint.bas](library/hrprint.bas.md)\n<br /> High Resolution Print<br /> Subroutine to print characters at any pixel level position on the screen,\ninstead of just character positions. (Rather slow for sprites, but fine if speed isn't needed)\n\n* [HRPrintFast.bas](library/hrprintfast.bas.md)\n<br /> High Resolution Print<br /> Subroutine to print characters at any pixel level position on the screen,\ninstead of just character positions. (20% faster per character, but much larger version using lookup tables)\n\n* [hMirror.bas](library/hmirror.bas.md)\n<br /> Function to mirror the bits in a byte - the basis of printing, say a left facing sprite,\nif all you have are right facing graphics stored.\n\n* [pos.bas](library/pos.md)\n<br /> Function to get the current cursor horizontal co-ordinate.\n\n* [windowPaint.bas](library/windowpaint.md)\n<br /> Set attributes in a rectangle without changing the bitmap.\n\n* [putchars.bas](library/putchars.bas.md)\n<br /> Subroutines to put graphics data to the screen in a block. Also contains routines for attribute painting as a\nblock. Passable for character based sprites.\n\n* [scrAddress.bas](library/scraddress.md)\n<br /> Function to get the top screen address for a given X-Y character co-ordinate.\n\n* [putTile.bas](library/puttile.md)\n<br /> Subroutine to paint a 2X2 character tile to the screen from a given data address, with attributes.\nUses PUSH/POP to the screen memory for speed.\n\n* [pixelScroll.bas](library/pixelscroll.md)\n<br /> Subroutines to scroll the screen by a specified number of pixel rows. (No attribute scroll)\n\n* [windowScrollUP.bas](library/windowscrollup.md)\n<br /> Subroutine to character scroll a window of screen - good for that sidebar of information.\nKeep status updates scrolling in and sliding up without affecting the game window.\n\n* [windowAttrScrollUP.bas](library/windowattrscrollup.md)\n<br /> Subroutine to character scroll the attributes of a window of screen - really a handy addendum utility\nfor [windowScrollUP.bas](library/windowscrollup.md)\n\n#### Text Handling Library\n\n* [asc.bas](library/asc.bas.md)\n<br /> Ascii Code of a character in a string. Compatible with FreeBasic\n\n* [doubleSizePrint.bas](library/doublesizeprint.bas.md)\n<br /> Prints to the screen with Double Size Characters\n\n* [HRPrint.bas](library/hrprint.bas.md)\n<br /> High Resolution Print<br /> Subroutine to print characters at any pixel level position on the screen,\ninstead of just character positions. (Rather slow for sprites, but fine if speed isn't needed)\n\n* [propPrint.bas](library/propprint.bas.md)\n<br /> Need characters to look more professional? LCD has weighed in with a Proportional Printing routine -\nand one that lets you set text position with Pixel accuracy!\n\n* [print42.bas](library/print42.bas.md)\n<br /> Need more screen space? You could try the 42 Character Printing routine. Text still lines up in columns,\nand attributes are allowed (with limitations).\n\n* [print64.bas](library/print64.bas.md)\n<br /> Need even MORE screen space? Here's a 64 characters per line Subroutine. Works in a very similar way to print42,\nwith printat64 and print64 subs.\n\n* [Print64x32.bas](library/print64x32.bas.md)\n<br /> What, just 64 chars to a line not enough? This is 64X32 Character printing.\nWill print 64 characters to a line (grid, not proportional), and 32 lines of text to a screen.\nUpping the standard 768 character screen to 2048 characters of text on one screen at once.\nWorks in a similar way to print42. This version uses screen tables.\n\n####Compression / Decompression Library\n\n* [megaLZDepack.bas](library/megalz.bas.md)\n<br /> Routine wrapping the megaLZ decompression algorithm.\n\n* [zx0](library/zx0.md)\n<br /> Routine wrapping the ZX0 decompression algorithm.\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "LN": {
    "content": "# LN\r\n\r\n## Syntax\r\n\r\n```\r\nLN expression\r\n```\r\n\r\n## Description\r\n\r\na = 5\r\n\r\n**Remarks**\r\n\r\n- This function does exist in Sinclair BASIC.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/ln/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LOAD": {
    "content": "# LOAD\r\n\r\n## Syntax\r\n\r\n```\r\nLOAD \"xxx\" CODE, LOAD \"xxx\" CODE START, LOAD \"xxx\" CODE START, LENGTH, LOAD \"xxx\" SCREEN$\r\n```\r\n\r\n## Description\r\n\r\nThe below commands work in a manner identical to Sinclair Basic. These do NOT load from SD card, please check LoadSDBank and LoadSD.\r\n\r\n\t LOAD \"file\" CODE 32768, 2048\r\n\r\n\t LOAD \"xxx\" CODE\r\n\t LOAD \"xxx\" CODE START\r\n\t LOAD \"xxx\" CODE START, LENGTH\r\n\t LOAD \"xxx\" SCREEN$\r\n\r\n**Remarks**\r\n\r\n- The save command should save bytes in a format that is 100% Sinclair BASIC Compatible\r\n- For LOAD and VERIFY, when a R-Tape Loading error occurs, the program will not stop.\r\n- You have to check PEEK 23610 (ERR_NR) for value 26. If that value exists, then the LOAD/VERIFY operation failed.\r\n- At this moment, LOAD/SAVE/VERIFY can be interrupted by the user by pressing BREAK/Space, which exits the program and returns to the ROM BASIC. \r\n- This may be changed in the future to behave like the previous point (signaling the break in ERR_NR and returning).\r\n- When using LOAD \"xxx\" DATA... you won't see the message \"Number array:\" or \"Char array:\", but \"Bytes:\" instead. \r\n- This is because ZX BASIC always uses bytes (LOAD/SAVE ... CODE) for storing user variables (ZX BASIC is machine code, so the idea of BASIC variables doesn't apply).\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/load/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LONG": {
    "content": "# LONG\r\n\r\n## Syntax\r\n\r\n```\r\nLONG\r\n```\r\n\r\n## Description\r\n\r\nLONG is an Integral Type.\r\n\r\nLONG are 4 bytes in size and signed. -2,147,483,648 - 2,147,483,647 - 32 bits signed\r\n\r\nMore info https://zxbasic.readthedocs.io/en/docs/types/#types_1\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LOOP": {
    "content": "# LOOP\r\n\r\n## Syntax\r\n\r\n```\r\nDO ... LOOP\r\n```\r\n\r\n## Description\r\n\r\nDO ... LOOP Seen DO for more information \r\n\r\nInfinite loops\r\n\r\n\tDO\r\n\tsentences\r\n\tLOOP: This loop repeats forever.\r\n\r\nLooping UNTIL\r\n\r\n\tDO\r\n\tsentences\r\n\tLOOP UNTIL condition\r\n\r\nYou can also put the condition at the beginning, this way:\r\n\r\n\tDO UNTIL condition\r\n\tsentences\r\n\tLOOP\r\n\r\nhttps://zxbasic.readthedocs.io/en/docs/do/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MOD": {
    "content": "# MOD\r\n\r\n## Syntax\r\n\r\n```\r\nn MOD n2\r\n```\r\n\r\n## Description\r\n\r\nMODULUS of value\r\n\r\n\t a = 32 MOD 6\r\n\r\n**Remarks**\r\n\r\n- This function does exist in Sinclair BASIC.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/mod/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MULTIKEYS": {
    "content": "# MultiKeys\n\nLibrary: `#include <keys.bas>`\n\nReturns whether any of the given keys is being pressed.\nUnlike [INKEY$](../../inkey.md), it can detect multiple keys pressed at once\n(with some restrictions).\n\n\n### Syntax\n`MultiKeys(KeyCode1 bOR KeyCode2 bOR ...)`\n\nReturns whether any of the given keys was pressed. If no key was pressed, returns 0.\nIt's possible to check for more than one key pressed at once, and to decode\nwhich keys were pressed by examining the returned value.\n\n## Examples\n\n```\n# include <keys.bas>\n\nDO\nLOOP UNTIL MultiKeys(KEYH bOR KEYL)\n\nPAUSE 10  'Needed to allow the user to wait press 2 keys\nx = MultiKeys(KEYH bOR KEYL)\nIF x bAND KEYH PRINT \"Key H was pressed\"\nIF x bAND KEYL PRINT \"Key L was pressed\"\n\n```\nWill print whether the Key H o the Key L or both bas been pressed.\n\nChecking for 2 or more keys will work only if these keys are in the same\n\"row half\", that is: in the same row and in the same group of 5 keys of that\nrow (the left one or the right one)\n\n### See also\n\n* [GetKey](getkey.md)\n* [GetKeyScanCode](getkeyscancode.md)\n\n\nBack to parent page: [Keys library](../keys.bas.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "NOT": {
    "content": "# NOT\r\n\r\n## Syntax\r\n\r\n```\r\na NOT b\r\n```\r\n\r\n## Description\r\n\r\nNOT is a Logical Operator. Performs the Logical Negation and returns TRUE if the arguments is False and vice versa. \r\n\r\n**Example**\r\n\r\n\ta = b NOT c\r\n\r\n\t|A|\tResult\t|\r\n\t|F|\t\tT\t|\r\n\t|T|\t\tF\t|\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/operators/#NOT\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ON_GOSUB": {
    "content": "# ON ... GOSUB\n\n## Syntax\n```\nON <expression> GOSUB <label0>, <label1>, <label2>, ..., <labelN>\nON <expression> GO SUB <label0>, <label1>, <label2>, ..., <labelN>\n```\n\nTransfers control to one of a series of specified line numbers or labels based on the value of an expression. This statement expects a `RETURN` statement in the subroutine to return control to the line following the `ON ... GOSUB` statement.\n\n> This statement uses a **jump table** for faster execution.\n\n### Parameters\n- `<expression>`: An integer expression that determines which label to jump to. It can be any numeric expression.\n- `<label0>, <label1>, <label2>, ..., <labelN>`: A comma-separated list of line numbers or labels.\n  These are the destinations for control transfer based on the value of `<expression>`.\n\nThe value of `<expression>` is converted to a [uByte](types.md#integral) (Unsigned Byte), so,\nfor example, a value of 256 will be converted to 0.\nIf the `<expression>` value is greater than the number of labels,\nthis instruction will be ignored and the execution will continue normally.\n\n### Example with ON ... GOSUB\n```BASIC\n 5 REM Random value between [0..3] both included\n10 LET X = INT(RND * 4): LET ok = 0\n20 ON X GOSUB 50, 100, 150: IF ok THEN END\n30 PRINT \"Invalid choice: \"; X\n40 GOTO 10\n50 PRINT \"You chose option 0\": LET ok = 1\n60 RETURN\n100 PRINT \"You chose option 1\": LET ok = 1\n110 RETURN\n150 PRINT \"You chose option 2\": LET ok = 1\n160 RETURN\n```\n\nIn this example:\n * If `X` is 0, the execution will jump to line 50.\n * If `X` is 1, it will jump to line 100.\n * If `X` is 2, it will jump to line 150.\n\nIn each block, after executing the corresponding print statement, the program sets the `ok` variable to 1, indicating a valid choice. Then, the `RETURN` statement returns control to the line following the `ON ... GOSUB` statement.\n\n## Remarks\n- The `<expression>` is evaluated, and if it results in a value outside the range 0 to N (where N is the number of labels), no action is taken.\n- `ON ... GOSUB` is a structured programming alternative to multiple `IF...THEN...GOSUB` statements.\n\n## Compatibility\n- This statement is not compatible with Sinclair BASIC.\n\n## See also\n- [GO TO](goto.md)\n- [GO SUB](gosub.md)\n- [ON ... GOTO](on_goto.md)\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ON_GOTO": {
    "content": "# ON ... GOTO\n## Syntax\n```\nON <expression> GOTO <label0>, <label1>, <label2>, ..., <labelN>\nON <expression> GO TO <label0>, <label1>, <label2>, ..., <labelN>\n```\n\nTransfers control to one of a series of specified line numbers or labels based on the value of an expression.\n\n### Parameters\n- `<expression>`: An integer expression that determines which label to jump to. It can be any numeric expression.\n- `<label0>, <label1>, <label2>, ..., <labelN>`: A comma-separated list of line numbers or labels. These are the destinations for control transfer based on the value of `<expression>`.\n\nThe value of expression is converted to a [uByte](types.md#integral) (Unsigned Byte), so, for example, a value of 256 will be converted to 0.\nIf the expression value is greater than the number of labels, this instruction will be ignored and the execution will continue normally.\n\n> This sentence uses a **jump table** for faster execution.\n\n### Example with ON ... GOTO\n```BASIC\n 5 REM Random value between [0..3] both included\n10 LET X = INT(RND * 4)\n20 ON X GOTO 50, 100, 150\n30 PRINT \"Invalid choice: \"; X\n40 GOTO 10\n50 PRINT \"You chose option 0\"\n60 END\n100 PRINT \"You chose option 1\"\n110 END\n150 PRINT \"You chose option 2\"\n160 END\n```\n\nIn this example, \n * if `X` is 0, the execution will jump to line 50\n * if `X` is 1, it will jump to line 100;\n * if `X` is 2, it will jump to line 150.\n * If `X` is outside this range, the `ON ... GOTO` sentence will be ignored. </br>\n   The program will print _\"Invalid choice\"_ and ask for input again.\n\n## Remarks\n- The `<expression>` is evaluated, and if it results in a value outside the range 0 to N (where N is the number of labels), no action is taken.\n- `ON ... GOTO` is a structured programming alternative to multiple `IF...THEN...GOTO` statements.\n\n## Compatibility\n- This statement is not compatible Sinclair BASIC.\n\n## See also\n- [GO TO](goto.md)\n- [GO SUB](gosub.md)\n- [ON ... GO SUB](on_gosub.md)",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "OR": {
    "content": "# OR\r\n\r\n## Syntax\r\n\r\n```\r\na OR b\r\n```\r\n\r\n## Description\r\n\r\nOR is a Logical Operator. Performs the Logical Disjunction and returns TRUE if any of the arguments are TRUE. \r\n\r\n**Example**\r\n\r\n\ta = b OR c\r\n\r\n\t| A | B | Result |\r\n\t| F | F | \tF\t |\r\n\t| F | T | \tT\t |\r\n\t| T | F | \tT\t |\r\n\t| T | T | \tT\t |\r\nMore info : https://zxbasic.readthedocs.io/en/docs/operators/#OR\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ORG": {
    "content": "# ORG\r\n\r\n## Syntax\r\n\r\n```\r\n'!org=*address*\r\n```\r\n\r\n## Description\r\n\r\nSets the start address of the program. If no org is set *32768* is used.\r\n\r\n**Example**\r\n\r\n\t'!org=24576\t\t' starts the program at 24576\r\n\t'!org=$6000\t\t' starts the program at $6000\r\n\r\n**Requires**\r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "OUT": {
    "content": "# OUT\r\n\r\n## Syntax\r\n\r\n```\r\nOUT *port,value*\r\n```\r\n\r\n## Description\r\n\r\nSends a byte of value to the specified port\r\n\r\n**Example**\r\n\r\n\t OUT 254, 0 : ' sets border to blank, border is on port 254\r\n\r\n**Remarks**\r\n\r\n- This identical to Sinclair BASIC.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "OVER": {
    "content": "# OVER\n\n## Syntax\n```\nOVER <value>\n```\n\nor\n\n```\nPRINT OVER <value>;\n```\n\nThis can be used to change the permanent print settings, or the temporary ones. When used as a direct command:\n\n```\n OVER 0\n OVER 1\n OVER 2\n OVER 3\n```\nthen the subsequent print statements will overwrite the previous ones with differing effects.\n\n * After an `OVER 0` command, the characters are simply replaced, as per usual.\n   This behaves just like the Sinclair Basic OVER 0 command.\n\n * After `OVER 1`, subsequent characters are combined with an Exclusive OR (XOR) - that is\n   to say pixels are flipped by overprinting with another ink pixel, and left alone by overprinting with a paper pixel.\n   This behaves identically to the OVER 1 Sinclair Basic Command.\n\n * After `OVER 2`, subsequent prints are combined using an AND function - that is only\n   pixels will remain where BOTH characters has pixels before. If either had a paper pixel, what is left is a paper pixel.\n   This is not Sinclair Basic compatible, and is an extension.\n\n * After `OVER 3`, Subsequent prints are combined using an OR function - that is pixels remain where EITHER\n   character had pixels before. If either had an ink pixel, what is left there is an ink pixel.\n   This is not Sinclair Basic compatible, and is an extension.\n\nJust as in Sinclair basic, these commands can be used as temporary colours by combining them with a print statement:\n\n```\nPrint Over 2; \"This is combined as an AND function\"\n```\n\nThis format does not change the permanent colour settings and only affects the characters\nprinted within that print statement.\n\n## Remarks\n* This function is Sinclair BASIC compatible.\n* This function _extends_ Sinclair BASIC.\n\n## See also\n* [PRINT](print.md)\n* [PAPER](paper.md)\n* [INK](ink.md)\n* [BOLD](bold.md)\n* [INVERSE](inverse.md)\n* [ITALIC](italic.md)\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PAPER": {
    "content": "# PAPER\r\n\r\n## Syntax\r\n\r\n```\r\nPAPER *value*, PRINT PAPER *value*;\r\n```\r\n\r\n## Description\r\n\r\nThis can be used to change the permanent print settings, or the temporary ones. When used as a direct command:\r\n\r\n**Example**\r\n\r\n\tPAPER 2\r\n- 0 - Black\r\n- 1 - Blue\r\n- 2 - Red\r\n- 3 - Magenta\r\n- 4 - Green\r\n- 5 - Cyan\r\n- 6 - Yellow\r\n- 7 - White\r\n- 8 - Transparent (Does not change paper value in square being printed)\r\n\r\nJust as in Sinclair basic, this command can be used as temporary colours by combining them with a print statement:\r\n\r\n\tPrint paper 2; \"This is on a red background\"\r\n\r\nThis format does not change the permanent colour settings and only affects the characters printed within that print statement.\r\n\r\n**Remarks**\r\n\r\n- This function is 100% Sinclair BASIC compatible.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/ink/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PAUSE": {
    "content": "# PAUSE\r\n\r\n## Syntax\r\n\r\n```\r\nPAUSE n\r\n```\r\n\r\n## Description\r\n\r\nPAUSE CPU for n frames (0-65535) if n=0 means PAUSE forever until a keypress.\r\n\r\n**Examples**\r\n\r\n\tPAUSE 0 : REM This will wait for a keypress\r\n\tPAUSE 1 : REM this will wait 1 frame\r\n\r\n**Remarks**\r\n\r\n- Using PAUSE will call ROM routine which may cause issues writing code for the NEX which can page out any part of memory. Use **WaitRetrace2(n)** and **WaitKey()** instead.\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PEEK": {
    "content": "# PEEK\r\n\r\n## Syntax\r\n\r\n```\r\nPEEK (address), PEEK (typeToRead, address)\r\n```\r\n\r\n## Description\r\n\r\nReturns the memory content (byte) stored at *address* position. If *address* is not a 16 bit unsigned integer, it will be converted to such type before reading the memory.\r\n\r\nWhen *typeToRead* is specified, the given type is read from memory; otherwise the type of the read value is supposed to be *ubyte* (8 bit unsigned integer).\r\n\r\nThe type of the returning value is the *typeToRead* specified, or *ubyte* if no type is specified.\r\n\r\n**Examples**\r\n\r\nThe following example reads a 16 bit unsigned integer at position 23675 (this is the System Variable for UDG in Sinclair BASIC systems):\r\n\r\n\tPRINT \"Address of UDG is \"; peek(23675) + 256 * peek(23676)\r\n\r\nBut it's faster to specify the type of the value:\r\n\r\n\tPRINT \"Address of UDG is \"; peek(uinteger, 23675)  \r\n\r\n**Remarks**\r\n\r\n- This function is Sinclair BASIC compatible.\r\n- This function extends the Sinclair BASIC version.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/peek/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PI": {
    "content": "# PI\r\n\r\n## Syntax\r\n\r\n```\r\nPI\r\n```\r\n\r\n## Description\r\n\r\nReturns the value of PI\r\n\r\n**Example**\r\n\r\n\ta = PI * 2\r\n\r\n**Remarks**\r\n\r\n- This function is Sinclair BASIC compatible.\r\n- This function extends the Sinclair BASIC version.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PLOT": {
    "content": "# PLOT\r\n\r\n## Syntax\r\n\r\n```\r\nPLOT x,y, PLOT *Attribute Modifiers*; x, y\r\n```\r\n\r\n## Description\r\n\r\nPlots a *pixel* at coordinates (x, y) (pixel column, pixel row). Coordinate (0, 0) designates bottom-left screen corner.\r\n\r\nPLOT is enhanced in ZX BASIC to allow plotting in the last two screen rows (this was not possible in Sinclair BASIC). So now we have 16 lines more (192 in total). Sinclair BASIC only used top 176 scan-lines. This means that in Sinclair BASIC\r\n\r\n\tPLOT x, y\r\n\r\nmust be translated to ZX BASIC as\r\n\r\n\tPLOT x, y + 16\r\n\r\nif you want your drawing to appear at the same vertical screen position Sinclair BASIC uses.\r\n\r\n**Remarks**\r\n\r\n- This function is not strictly Sinclair BASIC compatible since it uses all 192 screen lines instead of top 176. If you translate PLOT & DRAW commands from Sinclair BASIC as is your drawing will be shifted down 16 pixels.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/plot/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "POKE": {
    "content": "# POKE\n\n## Syntax\n\n```\npoke <address>, <value>\npoke <type> <address>, <value>\n```\n\n## Description\n\nStores the given (numeric) _value_ at the specified memory _address_. If _valueType_ is omitted, it is supposed to be _ubyte_ (8 bit unsigned integer).\n\nThe _value_ is [converted](cast.md) to the given _[valueType](zx_basic:types.md)_ and stored at the given _Address_. _Type_ can be any numeric one (like _[float](zx_basic:types#float.md)_ or _[integer](zx_basic:types#integer.md)_).\n\n## Examples\n\nIt is possible to _poke a decimal value_ (5 bytes) at a memory position:\n\n```\npoke float 16384, pi\n```\n\nTraditionally, in Sinclair BASIC, to store a 16 bit value the programmer does something like this:\n\n```\n10 LET i = 16384\n20 LET value = 65500\n30 POKE i, value - 256 * INT(value / 256) : REM value MOD 256\n40 POKE i + 1, INT(value / 256)\n```\n\nThis can be done in a single sentence in ZX BASIC:\n\n\n```\npoke uinteger 16384, 65500\n```\n\nIt's faster and the recommended way.\n\n## Remarks\n\n* This statement is Sinclair BASIC compatible.\n* This statement extends the Sinclair BASIC one.\n* This statement also allows parenthesis and [FreeBASIC syntax](http://www.freebasic.net/wiki/wikka.php?wakka=KeyPgPoke)\n\n## See also\n* [PEEK](peek.md)\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PRINT": {
    "content": "# PRINT\r\n\r\n## Syntax\r\n\r\n```\r\nPRINT [string][expression][value], | PRINT AT y,x; [string][expression][value]\r\n```\r\n\r\n## Description\r\n\r\nUses the ROM to PRINT text on to ULA. Can be used in conjunction with AT to set position\r\n\r\n**Examples**\r\n\r\nPRINT \"HELLO NEXTBUILD\"\r\n\r\n\tPRINT AT 10,4;\"HELLO ZX BASIC\"\r\n\r\nYou can also set attribute modifiers\r\n\r\n\tPRINT INK 2;\"THIS TEXT IS RED\"\r\n\r\n**Remarks**\r\n\r\n- This statement is Sinclair BASIC compatible.\r\n- This function extends the Sinclair BASIC version.\r\n- This statement also allows parenthesis and FreeBASIC syntax\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "RANDOMIZE": {
    "content": "# RANDOMIZE\r\n\r\n## Syntax\r\n\r\n```\r\nRANDOMIZE [value]\r\n```\r\n\r\n## Description\r\n\r\nSets RANDOM seed value to *value*\r\n\r\n**Example**\r\n\r\n\tRANDOMIZE 385\r\n\r\n**Remarks**\r\n\r\n- This statement is Sinclair BASIC compatible.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "READ": {
    "content": "# READ\r\n\r\n## Syntax\r\n\r\n```\r\nREAD *var or array_elem*[, *var or array_elem*, *var or array_elem*...]\r\n```\r\n\r\n## Description\r\n\r\n**READ** gets the next data expression available from a DATA line definition and stores it into a variable (not arrays) or an array element. Instead of using INPUT() function or LET assignments, you can write a sequence (or several of them) of **READ** which might result in a compact and more readable code to initialize data variables.\r\n\r\nREAD gets the items one after another. This order can be changed using RESTORE.\r\n\r\n  \r\n\r\n**Example**\r\n\r\n\tDIM a(9) as UByte\r\n\r\n\tFOR i = 0 TO 9: REM 0 TO 9 => 10 elements\r\n\t\tREAD a(i)\r\n\t\tPRINT a(i)\r\n\tNEXT i\r\n\r\n\t'notice the a(n) data entries\r\n\tDATA 2, 4, 6 * i, 7, 0\r\n\tDATA a(0), a(1), a(2), a(3), a(4)\r\n\r\nThis will output:\r\n\r\n\t2\r\n\t4\r\n\t12\r\n\t7\r\n\t0\r\n\t2\r\n\t4\r\n\t12\r\n\t7\r\n\t7\r\n\t0\r\n\r\nExpressions are read and evaluated one by one, **when the READ sentence is executed**. When a **DATA** line is finished, the next one in the listing will be read. Traditionally if there's no more data to read, an *OUT of Data* error happened. In ZX Basic, the read sequence restarts from the beginning. The reading sequence can be altered with RESTORE  \r\n\r\n**Remarks**\r\n\r\n- This statement is Sinclair BASIC compatible.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/read/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "REM": {
    "content": "# REM\r\n\r\n## Syntax\r\n\r\n```\r\nREM *var or array_elem*[, *var or array_elem*, *var or array_elem*...]\r\n```\r\n\r\n## Description\r\n\r\nTraditional BASIC dialects (e.g. Sinclair BASIC) uses REM to comment lines. REM is an abbreviation of REMark. ZX BASIC allows it. Newer dialects uses the apostrophe character (') as a shortened REM. ZX BASIC also allows it, so the above listing could be also rewritten this way:\r\n\r\n**Example**\r\n\r\n\t' This line has a comment\r\n\r\n\t20 PRINT \"Hello World\": 'The following sentence is ignored: PRINT \"Hello Again\"\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/comments/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "RESTORE": {
    "content": "# RESTORE\r\n\r\n## Syntax\r\n\r\n```\r\nRESTORE [*label*]\r\n```\r\n\r\n## Description\r\n\r\n**RESTORE** statement is used to change the order in which DATA lines are read. The **RESTORE** *label* statement will make the next READ to get the data from the label line onwards. If no label is specified, the data reading sequence is restarted from the beginning.\r\n\r\n**Example**\r\n\r\n\tRESTORE numbers\r\n\r\n\tFOR i = 0 TO 3\r\n\t\tREAD a\r\n\t\tPRINT a\r\n\tNEXT i\r\n\r\n\t'These will be skipped by the RESTORE above\r\n\tstrings:\r\n\tDATA \"Hello world!\", \"ZX Spectrum\", \"ZX Rules!\"\r\n\r\n\t'This will be read since RESTORE pointed to numbers: label\r\n\tnumbers:\r\n\tDATA 10, 20, 30\r\n\r\nThis will output:\r\n\r\n\t10\r\n\t20\r\n\t30\r\n\r\nNotice the strings section has been skipped over. \r\n\r\n**Remarks**\r\n\r\n- This statement is Sinclair BASIC compatible.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/restore/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "RETURN": {
    "content": "# RETURN\r\n\r\n## Syntax\r\n\r\n```\r\nRETURN [*value*]\r\n```\r\n\r\n## Description\r\n\r\nRETURNs from GOSUB or exits a FUNCTION with a RETURN value\r\n\r\n**Example**\r\n\r\n\tRETURN\r\n\r\n\tRETURN a\r\n\r\n**Remarks**\r\n\r\n- This statement is Sinclair BASIC compatible.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/return/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "RND": {
    "content": "# RND\r\n\r\n## Syntax\r\n\r\n```\r\nRND() | RND\r\n```\r\n\r\n## Description\r\n\r\nReturns a number of type float in the range [0, 1) (i.e. 0 <= RND < 1), based on a random seed (see RANDOMIZE).\r\n\r\n**Examples**\r\n\r\n\t'Function to a random number in the range [first, last), or {first <= x < last}.\r\n\tFunction rnd_range (first As Double, last As Double) As Float\r\n\t\tFunction = Rnd * (last - first) + first\r\n\tEnd Function\r\n\r\n\t'seed the random number generator, so the sequence is not the same each time\r\n\tRANDOMIZE\r\n\r\n\t'prints a random number in the range [0, 1], or {0 <= x < 1}.\r\n\tPRINT RND\r\n\r\n\t'prints a random number in the range [0, 10], or  {0 <= x < 10}.\r\n\tPRINT RND * 10\r\n\r\n\t'prints a random integer number in the range [1, 11), or  {1 <= x < 11}.\r\n\t'with integers, this is equivalent to [1, 10], or {1 <= n <= 10}.\r\n\tPRINT INT(RND * 10) +1\r\n\r\n\t'prints a random integer number in the range [69, 421], or {69 <= x < 421}.\r\n\t'this is equivalent to [69, 420], or {69 <= n <= 420}.\r\n\tPRINT INT(RND_RANGE(69,421)) \r\n\r\n**Remarks**\r\n\r\n- ZX BASIC RND is much faster than Sinclair BASIC RND, and produces different random sequences.\r\n- Its randomness is also much better (try plotting points at random x,y coords, and they look really random whilst in Sinclair BASIC diagonal lines begin to appear: this means there's a correlation between x, y points hence not very random).\r\n- Also, Sinclair BASIC RND has a periodicity of 2^16 (65536), whilst ZX BASIC RND has a periodicity of 2^32 (4,294,967,296).\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/rnd/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SAVE": {
    "content": "# SAVE\r\n\r\n## Syntax\r\n\r\n```\r\nSAVE \"xxx\" CODE START, LENGTH\r\n```\r\n\r\n## Description\r\n\r\nThe below commands work in a manner identical to Sinclair Basic.\r\n\r\n**Example**\r\n\r\n\tSAVE \"xxx\" CODE 32768, 6912\r\n\r\nSaves to TAP a block of memory 6912 in length from address 32768.\r\n\r\n\r\n\r\n**Remarks**\r\n\r\n- This statement is Sinclair BASIC compatible.\r\n- This DOES NOT WORK with the Next's SD, use SaveSD() instead.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/return/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SGN": {
    "content": "# SGN\r\n\r\n## Syntax\r\n\r\n```\r\nSGN *expression*\r\n```\r\n\r\n## Description\r\n\r\nSGN expression.\r\n\r\n**Example**\r\n\r\n\tSGN a\r\n\r\n**Remarks**\r\n\r\n- This statement is Sinclair BASIC compatible.\r\n- This DOES NOT WORK with the Next's SD, use SaveSD() instead.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SHL": {
    "content": "# SHL\r\n\r\n## Syntax\r\n\r\n```\r\n*expression* SHL *distance* | *expression* SHR *distance*\r\n```\r\n\r\n## Description\r\n\r\nBit shifts <expr> expression by <distance> bits to the left (SHL) or to the right (SHR). SHR can be replaced by >> and SHL by << for more legibility.\r\n\r\nThe argument should be of an integer type: uByte, Byte, uInteger, Integer, uLong or Long. Use of bit-shifting with fixed and float gives undefined results. CAST or INT should be used to convert floating point numbers into integer type numbers before use of the bit shift instructions.\r\n\r\nOwing to the nature of moving bits right and left, SHL n is the equivalent of a multiply by 2n, and SHR would be the equivalent of an integer division by 2n (destroying any fractional part).\r\n\r\n**Example**\r\n\r\n\tPRINT 2 << 1: REM prints 4\r\n\tPRINT 16 SHR 2: REM again 4\r\n\r\n**Remarks**\r\n\r\n- This function is not available in Sinclair BASIC.\r\n- The syntax is similar to C's << and >> operators.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/shl/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SHR": {
    "content": "# SHR\r\n\r\n## Syntax\r\n\r\n```\r\n*expression* SHL *distance* | *expression* SHR *distance*\r\n```\r\n\r\n## Description\r\n\r\nBit shifts <expr> expression by <distance> bits to the left (SHL) or to the right (SHR). SHR can be replaced by >> and SHL by << for more legibility.\r\n\r\nThe argument should be of an integer type: uByte, Byte, uInteger, Integer, uLong or Long. Use of bitshifting with fixed and float gives undefined results. CAST or INT should be used to convert floating point numbers into integer type numbers before use of the bit shift instructions.\r\n\r\nOwing to the nature of moving bits right and left, SHL n is the equivalent of a multiply by 2n, and SHR would be the equivalent of an integer division by 2n (destroying any fractional part).\r\n\r\n**Example**\r\n\r\n\tPRINT 2 << 1: REM prints 4\r\n\tPRINT 16 SHR 2: REM again 4\r\n\r\n**Remarks**\r\n\r\n- This function is not available in Sinclair BASIC.\r\n- The syntax is similar to C's << and >> operators.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/shl/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SIN": {
    "content": "# SIN\r\n\r\n## Syntax\r\n\r\n```\r\nSIN(*numericExpression*)\r\n```\r\n\r\n## Description\r\n\r\nReturns the sine value of the given argument. Argument must be a numeric expression in radians units. Returned value type is float.\r\n\r\n**Example**\r\n\r\n\tREM Sine value\r\n\tPRINT \"Sine value of a is \"; SIN(a)\r\n\r\n**Remarks**\r\n\r\n- This function is 100% Sinclair BASIC Compatible.\r\n- If the given argument type is not float, it will be converted to float before operating with it.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/sin/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SQR": {
    "content": "# SQR\r\n\r\n## Syntax\r\n\r\n```\r\nSQR(*numericExpression*)\r\n```\r\n\r\n## Description\r\n\r\nReturns the square root value of the given argument. Argument must be a numeric expression, and is returned as type float.\r\n\r\n**Example**\r\n\r\n\tREM Square Root value\r\n\tPRINT \"Root of a is \"; SQR(a)\r\n\r\n**Remarks**\r\n\r\n- This function is 100% Sinclair BASIC Compatible.\r\n- If the given argument type is not float, it will be converted to float before operating with it.\r\n- This function uses the ZX Spectrum ROM code to calculate. Note that the ZX Spectrum ROM is extremely inefficient at doing this calculation. If speed is an issue, and you can spare a few bytes, there are two functions in this wiki library to speed up square root calculations. The first is exactly as accurate as the ROM routine, but is about 6 times faster. The second returns an integer result, and is 50-100 times faster.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/sqr/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "STEP": {
    "content": "# STEP\r\n\r\n## Syntax\r\n\r\n```\r\nFOR ... NEXT STEP stepvalue\r\n```\r\n\r\n## Description\r\n\r\nSee FOR - NEXT \r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/for/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "STOP": {
    "content": "# STOP\r\n\r\n## Syntax\r\n\r\n```\r\nSTOP\r\n```\r\n\r\n## Description\r\n\r\nSTOPs the program and exits \r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "STR": {
    "content": "# STR\r\n\r\n## Syntax\r\n\r\n```\r\nSTR (value)\r\n```\r\n\r\n## Description\r\n\r\nConvert numerical value into a *string*\r\n\r\n**Example**\r\n\r\n\ta = 5\r\n\tb$ = STR(a)\r\n\tPRINT b$ : REM will print 5\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SUB": {
    "content": "# SUB\r\n\r\n## Syntax\r\n\r\n```\r\nSUB *subroutine name*[(*paramlist*)].. END SUB\r\n```\r\n\r\n## Description\r\n\r\nZX Basic allows function and subroutines declarations. Sinclair Basic does not allow named subroutines, only calls with the GOSUB command.\r\n\r\nA subroutine defined with the SUB statement is invoked directly. Unlike a FUNCTION, a SUB does not return a value. This is the fundamental difference between code defined with SUB and code defined with FUNCTION. Other than that, the setup for SUB and FUNCTION are almost identical.\r\n\r\n**Syntax**\r\n\r\n\tSUB <subroutine name>[(<paramlist>)]\r\n\t\tstatements\r\n\t\t...\r\n\tEND SUB\r\n\r\n**Example**\r\n\r\n\tSUB printat (y as uByte, x as uByte, data$ as STRING)\r\n\t\tPRINT AT y,x,data$\r\n\tEND SUB\r\n\r\nWhile this is a rather silly example, it shows how parameters can be passed into a SUB, just like a FUNCTION. No parameters are passed back.\r\n\r\nA SUB can be exited with the return statement.\r\n\r\nA SUB is an excellent way of wrapping machine code or data such that it does not interfere with program execution. Such data can be placed within a SUB but after a RETURN statement:\r\n\r\n\tSUB setupUDG ()\r\n\t\tDIM i,j as uInteger\r\n\t\tLET j=@udgdata\r\n\t\tFOR i=USR \"A\" to USR \"A\"+7\r\n\t\t\tPOKE i,PEEK j\r\n\t\tNEXT i\r\n\t\tRETURN\r\n\r\n\r\n\tudgdata:\r\n\t\tASM\r\n\t\t\tDEFB 1,2,3,4,5,6,7,8\r\n\t\tEND ASM\r\n\tEND SUB\r\n\r\nAgain, this is a rather silly example - far better to point the UDG system variable at the data than copy it, but it does show how an ASM context can be hidden from the main program, and accessed with an @ label.\r\n\r\nFinally, a SUB is an excellent way of running a pure machine code routine. FUNCTION can be used in a similar manner, if you wish to pass data back into the compiled basic, of course.\r\n\r\n\tSUB routine ()\r\n\t\tASM\r\n\t\t\t(your as code goes here)\r\n\t\tEND SUB\r\n\tEND SUB\r\n\r\n**Memory Optimization**\r\n\r\nIf you invoke zxbasic using -O1 (or higher) optimization flag the compiler will detect and ignore unused SUB's (thus saving memory space). It will also issue a warning (perhaps you forgot to call it?), that can be ignored.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/sub/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TAN": {
    "content": "# TAN\r\n\r\n## Syntax\r\n\r\n```\r\nTAN(*numericExpression*)\r\n```\r\n\r\n## Description\r\n\r\nReturns the tangent value of the given argument. Argument must be a numeric expression in radians units. Returned value type is float.\r\n\r\n**Examples**\r\n\r\n\tREM Tangent value\r\n\tPRINT \"Tangent value of a is \"; TAN(a)\r\n\r\n**Remarks**\r\n\r\n- This function is 100% Sinclair BASIC Compatible.\r\n- If the given argument type is not float, it will be converted to float before operating with it.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/tan/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TO": {
    "content": "# TO\r\n\r\n## Syntax\r\n\r\n```\r\na TO b\r\n```\r\n\r\n## Description\r\n\r\nTO can be used with FOR as follows:\r\n\r\n**Examples**\r\n\r\n\tFOR n = 0 TO 10\r\n\tPRINT n\r\n\tNEXT n\r\n\r\nIt can also be use to select a portion of a string\r\n\r\n\ta$ = \"NextBuild\"\r\n\t\tPRINT a$(0 TO 3) : REM will print \"Next\"\r\n\r\n\tPRINT a$(4 TO ) : REM will print \"Build\"\r\n\r\n**Remarks**\r\n\r\n- This function is almost 100% Sinclair BASIC Compatible.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TOOLS": {
    "content": "# Tools\n\n## The ZX BASIC SDK\n\nAs you might already know, ZX BASIC is not a single program. It consist in 3 python (.py) programs that might be used standalone or not, depending on how they are invoked.\n\n### ZXB\n[ZXb](zxb.md) is the main compiler executable (for Windows you can use the .exe _converted_ version).\nIt will compile a BASIC program into a binary file. At this moment, supported binary formats are:\n[TZX](https://web.archive.org/web/20171125213628/http://www.worldofspectrum.org/TZXformat.html),\n[TAP](http://www.tjornov.dk/spectrum/faq/fileform.html#TAPZ)  and raw binary (.BIN) format.\n\nGo to the [zxb page](zxb.md) for help on using the compiler.\n\n### ZXBasm\n[ZXbasm](zxbasm.md) is a cross-platform Z80 assembler. It will assemble plain ASCII files containing asm source code into the same formats described above. This tool is completely finished.\n\nGo to the [zxbasm page](zxbasm.md) for help on using the assembler.\n\n### ZXBpp\nThe [zxbpp](zxbpp.md) utility is a preprocessor which works in the same way as many C preprocessors (cpp) programs do. It is used both by [zxb](zxb.md) and [zxbasm](zxbasm.md). It basically filter an input file and produces a modified output one, by replacing macros and include files. If your used to C preprocessors (e.g. you've used Z88Dk), you will probably be very familiar with it.\n\nGo to the [zxbpp page](zxbpp.md) for help on using the preprocessor.\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "TYPES": {
    "content": "# Types\n\n## Introductions\n\nAlthough ZX BASIC was originally designed with ZX Spectrum in mind, it is a three-stage _retargeable_ compiler. This means it should not be difficult to hack ZX BASIC SDK to compile for other target machines (E.g. Commodore 64) or current machines (PC) or even virtual machines like Java or .NET. Porting ZX BASIC to other Z80 architectures like Amstrad or MSX should be almost straightforward (only the library.asm should need some work to use different ROM routines).\n\nOnce said that, _data types_ were designed for the Z80 platform. So, for example 64 bits integers are not implemented.\n\n## Types\n\nA data _type_ describes how the information of a variable is stored in memory.\nFor example, a variable can hold a floating point number or a string in the legacy\nSinclair BASIC. But sometimes this is a waste of time and memory.\nFor example, why don't we use a single byte to store a value we know it's always\nan integer between 0 and 10?\n\nNow you can: ZX BASIC allows more data types\nto save memory and achieve higher speed.\n\nThere are 3 kinds of types: **integrals** (integer numbers), **decimals** and **strings**\n\n### Integral\nIntegrals are numerical types to store integer values.\nThey can be _unsigned_ (their value is always 0 or positive) or _signed_ (can take negative values).\nZX Basic integer types sizes are 8, 16 and 32 bits. Unsigned types have the prefix _U_.\n\n\n| Type name | Size (bytes) | Signed? | Range | Description |\n|:-----------|:-----:|:--------:|:------:|:-------------|\n| Byte | 1 | yes | -128..127  | 8 bits signed integer  |\n| UByte| 1 | no | 0..255  | 8 bits unsigned integer  |\n| Integer | 2 | yes | -32768..32767 | 16 bits signed integer |\n| UInteger | 2 | no | 0..65535 | 16 bits unsigned integer |\n| Long | 4 | yes |  <small>−2,147,483,648 .. +2,147,483,647</small> | 32 bit signed integer |\n| ULong | 4 | yes | <small>0 .. 4,294,967,295</small>| 32 bit unsigned integer |\n\n\n### Decimals\n**Decimals**, as suggested, stores decimal numeric types.\nTheir sizes are 32 bit for `Fixed` type and 40 bits for `Float` one.\n\n#### Fixed\n32 bit Fixed Point decimal. First 16 bits are the integer part, whilst remaining 16 contains the decimal one.\nRanges from -32767.9999847 to 32767.9999847 with a precision of 1 / 2^16 (0.000015 approx.).\nFixed points decimal are less precise than Floating ones, but much faster and requires\nless space (1 byte less). Also, their range is much limited.\nThey're usually used on screen drawing when Floating point is too slow and decimal\ncalculations are required.\n\n#### Float\nFloating point type is **identical** to the Sinclair BASIC one.\nIt requires 5 bytes (1 byte for exponent, 4 bytes for mantissa).\nRead the ZX Spectrum manual or [here](http://www.worldofspectrum.org/ZXBasicManual/zxmanchap24.html).\n\n>To store the number in the computer, we use five bytes, as follows:\n>\n> Write the first eight bits of the mantissa in the second byte (we know that the first bit is 1), the second eight bits in the third byte, the third eight bits in the fourth byte and the fourth eight bits in the fifth byte;\n> replace the first bit in the second byte which we know is 1 by the sign: 0 for plus, 1 for minus;\n> write the exponent +128 in the first byte. For instance, suppose our number is 1 / 10, then<br/>\n> 1 / 10 = (4 / 5) * 2<sup>(-3)</sup>\n\n### Strings\n\nString types are used to store alphanumerical strings.\nStrings can contain up to 65535 characters, and they can change its size dynamically so, unlike other data types, their content is stored in a different memory area, called [the heap](memory_heap.md).\n\nIn most BASIC dialects, string variables used to have the **$** suffix (also called _sigil_), but suffixes are optional in ZX BASIC (you can omit them).\n\n## Classes\n\nAt this moment, ZX BASIC is not an <abbr title=\"Object Oriented Programming\">OOP</abbr> compiler. But there are three main _classes_. A class can be considered as a _kind of type_.\n\n### Var\n\nVars are _scalar_ variables. Scalar variables are those which store a single value.\nAlmost all variables are scalars:\n\n```\nREM A simple scalar variable\nDIM a = 3\n```\n\n### Arrays\n\nUnlike scalars, array variables can hold more than a single value at once.\nYou access a single value within the array container using an integer _index_:\n\n```\nREM An array variable\nDIM a(1 TO 10) AS UBYTE\nLET a(3) = 5: REM pick a(3) cell and store the number 5 in it\n```\n\n### Labels\n\nUnlike the above, [labels](labels.md) are not variables.\nThey refer to memory positions. Line numbers are also treated as labels and they are completely optional:\n\n\n```\n10 REM here '10' is a Label\n 5 REM here '5' is another label, so the number order does not matter\n   REM Line numbers are optional. So this line is ok either.\n   ' This line is also a comment. The character (') is like REM\n\nmylabel:\n   REM the above 'mylabel' identifier is also a Label. When not a line number,\n   REM they must be ended with a colon (:)\n\n   GOTO mylabel: REM Goes to 'mylabel' line\n\n   GO TO 5: REM Another way to write GOTO. Jumps to line 5\n```\n\n## See Also\n* [DIM](dim.md) (statement)\n* [Labels](labels.md)\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "UBOUND": {
    "content": "# UBOUND\r\n\r\n## Syntax\r\n\r\n```\r\nUBOUND (*array variable*), UBound(*array variable*, *dimension*)\r\n```\r\n\r\n## Description\r\n\r\nReturns the array upper bound of the given . If the is not specified, it defaults to 1. If the specified is 0, then total number of dimensions is returned.\r\n\r\n**Examples**\r\n\r\n\tDIM a(3 TO 5, 2 TO 8)\r\n\tPRINT UBound(a, 2) : ' Prints 8\r\n\tPRINT Ubound(a) : ' Prints 35, because dimension defaults to 1\r\n\r\nThe result is always a 16bit integer value.\r\n\r\nIf the is 0, then the number of dimension in the array is returned (useful to guess the number of dimensions of an array):\r\n\r\n\tDIM a(3 TO 5, 2 TO 8)\r\n\tPRINT UBound(a, 0): ' Prints 2, since 'a' has 2 dimensions\r\n\r\n**Remarks**\r\n\r\n- This function does not exists in Sinclair BASIC.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/lbound/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "UBYTE": {
    "content": "# UBYTE\r\n\r\n## Syntax\r\n\r\n```\r\nUBYTE\r\n```\r\n\r\n## Description\r\n\r\nUBYTE is an Integral Type.\r\n\r\nUBYTE are 1 byte in size not signed. 0-255 - 8 bits unsigned\r\n\r\nMore info https://zxbasic.readthedocs.io/en/docs/types/#types_1\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "UINTEGER": {
    "content": "# UINTEGER\r\n\r\n## Syntax\r\n\r\n```\r\nUINTEGER\r\n```\r\n\r\n## Description\r\n\r\nUINTEGER is an Integral Type.\r\n\r\nUINTEGER are 2 bytes in size not signed. 0-65535 - 16 bits unsigned\r\n\r\n\t00000000 \t00000000\r\n\tLSB\t\t\tMSB\r\n\r\nMore info https://zxbasic.readthedocs.io/en/docs/types/#types_1\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ULONG": {
    "content": "# ULONG\r\n\r\n## Syntax\r\n\r\n```\r\nULONG\r\n```\r\n\r\n## Description\r\n\r\nULONG is an Integral Type.\r\n\r\nULONG are 4 bytes in size and not signed. 0-4,294,967,295 - 32 bits unsigned\r\n\r\nMore info https://zxbasic.readthedocs.io/en/docs/types/#types_1\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "UNTIL": {
    "content": "# UNTIL\r\n\r\n## Syntax\r\n\r\n```\r\n... UNTIL <condition>\r\n```\r\n\r\n## Description\r\n\r\nPart of DO ... UNTIL. Please check DO for more information\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/do/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "USR": {
    "content": "# USR\n\n## Syntax\n\n\n```\nUSR(<address>)\nUSR(<string value>)\n```\n\n## Description\n\nThis function exist for the sole compatibility with Sinclair BASIC. It's not needed in ZX Basic.\n\nIf used with a numeric argument, it will jump to the given memory address and start executing the machine code from there.\nTo return the control to BASIC, a `ret` instruction must be executed. The value of the BC register will be used as the\nvalue (uInteger) returned by the function.\n\nIf used with a string argument, it will return the UDG (User Defined Graphic) memory address of the first character of the string.\nFor example, for the `\\A` UDG, `USR \"a\"` will return the address of it. This function is case insensitive.\n\nReturned value type is [UInteger](types.md#Integral).\n\n## Examples\n\nTo call a machine code routine:\n```\nREM Uses USR to invoke a machine code routine\nPRINT \"BC register returned \"; USR @myRoutine\nEND\n\nmyRoutine:\nAsm\nld bc, 1234\nret\nEnd Asm\n```\n\nTo work with UDG:\n```\nREM Creates an UDG with Horizontal lines\nFOR i = 0 TO 7:\n    POKE USR \"a\" + i, 255 * (i MOD 2)\nNEXT i\nPRINT \"\\A is the UDG A\"\n```\n\n## Remarks\n\n* This function is 100% Sinclair BASIC Compatible\n\n## See Also\n\n* [CODE](code.md)\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "VAL": {
    "content": "# VAL\r\n\r\n## Syntax\r\n\r\n```\r\nVAL string\r\n```\r\n\r\n## Description\r\n\r\nConverts a string into a numerical value.\r\n\r\n**Example**\r\n\r\n\ta$ = \"5\"\r\n\tb = 5\r\n\tPRINT VAL (a$)+5 : REM Will print 10\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "WEND": {
    "content": "# WEND\r\n\r\n## Syntax\r\n\r\n```\r\nWHILE ... WEND\r\n```\r\n\r\n## Description\r\n\r\nWHILE is a compound statement used to perform loops. The code within a WHILE statement will repeat while the given condition is true. If the given condition is false the first time the inner sentences are never executed.\r\n\r\n**Syntax**\r\n\r\n\tWHILE expression\r\n\t\tsentences\r\n\tEND WHILE\r\n\r\nOr\r\n\r\n\tWHILE expression\r\n\t\tsentences\r\n\tWEND\r\n\r\n**Example**\r\n\r\n\tWhile a < b\r\n\t\ta = a + 1\r\n\t\tPOKE a, 0\r\n\tEND WHILE\r\n\r\nAn infinite loop:\r\n\r\n\tWHILE 1\r\n\t\tREM An infinite loop. This will issue a warning\r\n\t\tPRINT \"HELLO WORLD\"\r\n\tEND WHILE\r\n\r\n**Note:** For infinite loops use DO...LOOP\r\n\r\n**Remarks**\r\n\r\n- This statement does not exist in Sinclair Basic.\r\n- **WHILE** can also be used with DO ... LOOP.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/while/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "WHILE": {
    "content": "# WHILE\r\n\r\n## Syntax\r\n\r\n```\r\nWHILE ... END WHILE\r\n```\r\n\r\n## Description\r\n\r\nWHILE is a compound statement used to perform loops. The code within a WHILE statement will repeat while the given condition is true. If the given condition is false the first time the inner sentences are never executed.\r\n\r\n**Syntax**\r\n\r\n\tWHILE expression\r\n\t\tsentences\r\n\tEND WHILE\r\n\r\nOr\r\n\r\n\tWHILE expression\r\n\t\tsentences\r\n\tWEND\r\n\r\n**Example**\r\n\r\n\tWhile a < b\r\n\t\ta = a + 1\r\n\t\tPOKE a, 0\r\n\tEND WHILE\r\n\r\nAn infinite loop:\r\n\r\n\tWHILE 1\r\n\t\tREM An infinite loop. This will issue a warning\r\n\t\tPRINT \"HELLO WORLD\"\r\n\tEND WHILE\r\n\r\n**Note:** For infinite loops use DO...LOOP\r\n\r\n**Remarks**\r\n\r\n- This statement does not exist in Sinclair Basic.\r\n- **WHILE** can also be used with DO ... LOOP.\r\n\r\nMore info : https://zxbasic.readthedocs.io/en/docs/while/\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "XOR": {
    "content": "# XOR\r\n\r\n## Syntax\r\n\r\n```\r\na XOR b\r\n```\r\n\r\n## Description\r\n\r\nXOR is a Logical Operator. Performs a logical XOR and returns TRUE if one of the arguments is true and one of the arguments is false. In essence, returns true if ONLY one of the arguments is true. \r\n\r\n**Example**\r\n\r\n\ta = b XOR c\r\n\r\n\t| A | B | Result |\r\n\t| F | F | \tF\t |\r\n\t| F | T | \tT\t |\r\n\t| T | F | \tT\t |\r\n\t| T | T | \tF\t |\r\nMore info : https://zxbasic.readthedocs.io/en/docs/operators/#XOR\r\n",
    "category": "keywords",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ZXB": {
    "content": "# Zxb\n\n**Note:** This section does not explain the [ZX BASIC language](syntax.md), but the usage of its compiler: ZXB.\n\n## Introduction\n\nZXB is the main SDK executable. It can act both as a compiler or as a translator:\n\n* When used as a _compiler_ (this is the default behavior) it will convert a `.BAS` text file to a binary `.BIN` or\n`.TZX` file you can later run on your Spectrum or in a ZX Spectrum emulator.\n* If invoked as a _translator_ it will convert a `.BAS` file to assembler (`.ASM` source file).\nYou can alter edit this assembler text file (for example to perform some low-level modifications or just to see\nhow the compiler does it work!).\n\n### Using ZXB\n\nZXB is invoked from the command line as **zxb.py** if you used the _Multiplatform_ (.zip) distribution or **zxb** if you installed the .MSI package.\n\nUsing ZXB is quite straightforward. You will need to type in a BASIC source in a text file. If you don't have any, create a file named _helloworld.bas_ using your favorite text editor, and type in the following:\n\n\n```\n10 PRINT \"HELLO WORLD\"\n```\n\n\nSave this text file as `helloworld.bas`. Now let's compile it:\n\n```\nzxb.py helloworld.bas\n```\n\n> **NOTE**: In Windows you should omit the trailing `.py` extension. So type `zxb helloworld.bas` instead.\n\nIf everything went ok, no message should appear on the screen.\nNow, if you examine your directory, you will see a `helloworld.bin` binary file.\nThis file contains the bytes of your program.\n\nAnother supported output formats are `.TAP` and `.TZX`. These formats are supported by many emulators, and can also be converted into sound (WAV, MP3, VOC) to be later loaded on a real ZX Spectrum. TZX and TAP files can also contain a BASIC loader which will load the binary code and execute it. Let's use all of this together:\n\n```\nzxb.py helloworld.bas --tzx --BASIC --autorun\n```\nThis will create a .tzx file. Open it with your preferred emulator, and type _LOAD \"\"_. You will see a BASIC loader program executing and loading your code. The machine code is finally executed using _RANDOMIZE USR 32768_.\n\n> **NOTE**: 32768 (8000h) is the default ORG for your program.\n\n\nYou can change the default origin using the -S command line parameter.\n\n### Command Line Options\n\nZXB provides several (and useful) command line options. To see them, just type **_zxb.py -h_**, which outputs:\n\n```\n usage: zxb [-h] [-d] [-O OPTIMIZE] [-o OUTPUT_FILE] [-T] [-t] [-B] [-a] [-A]\n           [-S ORG] [-e STDERR] [--array-base ARRAY_BASE]\n           [--string-base STRING_BASE] [-Z] [-H HEAP_SIZE] [--debug-memory]\n           [--debug-array] [--strict-bool] [--enable-break] [-E] [--explicit]\n           [-D DEFINES] [-M MEMORY_MAP] [-i] [-I INCLUDE_PATH] [--strict]\n           [--version]\n           PROGRAM\n\n positional arguments:\n  PROGRAM               BASIC program file\n\n optional arguments:\n  -h, --help            show this help message and exit\n  -d, --debug           Enable verbosity/debugging output. Additional -d\n                        increase verbosity/debug level\n  -O OPTIMIZE, --optimize OPTIMIZE\n                        Sets optimization level. 0 = None (default level is 2)\n  -o OUTPUT_FILE, --output OUTPUT_FILE\n                        Sets output file. Default is input filename with .bin\n                        extension\n  -T, --tzx             Sets output format to tzx (default is .bin)\n  -t, --tap             Sets output format to tap (default is .bin)\n  -B, --BASIC           Creates a BASIC loader which loads the rest of the\n                        CODE. Requires -T or -t\n  -a, --autorun         Sets the program to be run once loaded\n  -A, --asm             Sets output format to asm\n  -S ORG, --org ORG     Start of machine code. By default 32768\n  -e STDERR, --errmsg STDERR\n                        Error messages file (standard error console by\n                        default)\n  --array-base ARRAY_BASE\n                        Default lower index for arrays (0 by default)\n  --string-base STRING_BASE\n                        Default lower index for strings (0 by default)\n  -Z, --sinclair        Enable by default some more original ZX Spectrum\n                        Sinclair BASIC features: ATTR, SCREEN$, POINT\n  -H HEAP_SIZE, --heap-size HEAP_SIZE\n                        Sets heap size in bytes (default 4768 bytes)\n  --heap-size HEAP_ADDRESS\n                        Sets the start address of the heap\n  --debug-memory        Enables out-of-memory debug\n  --debug-array         Enables array boundary checking\n  --strict-bool         Enforce boolean values to be 0 or 1\n  --enable-break        Enables program execution BREAK detection\n  -E, --emit-backend    Emits backend code instead of ASM or binary\n  --explicit            Requires all variables and functions to be declared\n                        before used\n  -D DEFINES, --define DEFINES\n                        Defines de given macro. Eg. -D MYDEBUG or -D\n                        NAME=Value\n  -M MEMORY_MAP, --mmap MEMORY_MAP\n                        Generate label memory map\n  -i, --ignore-case     Ignore case. Makes variable names are case insensitive\n  -I INCLUDE_PATH, --include-path INCLUDE_PATH\n                        Add colon separated list of directories to add to\n                        include path. e.g. -I dir1:dir2\n  --strict              Enables strict mode. Force explicit type declaration\n  --version             show program's version number and exit\n```\n\nSome options (-h, --version) are quite obvious. Let's focus on the rest:\n\n* **-d** or **-debug**\n<br />This will show lots of (useless) debug information for the compiler developer (e.g. to me). Usually,\nyou won't need this at all.\n\n* **-O** or **--optimize**\n<br />The default optimization level is 1. Setting this to a value greater than 1 will enable the compiler code\noptimizations (e.g. Peephole optimizer).\nSetting this to 0 will produce slower code, but could be useful for debugging purposes (both for the compiler or the\nBASIC program). A value of 3 will enable **aggressive** optimizations not fully tested yet! So, beware!\n\n* **-o** or **--output**\n<br />Sets the output file name. By default it will be the same as the input file, but with the extension changed as\nappropriated (.BIN, .TAP, .ASM, .TZX).\n\n* **-T** or **--tzx**\n<br />Outputs the binary result in [TZX Format](https://web.archive.org/web/20171125213628/http://www.worldofspectrum.org/TZXformat.html).\nThis format can be converted to sound (.WAV or .MP3).\n\n* **-t** or **--tap**\n<br />Outputs the binary result in [TAP Format](http://www.nvg.ntnu.no/sinclair/faq/fileform.html#TAPZ).\n\n* **-B** or **--BASIC**\n<br />This is a very useful option. It will prepend a ZX spectrum BASIC loader that will load the rest of your binary\ncompiled program. This option requires the **--tap** or **--tzx** to be specified. This way you can type `LOAD \"\"`\nto load your program.\n\n* **-a** or **--autorun**\n<br />Makes your program to run automatically. If specified with the `-B` or `--basic` option, your program will\nautorun if loaded with `LOAD \"\"`. If `--basic` is no used this option is ignored.\n\n* **-A** or **--asm**\n<br />This will create the .asm (assembler) file. Useful to see / edit the assembler code. You could later assemble it\nusing [ZXbasm](zxbasm.md) included assembler.\n\n* **-S** or **--org**\n<br />This will change the default machine code ORiGin. By default your code will start at memory position\n32768 (8000h). But you can change this with this parameter.\n\n* **-e** or **--stderr**\n<br />This specifies an output file name for error msgs. This is useful if you want to capture compilation error\nmessages (for example, to call ZX BASIC compiler from within an\n<abbr title=\"Integrated Development Environment\">IDE</abbr>).\n\n* **--array-base**\n<br />Unlike original Sinclair BASIC, array indexes starts from 0, not from 1 (see [DIM](dim.md)).\nYou can change this behavior. For example setting `--array-base=1` will make array indexes start from 1\n(like in Sinclair BASIC). This option (array-base=1) is active when `--sinclair` compatibility flag is specified.\n\n* **--string-base**\n<br />Unlike original Sinclair BASIC, string indexes starts from 0, not from 1. That is, in ZX BASIC, a$(1) is\nthe 2nd letter in a$ string variable, and a$(0) the 1st. You can change this behavior, setting which position in\nthe string refers to the 1st letter. For example, setting `--string-base=1` will make strings start from 1\n(like in Sinclair BASIC). This option (string-base=1) is active when `--sinclair` compatibility flag is specified.\n\n* **-Z** or **--sinclair**\n<br />Tries to make ZX BASIC as much compatible as possible with Sinclair BASIC\n(ej. Arrays and Strings start at position 1). Also includes some external functions like `POINT`, `ATTR` and `SCREEN$`,\nnot available by default (they are in external libraries).\n\n* **-H** or **--heap-size**\n<br /> Set the size of the heap. Default heap size is above 4K (4768 bytes exactly).\nThe heap is a memory zone used to store and manipulate strings (and other dynamic size objects where available).\nIf you don't make use of strings, you can get back part of the heap memory. You might also need more heap space,\nso set it with this flag. The heap zone comes at the end of your program,\nand it size is fixed (won't change during program execution).\n\n* **--debug-memory**\n<br /> During your program execution, using strings might fail due to lack of memory, but your program won't report it\nand will continue executing (except the strings not fitting into the heap will be converted to `NULL` string or `\"\"`).\nThe same applies to other dynamic objects. So enabling this flag, will make your program to stop reporting a\nROM _Out of memory_ error. This will add a little overhead to your program execution, but it's useful to detect\n_Out of Memory_ errors.\n\n* **--debug-array**\n<br /> As above, using wrong subscript (out of range) in arrays won't trigger an error.\nSetting this flag will raise ROM error Subscript out of Range. This flag will add a little overhead to your program\nexecution, but it's useful to detect Out of Range errors.\n\n* **--strict-bool**\n<br /> By default, ZX BASIC will treat boolean values as 0 = False, Any other value = True.\nSome programmers expect TRUE = 1 always. Using this option will enforce boolean results to be always 0 or 1.\nUsing this option might add a little overhead to your program. Using `--sinclair` option will also enable this feature.\n\n* **--enable-break**\n<br /> Unlike Sinclair BASIC, Your program, being converted to machine code, won't be affected by BREAK.\nIf you enable this flag, you will be able to stop your program pressing BREAK (Shift + SPACE).\nThe ROM Break message will also report the line in which the program was interrupted.\nThis option will add some overhead to your program.\n\n* **--explicit**\n<br /> Requires all variables to be declared with DIM before being used. This is something similar to Sinclair BASIC,\nin which when you tried to read a variable not previously set, a \"Variable not Found\" error was triggered.\nThis option is really useful and you should enable it for large programs.\n\n* **--strict**\n<br /> Requires all variables (and parameters and functions!) to have an explicit type declared\n(e.g. [Uinteger](types.md)). Otherwise, forgetting a type will cause an error and the program won't compile.\nThis is very useful to avoid forgetting type declarations. When the type is explicitly declared the compiler can make\nbetter assumptions and further error checking and optimizations.\n\nThis is all you need to know to use the compiler. Proceed to the [ZX BASIC](language.md) page for a language reference.\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "DEZOG": {
    "content": "# Memory \r\n\r\n## Table of contents \r\n\r\nAllowed commands are:\r\n\r\n`\"-address address\"`: Prints out internal information of the debugger for a 64k address. Can be helpful if you encounter e.g. 'Unverified breakpoints' problems.\r\n\r\n`\"-dasm address count\"`: Disassembles a memory area. count=number of lines.\r\n\"-eval expr\": Evaluates an expression. The expression might contain mathematical expressions and also labels. It will also return the label if the value correspondents to a label.\r\n\r\n`\"-exec|e cmd args\"`: cmd and args are directly passed to the remote (ZEsarUX, CSpect, ...). E.g. `\"-exec get-registers\"`.\r\n\r\n`\"-help|h\"`: This command. Do \"-e help\" to get all possible remote (ZEsarUX, CSpect, ...) commands.\r\n\r\n`\"-label|-l XXX\"`: Returns the matching labels (XXX) with their values. Allows wildcard \"*\".\r\n`\"-md address size [dec|hex] [word] [little|big]\": Memory dump at 'address' with 'size' bytes. Output is in 'hex' (default) or 'dec'imal. Per default data will be grouped in bytes.\r\n  But if chosen, words are output. Last argument is the endianness which is little endian by default.\r\n`\"-mdelta address size string\"`: This does a 'delta' search on the address range. The memory is searched for byte sequences that contain the same deltas as the given string. E.g. if you would search for \"MIK\" not only \"MIK\" would be found but also \"mik\" or \"njl\". The whole memory is dumped but all values are adjusted by an offset to match the searched string. If several sequences are found the memory might be dumped several times.The idea is to find strings also if they are not coded as ASCII sequence but with some other, unknown coding scheme.\r\n\r\n`\"-memmodel\"`: Prints slot and bank info of the currently used memory model.\r\n`\"-ml address filepath\"`: Loads a binary file into memory. The filepath is relative to the TMP directory.\r\n`\"-ms address size filename\"`: Saves a memory dump to a file. The file is saved to the temp directory.\r\n`\"-msetb address value [repeat]\"`:\r\n\taddress: The address to fill. Can also be a label or expression.\r\n\tvalue: The byte value to set.\r\n\trepeat: (Optional) How often the value is repeated.\r\n\r\nExamples:\r\n\t`\"-msetb 8000h 0Fh\"` : Puts a 15 into memory location 0x8000.\r\n\t`\"-msetb 8000h 0 100h\"` : fills memory locations 0x8000 to 0x80FF with zeroes.\r\n\t`\"-msetb fill_colors_ptr+4 FEh\"`: If fill_colors_ptr is e.g. 0xCF02 the value FEh is put into location 0xCF06.\r\n\r\n`\"-msetw address value [repeat [endianness]]:\"`\r\n- address: The address to fill. Can also be a label or expression.\r\n- value: The word value to set.\r\n- repeat: (Optional) How often the value is repeated.\r\n- endianness: (Optional) 'little' (default) or 'big'.\r\n\r\nExamples:\r\n\t\"-msetw 8000h AF34h\" : Puts 34h into location 0x8000 and AFh into location 0x8001.\r\n\t\"-msetw 8000h AF34h 1 big\" : Puts AFh into location 0x8000 and 34h into location 0x8001.\r\n\t\"-msetw 8000h 1234h 100h\" : fills memory locations 0x8000 to 0x81FF with the word value 1234h.\r\n\r\n`\"-mv address size [address_n size_n]*\"`: Memory view at 'address' with 'size' bytes. Will open a new view to display the memory contents.\r\n\r\n`\"-mvd address size [address_n size_n]*\"`: Opens a memory view that can be used for comparison. I.e. you start at some time than later you update the view and then you can make a diff and search e.g. for all values that have been decremented by 1.\r\n`\"-mvw address size [address_n size_n]* [big]\"`: Memory view at 'address' with 'size' words. Like -mv but display unit is word instead of byte. Normally the display is little endian. This can be changed by adding \"big\" as last argument.\r\n`\"-patterns [index[+count|-endindex] [...]\"`: Shows the tbblue sprite patterns beginning at 'index' until 'endindex' or a number of 'count' indices.\r\n\r\n\tThe values can be omitted. 'index' defaults to 0 and 'count' to 1.\r\n\tWithout any parameter it will show all sprite patterns.\r\n\tYou can concat several ranges.\r\n\tExample: \"-patterns 10-15 20+3 33\" will show sprite patterns at index 10, 11, 12, 13, 14, 15, 20, 21, 22, 33.\r\n\r\n`-rmv`: Shows the memory register view. I.e. a dynamic view with the memory contents the registers point to.\r\n`\"-sprites [slot[+count|-endslot] [...]\"`: Shows the tbblue sprite registers beginning at 'slot' until 'endslot' or a number of 'count' slots. The values can be omitted. 'slot' defaults to 0 and 'count' to 1. You can concat several ranges.\r\n\tExample: \"-sprite 10-15 20+3 33\" will show sprite slots 10, 11, 12, 13, 14, 15, 20, 21, 22, 33.\r\n\tWithout any parameter it will show all visible sprites automatically.\r\n`\"-state save|restore|list|clear|clearall [statename]\"`: Saves/restores the current state. I.e. the complete RAM + the registers.\r\n`\"-wpadd address [size] [type]\"`: Adds a watchpoint. See below.\r\n`\"-wprm address [size] [type]\"`: Removes a watchpoint.\r\n\t- address: The 64k address to watch.\r\n\t- size: The size of the area to watch. Can be omitted. Defaults to 1.\r\n\t- type:\r\n\t    - \"r\": Read watchpoint\r\n\t    - \"w\": Write watchpoint\r\n\t    - \"rw\": Read/write watchpoint. Default.\r\n\tNote: This is a leightweight version of the WPMEM watchpoints you can add to your sources.\r\n\t      Watchpoints added through \"-wpadd\" are independent. They are NOT controlled (enabled/disabled) through the\r\n\t\t  vscode's BREAKPOINTS pane.\r\n\t\t  Furthermore they work on 64k addresses (whereas WPMEM works on long addresses).\r\n\t\t  I.e. a watchpoint added through \"-wpadd\" will break in any bank.\r\n\r\nSome examples:\r\n`\"-exec h 0 100\"`: Does a hexdump of 100 bytes at address 0.\r\n`\"-e write-memory 8000h 9fh\"`: Writes 9fh to memory address 8000h.\r\n`\"-e gr\"`: Shows all registers.\r\n`\"-eval 2+3*5\"`: Results to \"17\".\r\n`\"-msetb mylabel 3\"`: Sets the data at memory location 'mylabel' to 3.\r\n`\"-mv 0 10\"`: Shows the memory at address 0 to address 9.\r\n`\"-sprites\"`: Shows all visible sprites.\r\n`\"-state save 1\"`: Stores the current state as 'into' 1.\r\n`\"-state restore 1\"`: Restores the state 'from' 1.\r\n\r\nNotes:\r\nFor all commands (if it makes sense or not) you can add \"-view\" as first parameter. This will redirect the output to a new view instead of the console.\r\nE.g. use \"-help -view\" to put the help text in an own view.\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PALETTES": {
    "content": "# Palettes\n\n## Overview\n\nThe ZX Spectrum Next supports an advanced palette system that significantly expands the color capabilities beyond the original ZX Spectrum's 15 colors. The palette system allows different graphics modes to access various color options through a series of palette registers and indices.\n\n## Color Basics\n\nThe ZX Spectrum Next uses a 9-bit color system (RRRGGGBBB), allowing for a total of 512 possible colors. Each color component (Red, Green, Blue) uses 3 bits, providing 8 levels of intensity (0-7) per component.\n\n```\nRRRGGGBB,B format:\nR = Red bits (0-7)\nG = Green bits (0-7) \nB = Blue bits (0-7)\n```\n\nColors can be specified using 8-bit (RRRGGGBB) or 9-bit (RRRGGGBBB) values. When using 8-bit values, the missing blue bit is automatically generated as a logical OR of the two existing blue bits.\n\n## Supported Modes\n\nThe number of displayable colors varies depending on the graphics mode:\n\n* **Standard ULA**: 15 colors on screen at once (7 colors plus bright variations, as bright black is still black), using 1 of 2 ULA palettes\n* **ULANext**: Up to 256 colors via attribute mapping, using 1 of 2 ULA Next palettes\n* **Sprites**: 16 colors per sprite (4-bit) with palette offsets or 256 colors (8-bit), using 1 of 2 sprite palettes\n* **Layer 2**: Full 256-color display, using 8-bit pixel values as palette indices, using 1 of 2 Layer 2 palettes\n* **Tilemap**: Up to 16 colors per tile using one of two tilemap palettes for final color lookup\n\n## Setting Palette Colors\n\nTo define a color in a palette:\n\n1. Use [Enhanced ULA Control Register (NR $43)](PALETTE_CONTROL_NR_43.md) to select which palette to write to\n2. Use [Palette Index Register (NR $40)](PALETTE_INDEX_NR_40.md) to select the palette entry index\n3. Then send the color using either:\n   * [Palette Value Register (NR $41)](PALETTE_VALUE_NR_41.md) to send an 8-bit color in RRRGGGBB format\n   * [Enhanced ULA Palette Extension (NR $44)](PALETTE_VALUE_9BIT_NR_44.md) to send a 9-bit color, as two bytes\n\n## Palette Registers\n\n### Palette Index Register (NR $40)\n\n```\nbits 7-0 = Select the palette index to modify\n```\n\nThis register selects which color index in the current palette will be modified. The palette is selected via the Enhanced ULA Control Register (NR $43).\n\nFor the ULA, palette indices have special meanings:\n* Standard INK = indices 0-7\n* Bright INK = indices 8-15\n* PAPER = indices 16-23\n* Bright PAPER = indices 24-31\n\nIn ULANext mode, INK uses indices 0-127 and PAPER uses indices 128-255. In ULA+ mode, the top 64 entries hold the ULA+ palette.\n\n### Palette Value Register (NR $41)\n\n```\nbits 7-0 = 8-bit color value in RRRGGGBB format\n```\n\nThis register writes an 8-bit color value to the index selected by the Palette Index Register (NR $40). The missing third blue bit is automatically generated as an OR of the two blue bits. After each write, the index is auto-incremented if auto-increment is enabled in register NR $43.\n\n### Enhanced ULA Ink Color Mask (NR $42)\n\n```\nbits 7-0 = Mask for ULANext attribute format\n```\n\nDefines how many bits of the ULA attribute byte represent INK (the rest is PAPER). Must be one of: 1, 3, 7, 15, 31, 63, 127, or 255. If the mask is 255 (full ink), PAPER and BORDER colors come from the fallback color in NR $4A.\n\n### Enhanced ULA Control Register (NR $43)\n\n```\nbit 7    = Disable auto-increment (1 = disabled)\nbits 6-4 = Select palette to write or read:\n           000 = ULA first palette\n           100 = ULA second palette\n           001 = Layer 2 first palette\n           101 = Layer 2 second palette\n           010 = Sprites first palette\n           110 = Sprites second palette\n           011 = Tilemap first palette\n           111 = Tilemap second palette\nbit 3    = Select Sprites palette (0 = first, 1 = second)\nbit 2    = Select Layer 2 palette (0 = first, 1 = second)\nbit 1    = Select ULA palette (0 = first, 1 = second)\nbit 0    = Enable ULANext mode (0 after reset)\n```\n\nThis register controls palette selection, auto-increment behavior, and enables ULANext mode.\n\n### Enhanced ULA Palette Extension (NR $44)\n\n```\nFirst byte:  RRRGGGBB\nSecond byte: P000000B\n             bit 0 = LSB of blue component\n             bit 7 = Layer 2 priority (if 1, Layer 2 pixel appears above all other layers)\n```\n\nThis register requires two consecutive writes to set a 9-bit color. For Layer 2, bit 7 of the second byte determines priority.\n\n### Transparency Color Fallback Register (NR $4A)\n\n```\nbits 7-0 = 8-bit fallback color (RRRGGGBB)\n```\n\nThis 8-bit color is used when all layers are transparent. It's also used as PAPER/BORDER color when ULANext attribute mask is invalid or set to 255.\n\n### Sprites Transparency Index Register (NR $4B)\n\n```\nbits 7-0 = Transparency index for sprites\n```\n\nSets which palette index will be treated as transparent in sprite rendering. For 4-bit sprites, only the bottom 4 bits are used.\n\n### Tilemap Transparency Index Register (NR $4C)\n\n```\nbits 7-4 = Reserved, must be 0\nbits 3-0 = Transparency index for tilemap\n```\n\nSets which palette index (0-15) will be treated as transparent for tilemap rendering.\n\n## Working with Palettes\n\n### ULA and ULANext Modes\n\nIn standard ULA mode, the color mapping follows the classic ZX Spectrum model:\n* INK: palette indices 0-7\n* BRIGHT INK: indices 8-15\n* PAPER and BORDER: indices 16-23 and 24-31\n\nIn ULANext mode (enabled via bit 0 of NR $43), the attribute byte is split differently:\n* INK: indices 0-127\n* PAPER/BORDER: indices 128-255\n* The mask in NR $42 defines how the attribute byte is split into INK and PAPER\n\n### Layer 2 Priority Colors\n\nLayer 2 colors can have a priority bit set (bit 7 in the second byte of NR $44). When this bit is set, the Layer 2 pixel will be drawn above all other layers, regardless of the layer priority settings. If you need the same color in both priority and non-priority versions, you'll need two different palette entries.\n\n## Available Files\n\nVarious palette files are available in different formats:\n* Adobe Photoshop (.ACT)\n* GIMP (.GPL)\n* JASC (.PAL)\n* Raw binary formats\n\n\n## Remarks\n\n* Modern displays use 8-bit RGB values (0-255), but the Spectrum Next uses 3-bit values (0-7), so converting colors will always involve some form of approximation.\n* Only 256 colors can be displayed at once, even when using 512-color palettes.\n* Auto-increment of the palette index can be disabled by setting bit 7 of NR $43.\n* ULA+ mode is available by enabling bit 3 of ULA Control Register ($68) for compatibility with ULA+ systems.\n\n## See also\n\n* [Palette Index Register (NR $40)](PALETTE_INDEX_NR_40.md)\n* [Palette Value Register (NR $41)](PALETTE_VALUE_NR_41.md)\n* [Enhanced ULA Ink Color Mask (NR $42)](PALETTE_FORMAT_NR_42.md)\n* [Enhanced ULA Control Register (NR $43)](PALETTE_CONTROL_NR_43.md)\n* [Enhanced ULA Palette Extension (NR $44)](PALETTE_VALUE_9BIT_NR_44.md)\n* [Transparency Color Fallback Register (NR $4A)](transparency_color_fallback_register_nr_4a.md)\n* [Sprites Transparency Index Register (NR $4B)](sprites_transparency_index_register_nr_4b.md)\n* [Tilemap Transparency Index Register (NR $4C)](tilemap_transparency_index_register_nr_4c.md)\n* [Layer 2](layer_2.md)\n* [Sprites](_sprites.md)\n* [Tilemap](tilemap.md)\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ALTERNATE_ROM_NR_8C": {
    "content": "# ALTERNATE_ROM_NR_8C\r\n\r\n## Syntax\r\n\r\n```\r\nALTERNATE_ROM_NR_8C = $8C\r\n```\r\n\r\n## Description\r\n\r\nEnable alternate ROM or lock 48k ROM\r\n\r\n```\r\n(R/W) (hard reset = 0)\r\nIMMEDIATE\r\n  bit 7 = 1 to enable alt rom\r\n  bit 6 = 1 to make alt rom visible only during writes, otherwise replaces rom during reads\r\n  bit 5 = 1 to lock ROM1 (48K rom)\r\n  bit 4 = 1 to lock ROM0 (128K rom) AFTER SOFT RESET (copied into bits 7-4)\r\n  bit 3 = 1 to enable alt rom\r\n  bit 2 = 1 to make alt rom visible only during writes, otherwise replaces rom during reads\r\n  bit 1 = 1 to lock ROM1 (48K rom)\r\n  bit 0 = 1 to lock ROM0 (128K rom)\r\n```  \r\nThe locking mechanism also applies if the alt rom is not enabled. For the +3 and Next, if the two lock bits are not zero, then the corresponding rom page is locked in place. Other models use the bits to preferentially lock the corresponding 48K rom or the 128K rom.\r\n\r\n## Remarks \r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n```\r\n#INCLUDE <nextlib.bas>\r\n```",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ANTI_BRICK_NR_10": {
    "content": "# ANTI_BRICK_NR_10\r\n\r\n## Syntax\r\n\r\n```\r\nANTI_BRICK_NR_10 = $10\r\n```\r\n\r\n## Description\r\n\r\nUsed within the Anti-brick system.\r\n\r\nRead:\r\n```\r\n\r\nBit     Effect\r\n7       Reserved\r\n6-2     Core ID\r\n1       Button DRIVE (DivMMC) is pressed\r\n0       Button M1 (Multiface) is pressed \r\n```\r\nWrite:\r\n```\r\nBit \tEffect\r\n7       Start selected core (reboot FPGA)\r\n6-5 \tReserved, must be 0\r\n4-0 \tCore ID 0-31 (default is 2) (only in config mode) * \r\n```\r\n\r\n* A write of an out of range core id is ignored; this is the preferred way to determine max id\r\n\r\nNote that in normal running pressing the DivMMC or Multiface button creates an NMI which halts any running program, and the reflashable core must be loaded before any user code is run. This means that unless you are rewriting the entire firmware from scratch this register is probably not useful. \r\n\r\n## Remarks\r\n\r\nMore info : [https://wiki.specnext.dev/Anti-brick_Register](https://wiki.specnext.dev/Anti-brick_Register)\r\n\r\nRequires: \r\n\r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n\r\n## Links \r\n\r\n[Index](Index.md)\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CLIP_LAYER2_NR_18": {
    "content": "# CLIP_LAYER2_NR_18\r\n\r\n## Syntax\r\n\r\n```\r\nCLIP_LAYER2_NR_18 = $18\r\n```\r\n\r\n## Description\r\n\r\nRegister to set and read clip-window for Layer 2. (R\\W)\r\n\r\nThe coordinates are stored under index:\r\n```\r\nIndex\tCoordinate\r\n0\t'X1 Position\r\n1\t'X2 Position\r\n2\t'Y1 Position\r\n3\t'Y2 Position\r\n```\r\n\r\nThe current read/write index (which coordinate is selected) can be read or reset by Clip Window Control Register ($1C).\r\n\r\nWrite to register will modify currently selected coordinate, and auto-increment index (wrapping from 3 to 0).\r\n\r\nRead from register will only read currently selected coordinate, index is not modified (to read next coordinate, write the current coordinate value back, to increment index).\r\n\r\nThe coordinate values are 0,255,0,191 after a Reset.\r\n\r\nThe displayed area is \"inclusive\", i.e. for default values full 256x192 pixel area is displayed.\r\n\r\n## Remarks\r\n\r\nMore info : https://wiki.specnext.dev/Clip_Window_Layer_2_Register\r\n\r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n\r\n## Links \r\n\r\n[Index](Index.md)\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CLIP_SPRITE_NR_19": {
    "content": "# CLIP_SPRITE_NR_19\r\n\r\n## Syntax\r\n\r\n```\r\nCLIP_SPRITE_NR_19 = $19\r\n```\r\n\r\n## Description\r\n\r\n**CLIP WINDOW SPRITES REGISTER** More info : https://wiki.specnext.dev/Clip_Window_Sprites_Register\r\n\r\nSets and reads clip-window for Sprites. (R\\W)\r\n\r\nThe coordinates are stored under index:\r\n```\r\nIndex\tCoordinate\r\n0\t'X1 Position\r\n1\t'X2 Position\r\n2\t'Y1 Position\r\n3\t'Y2 Position\r\n```\r\nThe current read/write index (which coordinate is selected) can be read or reset by **Clip Window Control Register** ($1C).\r\n\r\nWrite to register will modify currently selected coordinate, and auto-increment index (wrapping from 3 to 0).\r\n\r\nRead from register will only read currently selected coordinate, index is not modified (to read next coordinate, write the current coordinate value back, to increment index).\r\n\r\n**The coordinate values are 0,255,0,191 after a Reset.**\r\n\r\nThe displayed area is \"inclusive\", i.e. for default values full 256x192 pixel area is displayed.\r\n\r\nClip window on Sprites works by default only when the \"draw over border\" is disabled. With \"over border\" enabled, the clip window must be enabled extra by bit 5 in Sprite and Layers System Register ($15), and X-axis coordinates of clip-window are then doubled, see the Sprite and Layers System Register ($15) for details and example. Set it to {0,159,0,255} to cover whole pixel+border sprite area (320x256 pixels area of display) in the x-axis doubled mode. Although setting it larger (like {0,255,0,255}) should be safe operation and still the full 320x256 area for sprite pixels will be visible.\r\n\r\nRequires: \r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n ## Links \r\n\r\n[Index](Index.md)\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CLIP_TILEMAP_NR_1B": {
    "content": "# CLIP_TILEMAP_NR_1B\r\n\r\n## Syntax\r\n\r\n```\r\nCLIP_TILEMAP_NR_1B = $1B\r\n```\r\n\r\n## Description\r\n\r\n**CLIP WINDOW TILEMAP REGISTER** More info : https://wiki.specnext.dev/Clip_Window_Tilemap_Register\r\n\r\nSets and reads clip-window for Tilemap. (R\\W)\r\n\r\nThe coordinates are stored under index:\r\n\r\n```\r\nIndex\tCoordinate\r\n0\t'X1 Position\r\n1\t'X2 Position\r\n2\t'Y1 Position\r\n3\t'Y2 Position\r\n```\r\n\r\nThe current read/write index (which coordinate is selected) can be read or reset by Clip Window Control Register ($1C).\r\n\r\nWrite to register will modify currently selected coordinate, and auto-increment index (wrapping from 3 to 0).\r\n\r\nRead from register will only read currently selected coordinate, index is not modified (to read next coordinate, write the current coordinate value back, to increment index).\r\n\r\nThe X coordinates are internally doubled (40x32 mode) or quadrupled (80x32 mode), and origin [0,0] is 32* pixels left and above the top-left ULA pixel, i.e. Tilemap mode does use same coordinates as Sprites, reaching 32* pixels into \"BORDER\" on each side.\r\n\r\n**The coordinate values are 0,159,0,255 after a Reset.**\r\n\r\nThe displayed area is \"inclusive\", i.e. for default values full 320x256 (640x256) sprite-pixel area is displayed.\r\n\r\n*32 pixels in 40x32 mode, when pixels have identical width with classic ULA and Sprite pixels. In 80x32 mode the pixels have half width, but they cover the identical screen area, so the first ULA pixel is then at [64,32] position out of [0..639,0..255] area.  \r\n\r\nRequires: \r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n\r\n## Links \r\n\r\n[Index](Index.md)\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CLIP_ULA_LORES_NR_1A": {
    "content": "# CLIP_ULA_LORES_NR_1A\r\n\r\n## Syntax\r\n\r\n```\r\nCLIP_ULA_LORES_NR_1A = $1A\r\n```\r\n\r\n## Description\r\n\r\n**CLIP WINDOW ULA/LORES REGISTER** More info : https://wiki.specnext.dev/Clip_Window_ULA/LoRes_Register\r\n\r\nSets and reads clip-window for ULA/LoRes layer. (R\\W)\r\n\r\nThe coordinates are stored under index:\r\n```\r\nIndex\tCoordinate\r\n0\t\t'X1 Position\r\n1\t\t'X2 Position\r\n2\t\t'Y1 Position\r\n3\t\t'Y2 Position\r\n```\r\nThe current read/write index (which coordinate is selected) can be read or reset by Clip Window Control Register ($1C).\r\n\r\nWrite to register will modify currently selected coordinate, and auto-increment index (wrapping from 3 to 0).\r\n\r\nRead from register will only read currently selected coordinate, index is not modified (to read next coordinate, write the current coordinate value back, to increment index)\r\n\r\nThe coordinate values are 0,255,0,191 after a Reset.\r\n\r\nThe displayed area is \"inclusive\", i.e. for default values full 256x192 pixel area is displayed.\r\n\r\nLoRes may get a separate clip window in the future.  \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CLIP_WINDOW_CONTROL_NR_1C": {
    "content": "# CLIP_WINDOW_CONTROL_NR_1C\r\n\r\n## Syntax\r\n\r\n```\r\nCLIP_WINDOW_CONTROL_NR_1C = $1C\r\n```\r\n\r\n## Description\r\n\r\n**CLIP WINDOW CONTROL REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/Clip_Window_Control_Register\r\n\r\nControls (resets) the clip-window registers indices. (R/W)\r\n\r\n**Bit Write**\r\n\r\n\tBit\tFunction\r\n\t7-4  'Reserved must be 0\r\n\t3\t'reset the Tilemap clip-window register index (by writing 1).\r\n\t2\t'reset the ULA/LoRes clip-window register index (by writing 1).\r\n\t1\t'reset the Sprite clip-window register index (by writing 1).\r\n\t0\t'reset the Layer 2 clip-window register index (by writing 1).\r\n\r\n**Bit Read**\r\n\r\n\t7-6  'the current Tilemap clip-window register index  \r\n\t5-4  'the current ULA/LoRes clip-window register index\r\n\t3-2  'he current Sprite clip-window register index\r\n\t1-0  'the current Layer 2 clip-window register index\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "COPPER_CONTROL_HI_NR_62": {
    "content": "# COPPER_CONTROL_HI_NR_62\r\n\r\n## Syntax\r\n\r\n```\r\nCOPPER_CONTROL_HI_NR_62 = $62\r\n```\r\n\r\n## Description\r\n\r\n**COPPER CONTROL HIGH BYTE** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Copper_Control_High_Byte\r\n\r\nHolds high byte of [Copper](https://wiki.specnext.dev/Copper) control flags.\r\n\r\n**Bit**\r\n\r\n\t7-6  'Control Mode\r\n\t5-3  'Reserved must be 0\r\n\t2-0  'High three bits of Copper list index (value-2047)\r\n\r\nWhen \"Control mode\" bits are identical with previously set ones, they are ignored - allowing for index change without restarting currently running Copper program.\r\n\r\nCopper has internally 10 bit \"program counter\" register (**CPC**), going through 0-1023 values, executing Copper instruction from the list at memory position (CPC*2). This will cause the Copper program to loop automatically. To \"halt\" program (avoiding possible loop), use WAIT instruction with non-existent horizontal line, like \"**WAIT 63,511 = 0xFF, 0xFF**\".\r\n\r\n**Bits 7-6**\r\n\r\n\t%00 'STOP Copper (CPC is kept at current value)\r\n\t%01 'Reset CPC to 0 and START Copper\r\n\t%10 'START Copper (does resume at current CPC)\r\n\t%11 'Reset CPC to 0 and START Copper, reset CPC at each video frame at (0,0) (top left pixel of PAPER area)\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "COPPER_CONTROL_LO_NR_61": {
    "content": "# COPPER_CONTROL_LO_NR_61\r\n\r\n## Syntax\r\n\r\n```\r\nCOPPER_CONTROL_LO_NR_61 = $61\r\n```\r\n\r\n## Description\r\n\r\n**COPPER CONTROL LOW BYTE** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Copper_Control_Low_Byte\r\n\r\nHolds low byte of Copper control bits.\r\n\r\nLow eight bits of [Copper](https://wiki.specnext.dev/Copper) list index.Index is set to 0 after a reset.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "COPPER_DATA_16B_NR_63": {
    "content": "# COPPER_DATA_16B_NR_63\r\n\r\n## Syntax\r\n\r\n```\r\nCOPPER_DATA_16B_NR_63 = $63\r\n```\r\n\r\n## Description\r\n\r\n**COPPER DATA 16-BIT WRITE REGISTER** (W)\r\n\r\n[More info](https://wiki.specnext.dev/Copper_Data_16-bit_Write_Register)\r\n\r\nUsed to upload code to the [Copper](https://wiki.specnext.dev/Copper)\r\n\r\nSimilar to [Copper Data ($60)](https://wiki.specnext.dev/Copper_Data), allows to upload Copper instructions to the copper memory, but the difference is that writes are committed to copper memory in 16-bit words (only half-written instructions by using NextReg $60 may get executed, $63 prevents that).\r\n\r\nThe first write to this register is MSB of Copper Instruction destined for even copper instruction address.\r\n\r\nThe second write to this register is LSB of Copper Instruction destined for odd copper instruction address.\r\n\r\nAfter any write, the copper address is auto-incremented to the next memory position.\r\n\r\nAfter a write to an odd address, the entire 16-bits are written to Copper memory at once.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "COPPER_DATA_NR_60": {
    "content": "# COPPER_DATA_NR_60\r\n\r\n## Syntax\r\n\r\n```\r\nCOPPER_DATA_NR_60 = $60\r\n```\r\n\r\n## Description\r\n\r\n**COPPER DATA** (W)\r\n\r\nMore info : https://wiki.specnext.dev/Copper_Data\r\n\r\nUsed to upload code to the [Copper](https://wiki.specnext.dev/Copper).\r\n\r\nAfter the write, the index is auto-incremented to the next memory position. The index wraps to zero when the last BYTE of program RAM is written (position 2047).\r\n\r\nEach Copper instruction is composed by two bytes (16 bits) - two writes are required to complete one instruction upload.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DAC_AD_MIRROR_NR_2D": {
    "content": "# DAC_AD_MIRROR_NR_2D\r\n\r\n## Syntax\r\n\r\n```\r\nDAC_AD_MIRROR_NR_2D = $2D\r\n```\r\n\r\n## Description\r\n\r\n**DAC A+D (MONO) MIRROR REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/DAC_A%2BD_(mono)_mirror_Register\r\n\r\nSpecDrum port 0xDF / DAC A+D mirror, read current I2S LSB\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DAC_B_MIRROR_NR_2C": {
    "content": "# DAC_B_MIRROR_NR_2C\r\n\r\n## Syntax\r\n\r\n```\r\nDAC_B_MIRROR_NR_2C = $2C\r\n```\r\n\r\n## Description\r\n\r\n**DAC B (LEFT) MIRROR REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/DAC_B_(left)_mirror_Register\r\n\r\nDAC B mirror, read current I2S left MSB\r\n\r\n**Write**\r\n\r\n\tbits 7:0 ' 8-bit sample written to left side DAC B (soft reset = $80)\r\n\r\n**Read**\r\n\r\n\tbits 7:0 ' MSB of current I2S (Pi:NextPi) left side sample\r\n\r\nthe LSB is latched and can be read from DAC A+D (mono) mirror Register ($2D) later\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DAC_COVOX_INDEX": {
    "content": "# DAC_COVOX_INDEX\r\n\r\n## Syntax\r\n\r\n```\r\nDAC_COVOX_INDEX = 6\r\n```\r\n\r\n## Description\r\n\r\nDAC_COVOX_INDEX = 6\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DAC_C_MIRROR_NR_2E": {
    "content": "# DAC_C_MIRROR_NR_2E\r\n\r\n## Syntax\r\n\r\n```\r\nDAC_C_MIRROR_NR_2E = $2E\r\n```\r\n\r\n## Description\r\n\r\nDAC_C_MIRROR_NR_2E = $2E\r\n\r\nMore info : https://wiki.specnext.dev/DAC_C_(right)_mirror_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DAC_GS_COVOX_INDEX": {
    "content": "# DAC_GS_COVOX_INDEX\r\n\r\n## Syntax\r\n\r\n```\r\nDAC_GS_COVOX_INDEX = 1\r\n```\r\n\r\n## Description\r\n\r\nDAC_GS_COVOX_INDEX = 1\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DAC_PENTAGON_ATM_INDEX": {
    "content": "# DAC_PENTAGON_ATM_INDEX\r\n\r\n## Syntax\r\n\r\n```\r\nDAC_PENTAGON_ATM_INDEX = 2\r\n```\r\n\r\n## Description\r\n\r\nDAC_PENTAGON_ATM_INDEX = 2\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DAC_PROFI_COVOX_INDEX": {
    "content": "# DAC_PROFI_COVOX_INDEX\r\n\r\n## Syntax\r\n\r\n```\r\nDAC_PROFI_COVOX_INDEX = 7\r\n```\r\n\r\n## Description\r\n\r\nDAC_PROFI_COVOX_INDEX = 7\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DAC_SOUNDRIVE1_INDEX": {
    "content": "# DAC_SOUNDRIVE1_INDEX\r\n\r\n## Syntax\r\n\r\n```\r\nDAC_SOUNDRIVE1_INDEX = 4\r\n```\r\n\r\n## Description\r\n\r\nDAC_SOUNDRIVE1_INDEX = 4\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DAC_SOUNDRIVE2_INDEX": {
    "content": "# DAC_SOUNDRIVE2_INDEX\r\n\r\n## Syntax\r\n\r\n```\r\nDAC_SOUNDRIVE2_INDEX = 5\r\n```\r\n\r\n## Description\r\n\r\nDAC_SOUNDRIVE2_INDEX = 5\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DAC_SPECDRUM_INDEX": {
    "content": "# DAC_SPECDRUM_INDEX\r\n\r\n## Syntax\r\n\r\n```\r\nDAC_SPECDRUM_INDEX = 3\r\n```\r\n\r\n## Description\r\n\r\nDAC_SPECDRUM_INDEX = 3\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DEBUG_LED_CONTROL_NR_FF": {
    "content": "# DEBUG_LED_CONTROL_NR_FF\r\n\r\n## Syntax\r\n\r\n```\r\nDEBUG_LED_CONTROL_NR_FF = $FF\r\n```\r\n\r\n## Description\r\n\r\nDEBUG_LED_CONTROL_NR_FF = $FF\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DISPLAY_CONTROL_NR_69": {
    "content": "# DISPLAY_CONTROL_NR_69\r\n\r\n## Syntax\r\n\r\n```\r\nDISPLAY_CONTROL_NR_69 = $69\r\n```\r\n\r\n## Description\r\n\r\n**DISPLAY CONTROL 1 REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Display_Control_1_Register\r\n\r\nLayer2, ULA shadow, Timex $FF port\r\n\r\n**Bit**\r\n\r\n\t7\t' Enable the Layer 2 (alias for Layer 2 Access Port ($123B / 4667) bit 1)\r\n\t6\t' Enable ULA shadow (bank 7) display alias (for Memory Paging Control ($7FFD / 32765) bit 3]\r\n\t5-0  ' alias for Timex Sinclair Video Mode ($xxFF / 255) bits 5:0Control\r\n\r\nULA shadow screen from Bank 7 has higher priority than Timex modes, setting bit 6 to \"1\" together with one of the extended Timex graphic modes will result into classic ZX128 ULA mode using Bank 7 data.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ESP_WIFI_GPIO_NR_A9": {
    "content": "# ESP_WIFI_GPIO_NR_A9\r\n\r\n## Syntax\r\n\r\n```\r\nESP_WIFI_GPIO_NR_A9 = $A9\r\n```\r\n\r\n## Description\r\n\r\nESP_WIFI_GPIO_NR_A9 = $A9\r\n\r\nMore info : https://wiki.specnext.dev/ESP_WiFi_GPIO_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ESP_WIFI_GPIO_OUTPUT_NR_A8": {
    "content": "# ESP_WIFI_GPIO_OUTPUT_NR_A8\r\n\r\n## Syntax\r\n\r\n```\r\nESP_WIFI_GPIO_OUTPUT_NR_A8 = $A8\r\n```\r\n\r\n## Description\r\n\r\nESP_WIFI_GPIO_OUTPUT_NR_A8 = $A8\r\n\r\nMore info : https://wiki.specnext.dev/ESP_WiFi_GPIO_Output_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "EXPANSION_BUS_CONTROL_NR_81": {
    "content": "# EXPANSION_BUS_CONTROL_NR_81\r\n\r\n## Syntax\r\n\r\n```\r\nEXPANSION_BUS_CONTROL_NR_81 = $81\r\n```\r\n\r\n## Description\r\n\r\nEXPANSION_BUS_CONTROL_NR_81 = $81\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "EXPANSION_BUS_DECODING_0_NR_86": {
    "content": "# EXPANSION_BUS_DECODING_0_NR_86\r\n\r\n## Syntax\r\n\r\n```\r\nEXPANSION_BUS_DECODING_0_NR_86 = $86\r\n```\r\n\r\n## Description\r\n\r\nEXPANSION_BUS_DECODING_0_NR_86 = $86\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "EXPANSION_BUS_DECODING_1_NR_87": {
    "content": "# EXPANSION_BUS_DECODING_1_NR_87\r\n\r\n## Syntax\r\n\r\n```\r\nEXPANSION_BUS_DECODING_1_NR_87 = $87\r\n```\r\n\r\n## Description\r\n\r\nEXPANSION_BUS_DECODING_1_NR_87 = $87\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "EXPANSION_BUS_DECODING_2_NR_88": {
    "content": "# EXPANSION_BUS_DECODING_2_NR_88\r\n\r\n## Syntax\r\n\r\n```\r\nEXPANSION_BUS_DECODING_2_NR_88 = $88\r\n```\r\n\r\n## Description\r\n\r\nEXPANSION_BUS_DECODING_2_NR_88 = $88\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "EXPANSION_BUS_DECODING_3_NR_89": {
    "content": "# EXPANSION_BUS_DECODING_3_NR_89\r\n\r\n## Syntax\r\n\r\n```\r\nEXPANSION_BUS_DECODING_3_NR_89 = $89\r\n```\r\n\r\n## Description\r\n\r\nEXPANSION_BUS_DECODING_3_NR_89 = $89\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "EXPANSION_BUS_ENABLE_NR_80": {
    "content": "# EXPANSION_BUS_ENABLE_NR_80\r\n\r\n## Syntax\r\n\r\n```\r\nEXPANSION_BUS_ENABLE_NR_80 = $80\r\n```\r\n\r\n## Description\r\n\r\nEXPANSION_BUS_ENABLE_NR_80 = $80\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "EXPANSION_BUS_PROPAGATE_NR_8A": {
    "content": "# EXPANSION_BUS_PROPAGATE_NR_8A\r\n\r\n## Syntax\r\n\r\n```\r\nEXPANSION_BUS_PROPAGATE_NR_8A = $8A\r\n```\r\n\r\n## Description\r\n\r\nEXPANSION_BUS_PROPAGATE_NR_8A = $8A\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "EXTENDED_KEYS_0_NR_B0": {
    "content": "# EXTENDED_KEYS_0_NR_B0\r\n\r\n## Syntax\r\n\r\n```\r\nEXTENDED_KEYS_0_NR_B0 = $B0\r\n```\r\n\r\n## Description\r\n\r\nEXTENDED_KEYS_0_NR_B0 = $B0\r\n\r\nMore info : https://wiki.specnext.dev/Extended_Keys_0_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "EXTENDED_KEYS_1_NR_B1": {
    "content": "# EXTENDED_KEYS_1_NR_B1\r\n\r\n## Syntax\r\n\r\n```\r\nEXTENDED_KEYS_1_NR_B1 = $B1\r\n```\r\n\r\n## Description\r\n\r\nEXTENDED_KEYS_1_NR_B1 = $B1\r\n\r\nMore info : https://wiki.specnext.dev/Extended_Keys_1_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "GLOBAL_TRANSPARENCY_NR_14": {
    "content": "# GLOBAL_TRANSPARENCY_NR_14\r\n\r\n## Syntax\r\n\r\n```\r\nGLOBAL_TRANSPARENCY_NR_14 = $14\r\n```\r\n\r\n## Description\r\n\r\n**GLOBAL TRANSPARENCY REGISTER** More info : https://wiki.specnext.dev/Global_Transparency_Register\r\n\r\nSets the \"transparent\" colour for Layer 2, ULA and LoRes pixel data.  (R/W)\r\n\r\nTransparency color value (0xE3 after a reset).\r\n\r\nThis value is 8-bit only, so the transparency is compared only by the MSB bits of the final colour.\r\n\r\nThis only affects Layer 2, ULA, LoRes and 1-bit (\"text mode\") tilemap. Sprites use **SPRITE_TRANSPARENCY_I_NR_4B** ($4B) for transparency, 4-bit Tilemap uses **TILEMAP_TRANSPARENCY_I_NR_4C** ($4C). \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "HIGH_ADRESS_KEYMAP_NR_28": {
    "content": "# HIGH_ADRESS_KEYMAP_NR_28\r\n\r\n## Syntax\r\n\r\n```\r\nHIGH_ADRESS_KEYMAP_NR_28 = $28\r\n```\r\n\r\n## Description\r\n\r\n**KEYMAP HIGH ADDRESS REGISTER**\r\n\r\nMore info : https://wiki.specnext.deveymap_High_Address_Register\r\n\r\nPS/2 Keymap address MSB, read (pending) first byte of palette colour\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "HIGH_DATA_TO_KEYMAP_NR_2A": {
    "content": "# HIGH_DATA_TO_KEYMAP_NR_2A\r\n\r\n## Syntax\r\n\r\n```\r\nHIGH_DATA_TO_KEYMAP_NR_2A = $2A\r\n```\r\n\r\n## Description\r\n\r\n**KEYMAP HIGH DATA REGISTER**\r\n\r\nMMore info : https://wiki.specnext.dev/Keymap_High_Data_Register\r\n\r\nHigh data to PS/2 Keymap (MSB of data in bit 0)\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INTERNAL_PORT_DECODING_0_NR_82": {
    "content": "# INTERNAL_PORT_DECODING_0_NR_82\r\n\r\n## Syntax\r\n\r\n```\r\nINTERNAL_PORT_DECODING_0_NR_82 = $82\r\n```\r\n\r\n## Description\r\n\r\nINTERNAL_PORT_DECODING_0_NR_82 = $82\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INTERNAL_PORT_DECODING_1_NR_83": {
    "content": "# INTERNAL_PORT_DECODING_1_NR_83\r\n\r\n## Syntax\r\n\r\n```\r\nINTERNAL_PORT_DECODING_1_NR_83 = $83\r\n```\r\n\r\n## Description\r\n\r\nINTERNAL_PORT_DECODING_1_NR_83 = $83\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INTERNAL_PORT_DECODING_2_NR_84": {
    "content": "# INTERNAL_PORT_DECODING_2_NR_84\r\n\r\n## Syntax\r\n\r\n```\r\nINTERNAL_PORT_DECODING_2_NR_84 = $84\r\n```\r\n\r\n## Description\r\n\r\nINTERNAL_PORT_DECODING_2_NR_84 = $84\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INTERNAL_PORT_DECODING_3_NR_85": {
    "content": "# INTERNAL_PORT_DECODING_3_NR_85\r\n\r\n## Syntax\r\n\r\n```\r\nINTERNAL_PORT_DECODING_3_NR_85 = $85\r\n```\r\n\r\n## Description\r\n\r\nINTERNAL_PORT_DECODING_3_NR_85 = $85\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LAYER2_CONTROL_NR_70": {
    "content": "# LAYER2_CONTROL_NR_70\r\n\r\n## Syntax\r\n\r\n```\r\nLAYER2_CONTROL_NR_70 = $70\r\n```\r\n\r\n## Description\r\n\r\n**LAYER 2 CONTROL REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/Layer_2_Control_Register\r\n\r\nLayer 2 resolution, palette offset (R/W)\r\n\r\n**Bits**\r\n\r\n\t7-6  'Reserved, must be 0\r\n\t5-4  'Layer 2 resolution (0 on reset)\r\n\t\t%00 ' 256x192x8bpp\r\n\t\t%01 ' 320x256x8bpp\r\n\t\t%10 ' 640x256x4bpp\r\n\t3-0  'Palette offset (soft reset = 0)\r\n\r\nThe 256x192x8bpp mode is simple 256 colour mode, one pixel is one byte (index into Layer 2 palette), pixels are stored from left to right, from top to bottom (next pixel to right is at +1 address, next pixel below is at +256 address), total memory is 48kiB = three 16kiB banks, starting at bank set in Layer 2 RAM Page Register ($12).\r\n\r\nThe 320x256x8bpp mode is similar, but pixels are stored from top to bottom, then from left to right! Next pixel to right is at +256 address, next pixel below is at +1 address (the image data are kind of \"transposed\" in memory). The clip window X coordinates are doubled like for tile mode and sprites. Total memory is 80kiB = five 16kiB banks, selected also by NextReg $12. The first bank then contains whole columns 0..63 (64 pixels width), the last fifth bank contains whole columns 256..319.\r\n\r\nThe 640x256x4bpp mode is more like 320x256x8bpp mode, but every byte is displayed as two half-width paired pixels, the left pixel colour extracted from top four bits %1111'0000, right pixel extracted from low four bits %0000'1111. This means that next two paired pixels below are at +1 address, and next two paired pixels at right are at +256 address.\r\n\r\nDon't forget to set up the clip window for 320x256 or 640x256 modes, to make whole area visible, use 0,159,0,255 settings (the 640x256 does quadruple the value so X1=10,X2=80 makes pixels 40..323 visible (inclusive)). The Layer 2 clip window is by default set to 0,255,0,191 which shows full 256x192x8bpp mode, but it will make the larger modes appear cut at bottom.\r\n\r\nPalette offset is added to top four bits of pixel value (in case of 4bpp mode it just forms top four bits of pixel value, nothing to add with, pixel data are bottom four bits) and does apply to all Layer 2 modes.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LAYER2_RAM_BANK_NR_12": {
    "content": "# LAYER2_RAM_BANK_NR_12\r\n\r\n## Syntax\r\n\r\n```\r\nLAYER2_RAM_BANK_NR_12 = $12\r\n```\r\n\r\n## Description\r\n\r\n**LAYER 2 RAM PAGE REGISTER** More info : https://wiki.specnext.dev/Layer_2_RAM_Page_Register\r\n\r\nNote that this register uses the 16kiB bank method, so if you set Nextreg $12,$C if you need to read the contents via 8kb banks you would need to multiply x 2 (16k bank $0C is identical to 8k pages $18 and $19).\r\n\r\nBits 6-0 store the number of the \"SRAM page\" (ie, bank) used for the standard Layer 2 screen. The default is 8. Because the layer 2 screen is 48kiB, it actually occupies 3 banks, and the number set here is the first; so by default, it occupies banks 8-10. Then later NextZXOS does reconfigure both this and shadow bank to 9 (banks 9-11). (bit 7 is reserved, use always 0)\r\n\r\nFor shadow bank paging see Layer_2 and Layer 2 RAM Shadow Page Register ($13).\r\n\r\nValid values are 0 to 109 (with 2MiB SRAM memory extension, 0 to 45 with default 1MiB memory).\r\n\r\nThe new 320x256x8 and 640x256x4 Layer 2 modes require 80kiB of memory, i.e. five 16k banks. The valid values are then 0 to 107 (2MiB extended) or 0 to 43 with default 1MiB model.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LAYER2_RAM_SHADOW_BANK_NR_13": {
    "content": "# LAYER2_RAM_SHADOW_BANK_NR_13\r\n\r\n## Syntax\r\n\r\n```\r\nLAYER2_RAM_SHADOW_BANK_NR_13 = $13\r\n```\r\n\r\n## Description\r\n\r\n**LAYER 2 RAM SHADOW PAGE REGISTER** More info : https://wiki.specnext.dev/Layer_2_RAM_Shadow_Page_Register\r\n\r\nSets the bank number where the Layer 2 shadow screen begins.\r\n\r\nBits 6-0 store the number of the \"SRAM page\" (ie, bank) used for the shadow Layer 2 screen. The default is 11. Because the layer 2 screen is 48kiB, it actually occupies 3 banks, and the number set here is the first; so by default, it occupies banks 11-13. (bit 7 is reserved, use 0)\r\n\r\nFor shadow bank paging see Layer_2\r\n\r\nValid values are 0 to 109 (with 2MiB SRAM memory extension, 0 to 45 with default 1MiB memory).\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LAYER2_XOFFSET_MSB_NR_71": {
    "content": "# LAYER2_XOFFSET_MSB_NR_71\r\n\r\n## Syntax\r\n\r\n```\r\nLAYER2_XOFFSET_MSB_NR_71 = $71\r\n```\r\n\r\n## Description\r\n\r\n**LAYER 2 X OFFSET MSB REGISTER** (R/W)\r\n\r\nSets the pixel offset used for drawing Layer 2 graphics on the screen. You can use [ScrollLayer2(x, y)](SCROLLLAYER2.md) for conveinience. \r\n```\r\nbits 7-1 ' Reserved must be 0\r\nbits 0   ' MSB scroll amount\r\n```\r\nThis is most significant bit for high resolution **320x256x8** and **640x256x4** Layer 2 modes (valid range of scroll values is then [0..319], in **640x256x4** mode the layer is scrolling by two pixels horizontally)\r\n\r\nThe low 8 bits are defined by [Layer 2 X Offset Register $16](LAYER2_XOFFSET_LSB_NR_16.md)\r\n\r\n## Links\r\n\r\nMore info : https://wiki.specnext.dev/Layer_2_X_Offset_MSB_Register\r\n\r\n## Requires:\r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n\r\n[SCROLLLAYER](SCROLLLAYER.md)",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LAYER2_XOFFSET_NR_16": {
    "content": "# LAYER2_XOFFSET_NR_16\r\n\r\n## Syntax\r\n\r\n```\r\nLAYER2_XOFFSET_NR_16 = $16\r\n```\r\n\r\n## Description\r\n\r\n**LAYER 2 X OFFSET REGISTER** More info : https://wiki.specnext.dev/Layer_2_X_Offset_Register\r\n\r\nSets the pixel offset used for drawing Layer 2 graphics on the screen.\r\n\r\n**Valid Range**\r\n\r\n\t0-255\t'0 after a reset\r\n\r\nThe ninth most significant bit of scroll value is in **Layer 2 X Offset MSB Register** ($71) (for the 320x256 and 640x256 modes the valid X-offset range is 0..319, so one more bit is needed).\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LAYER2_YOFFSET_NR_17": {
    "content": "# LAYER2_YOFFSET_NR_17\r\n\r\n## Syntax\r\n\r\n```\r\nLAYER2_YOFFSET_NR_17 = $17\r\n```\r\n\r\n## Description\r\n\r\n**LAYER 2 Y OFFSET REGISTER** More info : https://wiki.specnext.dev/Layer_2_Y_Offset_Register\r\n\r\nSets the Y offset used when drawing Layer 2 graphics on the screen.\r\n\r\nLayer 2 Y-offset (0 after a reset)\r\n\r\n**Valid Range**\r\n\r\n\t0-191\t'in 256x192 mode\r\n\t0-255\t'0-255 in 320x256 and 640x256 modes\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LORES_CONTROL_NR_6A": {
    "content": "# LORES_CONTROL_NR_6A\r\n\r\n## Syntax\r\n\r\n```\r\nLORES_CONTROL_NR_6A = $6A\r\n```\r\n\r\n## Description\r\n\r\n**LORES CONTROL REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/LoRes_Control_Register\r\n\r\nLoRes Radastan mode\r\n\r\n**Bit**\r\n\r\n\t7-6  ' Reserved, must be 0\r\n\t5\t ' 1 = LoRes is Radastan mode (128x96x4, 6144 bytes) (soft reset = 0)\r\n\t4\t ' 1 = LoRes Radastan Timex display file xor (soft reset = 0)\r\n\t3-0  ' LoRes Radastan palette offset (bits 1:0 apply in ULA+ mode) (soft reset = 0)\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LORES_XOFFSET_NR_32": {
    "content": "# LORES_XOFFSET_NR_32\r\n\r\n## Syntax\r\n\r\n```\r\nLORES_XOFFSET_NR_32 = $32\r\n```\r\n\r\n## Description\r\n\r\n**LORES X OFFSET REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/LoRes_X_Offset_Register\r\n\r\nbits 7-0 = X Offset (0-255) (Reset to 0 after a reset)\r\n\r\nLoRes scrolls in \"half-pixels\" at the same resolution and smoothness as Layer 2.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LORES_YOFFSET_NR_33": {
    "content": "# LORES_YOFFSET_NR_33\r\n\r\n## Syntax\r\n\r\n```\r\nLORES_YOFFSET_NR_33 = $33\r\n```\r\n\r\n## Description\r\n\r\n**LORES Y OFFSET REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/LoRes_Y_Offset_Register\r\n\r\nPixel Y offset (0..191) to use when drawing LoRes Layer.\r\n\r\nbits 7-0 = Y Offset (0-191) (Reset to 0 after a reset)\r\n\r\nLoRes scrolls in \"half-pixels\" at the same resolution and smoothness as Layer 2 (0-191).\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LOW_ADRESS_KEYMAP_NR_29": {
    "content": "# LOW_ADRESS_KEYMAP_NR_29\r\n\r\n## Syntax\r\n\r\n```\r\nLOW_ADRESS_KEYMAP_NR_29 = $29\r\n```\r\n\r\n## Description\r\n\r\n**KEYMAP LOW ADDRESS REGISTER**\r\n\r\nM More info : https://wiki.specnext.dev/Keymap_Low_Address_Register\r\n\r\nPS/2 Keymap address LSB.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LOW_DATA_TO_KEYMAP_NR_2B": {
    "content": "# LOW_DATA_TO_KEYMAP_NR_2B\r\n\r\n## Syntax\r\n\r\n```\r\nLOW_DATA_TO_KEYMAP_NR_2B = $2B\r\n```\r\n\r\n## Description\r\n\r\n**KEYMAP LOW DATA REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/Keymap_Low_Data_Register\r\n\r\nLow eight LSBs of PS/2 Keymap data.\r\n\r\nBy writing to this register the keymap address is auto-incremented.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MACHINE_ID_NR_00": {
    "content": "# MACHINE_ID_NR_00\r\n\r\n## Syntax\r\n\r\n```\r\nMACHINE_ID_NR_00 = $00\r\n```\r\n\r\n## Description\r\n\r\n**MACHINE ID REGISTER**\r\n\r\nIdentifies TBBlue board type. Should always be 10 on Next.\r\n\r\nMore info : https://wiki.specnext.dev/Machine_ID_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MACHINE_TYPE_NR_03": {
    "content": "# MACHINE_TYPE_NR_03\r\n\r\n## Syntax\r\n\r\n```\r\nMACHINE_TYPE_NR_03 = $03\r\n```\r\n\r\n## Description\r\n\r\n**MACHINE TYPE REGISTER** More info : https://wiki.specnext.dev/Machine_Type_Register\r\n\r\nIdentifies timing and machine type.\r\n\r\nA write to this register disables the bootrom in config mode\r\n\r\nA write with bit 7 set will be accepted in any mode to change only display timing (bits 6-4).\r\n\r\n**Bits**\r\n\r\n\t7\t'(W) 1 to allow changes to bits 6:4\r\n\t7\t'(R) Next write to Enhanced ULA Palette Extension ($44) will affect colour byte: 0 = RRRGGGBB, 1 = p000000B\r\n\t6-4  'Display timing affects I/O port decoding (since core 3.1.1)):\r\n\t\t%000: 'internal usage\r\n\t\t%001: 'ZX 48k\r\n\t\t%010: 'ZX 128k/+2 Grey\r\n\t\t%011: 'ZX +2A/B/+3e/Next Native\r\n\t\t%100: 'Pentagon\r\n\t3\t'1 to toggle user lock on display timing (hard reset = 0) (since core 3.1.0)\r\n\t2-0\t'Machine type (determines roms loaded and multiface type (since core 3.1.1)):\r\n\t\t%000: 'Config mode\r\n\t\t%001: 'ZX 48k\r\n\t\t%010: 'ZX 128k/+2 (Grey)\r\n\t\t%011: 'ZX +2A-B/+3e/Next Native\r\n\t\t%100: Pentagon.\r\n\t\t'Writable only in config mode.\r\n\r\nCore 3.1.1 change: port-decoding now depends on the selected display-mode, not machine-type. So while machine is still in Next type, by changing to 128 display the port decoding does change too (for example $7FFD port is decoded differently on ZX128 vs ZX128+3 machines).\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MMU0_0000_NR_50": {
    "content": "# MMU0_0000_NR_50\r\n\r\n## Syntax\r\n\r\n```\r\nNextReg(MMU0_0000_NR_50,n ) \r\n```\r\n\r\n## Description\r\n\r\n**MEMORY MANAGEMENT SLOT 0 BANK** (R/W)\r\n\r\nn = memory bank 0-224 on a fully expanded Next\r\n\r\nSelects the 8k-bank stored in 8k-slot 0 [see Memory map](https://wiki.specnext.dev/Memory_map).\r\n```\r\nSlot 0 : $0000-$1FFF\r\n```\r\nRequires: \r\n```\r\n#INCLUDE <nextlib.bas>\r\n```",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MMU1_2000_NR_51": {
    "content": "# MMU1_2000_NR_51\r\n\r\n## Syntax\r\n\r\n```\r\nMMU1_2000_NR_51 = $51\r\n```\r\n\r\n## Description\r\n\r\n**MEMORY MANAGEMENT SLOT 1 BANK** (R/W)\r\n\r\nSelects the 8k-bank stored in 8k-slot 1 [see Memory map](https://wiki.specnext.dev/Memory_map).\r\n\r\n\tSlot 1 : $2000-$3FFF\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MMU2_4000_NR_52": {
    "content": "# MMU2_4000_NR_52\r\n\r\n## Syntax\r\n\r\n```\r\nMMU2_4000_NR_52 = $52\r\n```\r\n\r\n## Description\r\n\r\n**MEMORY MANAGEMENT SLOT 2 BANK** (R/W)\r\n\r\nSelects the 8k-bank stored in 8k-slot 2 [see Memory map](https://wiki.specnext.dev/Memory_map).\r\n\r\n\tSlot 2 : $4000-$5FFF\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MMU3_6000_NR_53": {
    "content": "# MMU3_6000_NR_53\r\n\r\n## Syntax\r\n\r\n```\r\nMMU3_6000_NR_53 = $53\r\n```\r\n\r\n## Description\r\n\r\n**MEMORY MANAGEMENT SLOT 3 BANK** (R/W)\r\n\r\nSelects the 8k-bank stored in 8k-slot 3 [see Memory map](https://wiki.specnext.dev/Memory_map).\r\n\r\n\tSlot 3 : $6000-$7FFF\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MMU4_8000_NR_54": {
    "content": "# MMU4_8000_NR_54\r\n\r\n## Syntax\r\n\r\n```\r\nMMU4_8000_NR_54 = $54\r\n```\r\n\r\n## Description\r\n\r\n**MEMORY MANAGEMENT SLOT 4 BANK** (R/W)\r\n\r\nSelects the 8k-bank stored in 8k-slot 4 [see Memory map](https://wiki.specnext.dev/Memory_map).\r\n\r\n\tSlot 4 : $8000-$9FFF\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MMU5_A000_NR_55": {
    "content": "# MMU5_A000_NR_55\r\n\r\n## Syntax\r\n\r\n```\r\nMMU5_A000_NR_55 = $55\r\n```\r\n\r\n## Description\r\n\r\n**MEMORY MANAGEMENT SLOT 5 BANK** (R/W)\r\n\r\nSelects the 8k-bank stored in 8k-slot 5 [see Memory map](https://wiki.specnext.dev/Memory_map).\r\n\r\n\tSlot 5 : $A000-$BFFF\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MMU6_C000_NR_56": {
    "content": "# MMU6_C000_NR_56\r\n\r\n## Syntax\r\n\r\n```\r\nMMU6_C000_NR_56 = $56\r\n```\r\n\r\n## Description\r\n\r\n**MEMORY MANAGEMENT SLOT 6 BANK** (R/W)\r\n\r\nSelects the 8k-bank stored in 8k-slot 6 [see Memory map](https://wiki.specnext.dev/Memory_map).\r\n\r\n\tSlot 6 : $C000-$DFFF\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MMU7_E000_NR_57": {
    "content": "# MMU7_E000_NR_57\r\n\r\n## Syntax\r\n\r\n```\r\nMMU7_E000_NR_57 = $57\r\n```\r\n\r\n## Description\r\n\r\n**MEMORY MANAGEMENT SLOT 7 BANK** (R/W)\r\n\r\nSelects the 8k-bank stored in 8k-slot 7 [see Memory map](https://wiki.specnext.dev/Memory_map).\r\n\r\n\tSlot 7 : $E000-$FFFF\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "NEXT_RESET_NR_02": {
    "content": "# NEXT_RESET_NR_02\r\n\r\n## Syntax\r\n\r\n```\r\nNEXT_RESET_NR_02 = $02\r\n```\r\n\r\n## Description\r\n\r\n**NEXT RESET REGISTER** More info : https://wiki.specnext.dev/Next_Reset_Register\r\n\r\nIdentifies type of last reset. Can be written to force reset.\r\n\r\n**Read**\r\n\r\n\t'bit 7 = Indicates the reset signal to the expansion bus and esp is asserted\r\n\t'bits 6:2 = Reserved\r\n\t'bit 1 = Indicates the last reset was a hard reset\r\n\t'bit 0 = Indicates the last reset was a soft reset\r\n\t* Only one of bits 1:0 will be set\r\n\r\n**Write**\r\n\r\n\t'bit 7 = Assert and hold reset to the expansion bus and the esp wifi (hard reset = 0)\r\n\t'bits 6:2 = Reserved, must be 0\r\n\t'bit 1 = Generate a hard reset (reboot)\r\n\t'bit 0 = Generate a soft reset\r\n\t* Hard reset has precedence   \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "NEXT_VERSION_MINOR_NR_0E": {
    "content": "# NEXT_VERSION_MINOR_NR_0E\r\n\r\n## Syntax\r\n\r\n```\r\nNEXT_VERSION_MINOR_NR_0E = $0E\r\n```\r\n\r\n## Description\r\n\r\nNEXT_VERSION_MINOR_NR_0E = $0E\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "NEXT_VERSION_NR_01": {
    "content": "# NEXT_VERSION_NR_01\r\n\r\n## Syntax\r\n\r\n```\r\nNEXT_VERSION_NR_01 = $01\r\n```\r\n\r\n## Description\r\n\r\n**CORE VERSION REGISTER** https://wiki.specnext.dev/Core_Version_Register\r\n\r\nIdentifies core (FPGA image) version.\r\n\r\nMost significant nibble holds major version number; least significant nibble holds minor version number.\r\n\r\nSee Core Version Register/**NEXT_VERSION_MINOR_NR_0E** (sub minor) ($0E) for sub-minor version number.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PALETTE_CONTROL_NR_43": {
    "content": "# PALETTE_CONTROL_NR_43\r\n\r\n## Syntax\r\n\r\n```\r\nPALETTE_CONTROL_NR_43 = $43\r\n```\r\n\r\n## Description\r\n\r\n**ENHANCED ULA CONTROL REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Enhanced_ULA_Control_Register\r\n\r\nEnables or disables Enhanced ULA interpretation of attribute values and toggles active palette.\r\n\r\n**Bit**\r\n\r\n\t7\t '1 to disable palette index write auto-increment\r\n\t6-4  'Select palette for reading or writing\r\n\t3\t 'Select Sprites palette (0 = first palette, 1 = second palette)\r\n\t2\t 'Select Layer 2 palette (0 = first palette, 1 = second palette)\r\n\t1\t 'Select ULA palette (0 = first palette, 1 = second palette)\r\n\t0\t 'Enable ULANext mode if 1. (0 after a reset)\r\n\r\nn.b. Bits 6-4 select palette for reading or writing whereas bits 3-1 select the palette for the display signal generator.\r\n\r\nPossible bits 6-4 for palette select (bit 6 selects first/second, 5-4 select type):\r\n\r\n**Bits 6-4**\r\n```\r\n    %0xxx0000\r\n\t%000\tULA first palette\r\n\t%100\tULA second palette\r\n\t%001\tLayer2 first palette\r\n\t%101\tLayer2 second palette\r\n\t%010\tSprites first palette\r\n\t%110\tSprites second palette\r\n\t%011\tTilemap first palette\r\n\t%111\tTilemap second palette\r\n```\r\n\r\nWrite will also reset the index of Enhanced ULA Palette Extension ($44), so the next write there will be considered as first byte of colour.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PALETTE_FORMAT_NR_42": {
    "content": "# PALETTE_FORMAT_NR_42\r\n\r\n## Syntax\r\n\r\n```\r\nPALETTE_FORMAT_NR_42 = $42\r\n```\r\n\r\n## Description\r\n\r\n**ENHANCED ULA INK COLOR MASK** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Enhanced_ULA_Ink_Color_Mask\r\n\r\nSpecifies mask to extract ink colour from attribute cell value in ULANext mode.\r\n\r\nBits 7-0 = Number of the last ink colour entry in palette (core 2.0: 15 after a Reset | core 3.0: 7 after a Reset).\r\n\r\nThis number can be 1, 3, 7, 15, 31, 63, 127 or 255.\r\n\r\nThis value is used only when ULANext mode is enabled.\r\n\r\nThe 255 value enables the full ink colour mode and all the palette entries are inks. The paper and border colour is then taken from Transparency colour fallback Register ($4A).\r\n\r\nIf the ink mask is not 255, then the zeroed part of mask signals which bits will be used to extract index of paper colour. Then this index is added to 128 and read from current palette (border index is also 128 + 0..7 value from port $FE). There are no \"flash\" or \"bright\" bits when ULANext mode is enabled, all eight attribute bits contribute either to ink or paper colour index.\r\n\r\nApplies only to Enhanced ULA palette. Layer 2, Sprite and Tilemap palettes work as \"full ink\" or specifically to 4-bit graphics data.\r\n\r\nWhen set to \"invalid\" value, the ink value is masked by the value and background colour is taken from transparency fallback (as in \"full ink\" mode).\r\n\r\n\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PALETTE_INDEX_NR_40": {
    "content": "# PALETTE_INDEX_NR_40\r\n\r\n## Syntax\r\n\r\n```\r\nPALETTE_INDEX_NR_40 = $40\r\n```\r\n\r\n## Description\r\n\r\n**PALETTE INDEX REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Palette_Index_Register\r\n\r\nChooses an palette element (index) to manipulate with\r\n\r\nThis associates selected element (0-255) of currently selected (Register $43) palette to be accessible through the Palette Value Register ($41) and Enhanced ULA Palette Extension ($44). Write will also reset the index of Enhanced ULA Palette Extension ($44), so the next write there will be considered as first byte of colour.\r\n\r\nFor the [classic] ULA only:\r\n- INKs are mapped to indices 0-7\r\n- Bright INKS are mapped to indices 8-15\r\n- PAPERs are mapped to indices 16-23\r\n- Bright PAPERs are mapped to indices 24-31\r\n\r\nIn ULANext mode, enabled via Enhanced ULA Control Register ($43):\r\n\r\n- INKs come from a subset of indices 0-127 (except full-ink colour mode, when all 0-255 indices are INK colour)\r\n- PAPERs come from a subset of indices 128-255 (in full-ink colour mode the PAPER and BORDER colour is taken from Transparency colour fallback Register ($4A))\r\n- The number of active indices depends on the number of attribute bits assigned to INK and PAPER out of the attribute byte by Enhanced ULA Ink Color Mask ($42).\r\n\r\nIn ULA+ mode, the top 64 entries hold the ULA+ palette.\r\n\r\nThe ULA always takes border colour from paper colours.\r\n\r\nLayer 2, Sprite and LoRes palettes work as \"full ink\" always, INK/PAPER concept does apply only to classic/enhanced ULA palette.\r\n\r\nThe Tilemap palette contains 256 colours, but number of colour selected by particular pixel of tile consists of top 4 bits from tile attribute and bottom 4 bits from the tile pixel, i.e. the Tilemap palette works like 16x16 sub-palettes, with each tile being defined with 0-15 indices only (and one index of them is transparent). Then the attribute of the tile fills up the top four bits, selecting 0-15 \"sub-palette\".\r\n\r\n4-bit sprites test for transparency only against low 4 bits of Sprite transparency register, and further the pixels are processed similarly to 8-bit sprites, as if the top 4 bits in pattern data were all zeroes. I.e. to the pixel value the palette offset from sprite attributes is added, and final index is used to fetch colour from Sprite palette. Transparency index is compared before the palette offset is applied.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PALETTE_VALUE_9BIT_NR_44": {
    "content": "# PALETTE_VALUE_9BIT_NR_44\r\n\r\n## Syntax\r\n\r\n```\r\nPALETTE_VALUE_9BIT_NR_44 = $44\r\n```\r\n\r\n## Description\r\n\r\n**ENHANCED ULA PALETTE EXTENSION** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Enhanced_ULA_Palette_Extension\r\n\r\nUse to set 9-bit (2-byte) colours of the Enhanced ULA palette, or to read second byte of colour.\r\n\r\nTwo consecutive writes are needed to write the 9 bit colour:\r\n- 1st write: bits 7-0 = RRRGGGBB\r\n- 2nd write: bits 7-1 are reserved, must be 0 (except bit 7 for Layer 2), bit 0 = lsb B\r\n\r\n```\r\n\tNextReg $43, %00010000\t\t\t; \t%001 Layer2 first palette\r\n\tNextReg $40, 0 \t\t\t\t\t; \treset palette index \r\n\tNextReg $44, $ff \t\t\t\t; \t9bit white \r\n\tNextReg\t$44, 01 \r\n```\r\n\r\n(to detect whether first or second write is expected, one can read bit 7 of Machine Type Register ($03), in case your code is not aware of current state)\r\n\r\nIf writing the Layer 2 palette colour, in the second byte, bit 7 is \"priority\" bit. Priority colour will be always on top (drawn above all other layers), even on a priority arrangement like \"USL\" . If you need the exact same colour with priority and non priority, you will need to program the same colour twice, changing bit 7 to 0 for the non priority colour alternative.\r\n\r\nAfter the write of second byte, the palette index is auto-incremented, if the auto-increment is enabled by Enhanced ULA Control Register ($43).\r\n\r\nThe read will always read the second byte of colour (%p000000B) and it will not modify the index.\r\n\r\nThe modified palette remains until a Hard Reset.   \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PALETTE_VALUE_NR_41": {
    "content": "# PALETTE_VALUE_NR_41\r\n\r\n## Syntax\r\n\r\n```\r\nPALETTE_VALUE_NR_41 = $41\r\n```\r\n\r\n## Description\r\n\r\n**PALETTE VALUE REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Palette_Value_Register\r\n\r\nUse to set/read 8-bit colours of the ULANext palette.\r\n\r\nBits 7-0 = Eight bit colour for the palette index selected by the Palette Index Register ($40).\r\n\r\nFormat is **RRRGGGBB** - Note the lowest blue bit of colour (*ninth bit*) will be set to an *OR* between bit 1 and bit 0.\r\n\r\nAfter the write, the palette index is auto-incremented to the next index, if the auto-increment is enabled at *Enhanced ULA Control Register* ($43). And also the index of *Enhanced ULA Palette Extension* ($44) is reset, so the next write there will be considered as first byte of colour.\r\n\r\nRead does not auto-increment the index, and reads always the top 8 bits of colour from palette, to read the 9th bit of colour, use *Enhanced ULA Palette Extension* ($44) in tandem with value from this register.\r\n\r\nThe modified palette remains until a Hard Reset.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PERIPHERAL_1_NR_05": {
    "content": "# PERIPHERAL_1_NR_05\r\n\r\n## Syntax\r\n\r\n```\r\nPERIPHERAL_1_NR_05 = $05\r\n```\r\n\r\n## Description\r\n\r\n**PERIPHERAL 1 REGISTER** More info : https://wiki.specnext.dev/Peripheral_1_Register\r\n\r\nSets joystick mode, video frequency and Scandoubler.\r\n\r\n**Bit**\t\t**Function**\r\n\r\n\t7-6\t'Joystick 1 mode (LSB)\r\n\t5-4\t'Joystick 2 mode (LSB)\r\n\t3\t'Joystick 1\r\n\t2\t'50/60 Hz mode (0 = 50Hz, 1 = 60Hz) (0 after a PoR or Hard-reset)\r\n\t1\t'Joystick 2 mode (MSB)\r\n\t0\t'Enable Scandoubler (1 = enabled) (1 after a PoR or Hard-reset) mode (MSB)  \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PERIPHERAL_2_NR_06": {
    "content": "# PERIPHERAL_2_NR_06\r\n\r\n## Syntax\r\n\r\n```\r\nPERIPHERAL_2_NR_06 = $06\r\n```\r\n\r\n## Description\r\n\r\n**PERIPHERAL 2 REGISTER** More info : https://wiki.specnext.dev/Peripheral_2_Register\r\n\r\nEnables CPU Speed key, DivMMC, Multiface, Mouse and AY audio.\r\n\r\n**Bit**\r\n\r\n\t7\t'Enable CPU speed mode key \"F8\", 0 = disabled (1 after Soft-reset)\r\n\t6\t'core3.1.2: Divert BEEP-only to internal speaker (hard reset = 0)\r\n\t5\t'Enable \"F3\" key (50/60 Hz switch) (1 after Soft-reset)\r\n\t4\t'Enable DivMMC automap and DivMMC NMI by DRIVE button (0 after Hard-reset)\r\n\t3\t'Enable multiface NMI by M1 button (hard reset = 0)\r\n\t2\t'PS/2 mode (primary device: 0 = keyboard, 1 = mouse), exchanges the keyboard/mouse pins on the PS/2 connector (writeable only in config mode)\r\n\t1\t'Audio chip mode (%00 = YM, %01 = AY, %1x = Disabled)\r\n\t0\t'(core 3.0) %11 hold all AY in reset\r\n\r\nThe bit 7 doesn't prevent SW from setting up different CPU speed by writing into CPU Speed Register ($07), it is used only to enable/disable the \"F8\" key toggle, similarly bit 5 enables \"F3\" key.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PERIPHERAL_3_NR_08": {
    "content": "# PERIPHERAL_3_NR_08\r\n\r\n## Syntax\r\n\r\n```\r\nPERIPHERAL_3_NR_08 = $08\r\n```\r\n\r\n## Description\r\n\r\nPERIPHERAL_3_NR_08 = $08\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PERIPHERAL_4_NR_09": {
    "content": "# PERIPHERAL_4_NR_09\r\n\r\n## Syntax\r\n\r\n```\r\nPERIPHERAL_4_NR_09 = $09\r\n```\r\n\r\n## Description\r\n\r\nPERIPHERAL_4_NR_09 = $09\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PERIPHERAL_5_NR_0A": {
    "content": "# PERIPHERAL_5_NR_0A\r\n\r\n## Syntax\r\n\r\n```\r\nPERIPHERAL_5_NR_0A = $0A\r\n```\r\n\r\n## Description\r\n\r\nPERIPHERAL_5_NR_0A = $0A\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PI_GPIO_0_NR_98": {
    "content": "# PI_GPIO_0_NR_98\r\n\r\n## Syntax\r\n\r\n```\r\nPI_GPIO_0_NR_98 = $98\r\n```\r\n\r\n## Description\r\n\r\nPI_GPIO_0_NR_98 = $98\r\n\r\nMore info : https://wiki.specnext.dev/Pi_GPIO_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PI_GPIO_1_NR_99": {
    "content": "# PI_GPIO_1_NR_99\r\n\r\n## Syntax\r\n\r\n```\r\nPI_GPIO_1_NR_99 = $99\r\n```\r\n\r\n## Description\r\n\r\nPI_GPIO_1_NR_99 = $99\r\n\r\nMore info : https://wiki.specnext.dev/Pi_GPIO_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PI_GPIO_2_NR_9A": {
    "content": "# PI_GPIO_2_NR_9A\r\n\r\n## Syntax\r\n\r\n```\r\nPI_GPIO_2_NR_9A = $9A\r\n```\r\n\r\n## Description\r\n\r\nPI_GPIO_2_NR_9A = $9A\r\n\r\nMore info : https://wiki.specnext.dev/Pi_GPIO_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PI_GPIO_3_NR_9B": {
    "content": "# PI_GPIO_3_NR_9B\r\n\r\n## Syntax\r\n\r\n```\r\nPI_GPIO_3_NR_9B = $9B\r\n```\r\n\r\n## Description\r\n\r\nPI_GPIO_3_NR_9B = $9B\r\n\r\nMore info : https://wiki.specnext.dev/Pi_GPIO_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PI_GPIO_OUT_ENABLE_0_NR_90": {
    "content": "# PI_GPIO_OUT_ENABLE_0_NR_90\r\n\r\n## Syntax\r\n\r\n```\r\nPI_GPIO_OUT_ENABLE_0_NR_90 = $90\r\n```\r\n\r\n## Description\r\n\r\n**PI GPIO OUTPUT ENABLE REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Pi_GPIO_Output_Enable_Register\r\n\r\n-  Bits 27-0: Set bits enable GPIO output on the corresponding GPIO pin (soft reset = all 0)\r\n\r\nGPIO pins 1:0 cannot be enabled.\r\n\r\nThe register $93 is MSB (most significant byte = bits 31-24), register $90 is LSB (least significant byte = bits 7-0).\r\n\r\nBits 31-28 are not explicitly specified in the docs, so consider them \"Reserved, preserve current value\".\r\n\r\n(note: Next registers with number higher than $7F are inaccessible from Copper code) \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PI_GPIO_OUT_ENABLE_1_NR_91": {
    "content": "# PI_GPIO_OUT_ENABLE_1_NR_91\r\n\r\n## Syntax\r\n\r\n```\r\nPI_GPIO_OUT_ENABLE_1_NR_91 = $91\r\n```\r\n\r\n## Description\r\n\r\nPI_GPIO_OUT_ENABLE_1_NR_91 = $91\r\n\r\nMore info : https://wiki.specnext.dev/Pi_GPIO_Output_Enable_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PI_GPIO_OUT_ENABLE_2_NR_92": {
    "content": "# PI_GPIO_OUT_ENABLE_2_NR_92\r\n\r\n## Syntax\r\n\r\n```\r\nPI_GPIO_OUT_ENABLE_2_NR_92 = $92\r\n```\r\n\r\n## Description\r\n\r\nPI_GPIO_OUT_ENABLE_2_NR_92 = $92\r\n\r\nMore info : https://wiki.specnext.dev/Pi_GPIO_Output_Enable_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PI_GPIO_OUT_ENABLE_3_NR_93": {
    "content": "# PI_GPIO_OUT_ENABLE_3_NR_93\r\n\r\n## Syntax\r\n\r\n```\r\nPI_GPIO_OUT_ENABLE_3_NR_93 = $93\r\n```\r\n\r\n## Description\r\n\r\nPI_GPIO_OUT_ENABLE_3_NR_93 = $93\r\n\r\nMore info : https://wiki.specnext.dev/Pi_GPIO_Output_Enable_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PI_I2S_AUDIO_CONTROL_NR_A2": {
    "content": "# PI_I2S_AUDIO_CONTROL_NR_A2\r\n\r\n## Syntax\r\n\r\n```\r\nPI_I2S_AUDIO_CONTROL_NR_A2 = $A2\r\n```\r\n\r\n## Description\r\n\r\nPI_I2S_AUDIO_CONTROL_NR_A2 = $A2\r\n\r\nMore info : https://wiki.specnext.dev/Pi_I2S_Clock_Divide_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PI_PERIPHERALS_ENABLE_NR_A0": {
    "content": "# PI_PERIPHERALS_ENABLE_NR_A0\r\n\r\n## Syntax\r\n\r\n```\r\nPI_PERIPHERALS_ENABLE_NR_A0 = $A0\r\n```\r\n\r\n## Description\r\n\r\n**PI PERIPHERAL ENABLE REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Pi_Peripheral_Enable_Register\r\n\r\nEnable Pi peripherals: UART, Pi hats, I2C, SPI\r\n\r\n**Bit**\r\n\r\n\t7-6  'Reserved, must be 0\r\n\t5\t'Enable UART on GPIO 14,15 (overrides GPIO) (soft reset = 0)\r\n\t4\t%0 'to connect Rx to GPIO 15, Tx to GPIO 14 (for comm with Pi hats) (soft reset = 0)\r\n\t\t%1 '1 to connect Rx to GPIO 14, Tx to GPIO 15 (for comm with Pi)\r\n\t3\tEnable I2C on GPIO 2,3 (overrides GPIO) (soft reset = 0)\r\n\t2-1  'Reserved, must be 0\r\n\t0\tEnable SPI on GPIO 7,8,9,10,11 (overrides GPIO) (soft reset = 0)\r\n\r\n*(note: Next registers with number higher than $7F are inaccessible from Copper code)* \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "REGISTERNAME": {
    "content": "[ALTERNATE_ROM_NR_8C](ALTERNATE_ROM_NR_8C.md)\n[ANTI_BRICK_NR_10](ANTI_BRICK_NR_10.md)\n[CLIP_LAYER2_NR_18](CLIP_LAYER2_NR_18.md)\n[CLIP_SPRITE_NR_19](CLIP_SPRITE_NR_19.md)\n[CLIP_TILEMAP_NR_1B](CLIP_TILEMAP_NR_1B.md)\n[CLIP_ULA_LORES_NR_1A](CLIP_ULA_LORES_NR_1A.md)\n[CLIP_WINDOW_CONTROL_NR_1C](CLIP_WINDOW_CONTROL_NR_1C.md)\n[COPPER_CONTROL_HI_NR_62](COPPER_CONTROL_HI_NR_62.md)\n[COPPER_CONTROL_LO_NR_61](COPPER_CONTROL_LO_NR_61.md)\n[COPPER_DATA_16B_NR_63](COPPER_DATA_16B_NR_63.md)\n[COPPER_DATA_NR_60](COPPER_DATA_NR_60.md)\n[DAC_AD_MIRROR_NR_2D](DAC_AD_MIRROR_NR_2D.md)\n[DAC_B_MIRROR_NR_2C](DAC_B_MIRROR_NR_2C.md)\n[DAC_COVOX_INDEX](DAC_COVOX_INDEX.md)\n[DAC_C_MIRROR_NR_2E](DAC_C_MIRROR_NR_2E.md)\n[DAC_GS_COVOX_INDEX](DAC_GS_COVOX_INDEX.md)\n[DAC_PENTAGON_ATM_INDEX](DAC_PENTAGON_ATM_INDEX.md)\n[DAC_PROFI_COVOX_INDEX](DAC_PROFI_COVOX_INDEX.md)\n[DAC_SOUNDRIVE1_INDEX](DAC_SOUNDRIVE1_INDEX.md)\n[DAC_SOUNDRIVE2_INDEX](DAC_SOUNDRIVE2_INDEX.md)\n[DAC_SPECDRUM_INDEX](DAC_SPECDRUM_INDEX.md)\n[DEBUG_LED_CONTROL_NR_FF](DEBUG_LED_CONTROL_NR_FF.md)\n[DISPLAY_CONTROL_NR_69](DISPLAY_CONTROL_NR_69.md)\n[ESP_WIFI_GPIO_NR_A9](ESP_WIFI_GPIO_NR_A9.md)\n[ESP_WIFI_GPIO_OUTPUT_NR_A8](ESP_WIFI_GPIO_OUTPUT_NR_A8.md)\n[EXPANSION_BUS_CONTROL_NR_81](EXPANSION_BUS_CONTROL_NR_81.md)\n[EXPANSION_BUS_DECODING_0_NR_86](EXPANSION_BUS_DECODING_0_NR_86.md)\n[EXPANSION_BUS_DECODING_1_NR_87](EXPANSION_BUS_DECODING_1_NR_87.md)\n[EXPANSION_BUS_DECODING_2_NR_88](EXPANSION_BUS_DECODING_2_NR_88.md)\n[EXPANSION_BUS_DECODING_3_NR_89](EXPANSION_BUS_DECODING_3_NR_89.md)\n[EXPANSION_BUS_ENABLE_NR_80](EXPANSION_BUS_ENABLE_NR_80.md)\n[EXPANSION_BUS_PROPAGATE_NR_8A](EXPANSION_BUS_PROPAGATE_NR_8A.md)\n[EXTENDED_KEYS_0_NR_B0](EXTENDED_KEYS_0_NR_B0.md)\n[EXTENDED_KEYS_1_NR_B1](EXTENDED_KEYS_1_NR_B1.md)\n[GLOBAL_TRANSPARENCY_NR_14](GLOBAL_TRANSPARENCY_NR_14.md)\n[HIGH_ADRESS_KEYMAP_NR_28](HIGH_ADRESS_KEYMAP_NR_28.md)\n[HIGH_DATA_TO_KEYMAP_NR_2A](HIGH_DATA_TO_KEYMAP_NR_2A.md)\n[INTERNAL_PORT_DECODING_0_NR_82](INTERNAL_PORT_DECODING_0_NR_82.md)\n[INTERNAL_PORT_DECODING_1_NR_83](INTERNAL_PORT_DECODING_1_NR_83.md)\n[INTERNAL_PORT_DECODING_2_NR_84](INTERNAL_PORT_DECODING_2_NR_84.md)\n[INTERNAL_PORT_DECODING_3_NR_85](INTERNAL_PORT_DECODING_3_NR_85.md)\n[LAYER2_CONTROL_NR_70](LAYER2_CONTROL_NR_70.md)\n[LAYER2_RAM_BANK_NR_12](LAYER2_RAM_BANK_NR_12.md)\n[LAYER2_RAM_SHADOW_BANK_NR_13](LAYER2_RAM_SHADOW_BANK_NR_13.md)\n[LAYER2_XOFFSET_MSB_NR_71](LAYER2_XOFFSET_MSB_NR_71.md)\n[LAYER2_XOFFSET_NR_16](LAYER2_XOFFSET_NR_16.md)\n[LAYER2_YOFFSET_NR_17](LAYER2_YOFFSET_NR_17.md)\n[LORES_CONTROL_NR_6A](LORES_CONTROL_NR_6A.md)\n[LORES_XOFFSET_NR_32](LORES_XOFFSET_NR_32.md)\n[LORES_YOFFSET_NR_33](LORES_YOFFSET_NR_33.md)\n[LOW_ADRESS_KEYMAP_NR_29](LOW_ADRESS_KEYMAP_NR_29.md)\n[LOW_DATA_TO_KEYMAP_NR_2B](LOW_DATA_TO_KEYMAP_NR_2B.md)\n[MACHINE_ID_NR_00](MACHINE_ID_NR_00.md)\n[MACHINE_TYPE_NR_03](MACHINE_TYPE_NR_03.md)\n[MMU0_0000_NR_50](MMU0_0000_NR_50.md)\n[MMU1_2000_NR_51](MMU1_2000_NR_51.md)\n[MMU2_4000_NR_52](MMU2_4000_NR_52.md)\n[MMU3_6000_NR_53](MMU3_6000_NR_53.md)\n[MMU4_8000_NR_54](MMU4_8000_NR_54.md)\n[MMU5_A000_NR_55](MMU5_A000_NR_55.md)\n[MMU6_C000_NR_56](MMU6_C000_NR_56.md)\n[MMU7_E000_NR_57](MMU7_E000_NR_57.md)\n[NEXT_RESET_NR_02](NEXT_RESET_NR_02.md)\n[NEXT_VERSION_MINOR_NR_0E](NEXT_VERSION_MINOR_NR_0E.md)\n[NEXT_VERSION_NR_01](NEXT_VERSION_NR_01.md)\n[PALETTE_CONTROL_NR_43](PALETTE_CONTROL_NR_43.md)\n[PALETTE_FORMAT_NR_42](PALETTE_FORMAT_NR_42.md)\n[PALETTE_INDEX_NR_40](PALETTE_INDEX_NR_40.md)\n[PALETTE_VALUE_9BIT_NR_44](PALETTE_VALUE_9BIT_NR_44.md)\n[PALETTE_VALUE_NR_41](PALETTE_VALUE_NR_41.md)\n[PERIPHERAL_1_NR_05](PERIPHERAL_1_NR_05.md)\n[PERIPHERAL_2_NR_06](PERIPHERAL_2_NR_06.md)\n[PERIPHERAL_3_NR_08](PERIPHERAL_3_NR_08.md)\n[PERIPHERAL_4_NR_09](PERIPHERAL_4_NR_09.md)\n[PERIPHERAL_5_NR_0A](PERIPHERAL_5_NR_0A.md)\n[PI_GPIO_0_NR_98](PI_GPIO_0_NR_98.md)\n[PI_GPIO_1_NR_99](PI_GPIO_1_NR_99.md)\n[PI_GPIO_2_NR_9A](PI_GPIO_2_NR_9A.md)\n[PI_GPIO_3_NR_9B](PI_GPIO_3_NR_9B.md)\n[PI_GPIO_OUT_ENABLE_0_NR_90](PI_GPIO_OUT_ENABLE_0_NR_90.md)\n[PI_GPIO_OUT_ENABLE_1_NR_91](PI_GPIO_OUT_ENABLE_1_NR_91.md)\n[PI_GPIO_OUT_ENABLE_2_NR_92](PI_GPIO_OUT_ENABLE_2_NR_92.md)\n[PI_GPIO_OUT_ENABLE_3_NR_93](PI_GPIO_OUT_ENABLE_3_NR_93.md)\n[PI_I2S_AUDIO_CONTROL_NR_A2](PI_I2S_AUDIO_CONTROL_NR_A2.md)\n[PI_PERIPHERALS_ENABLE_NR_A0](PI_PERIPHERALS_ENABLE_NR_A0.md)\n[ROM_MAPPING_NR_04](ROM_MAPPING_NR_04.md)\n[SOUNDDRIVE_DF_MIRROR_NR_2D](SOUNDDRIVE_DF_MIRROR_NR_2D.md)\n[SPRITE_ATTR0_INC_NR_75](SPRITE_ATTR0_INC_NR_75.md)\n[SPRITE_ATTR0_NR_35](SPRITE_ATTR0_NR_35.md)\n[SPRITE_ATTR1_INC_NR_76](SPRITE_ATTR1_INC_NR_76.md)\n[SPRITE_ATTR1_NR_36](SPRITE_ATTR1_NR_36.md)\n[SPRITE_ATTR2_INC_NR_77](SPRITE_ATTR2_INC_NR_77.md)\n[SPRITE_ATTR2_NR_37](SPRITE_ATTR2_NR_37.md)\n[SPRITE_ATTR3_INC_NR_78](SPRITE_ATTR3_INC_NR_78.md)\n[SPRITE_ATTR3_NR_38](SPRITE_ATTR3_NR_38.md)\n[SPRITE_ATTR4_INC_NR_79](SPRITE_ATTR4_INC_NR_79.md)\n[SPRITE_ATTR4_NR_39](SPRITE_ATTR4_NR_39.md)\n[SPRITE_ATTR_SLOT_SEL_NR_34](SPRITE_ATTR_SLOT_SEL_NR_34.md)\n[SPRITE_CONTROL_NR_15](SPRITE_CONTROL_NR_15.md)\n[SPRITE_TRANSPARENCY_I_NR_4B](SPRITE_TRANSPARENCY_I_NR_4B.md)\n[TILEMAP_BASE_ADR_NR_6E](TILEMAP_BASE_ADR_NR_6E.md)\n[TILEMAP_CONTROL_NR_6B](TILEMAP_CONTROL_NR_6B.md)\n[TILEMAP_DEFAULT_ATTR_NR_6C](TILEMAP_DEFAULT_ATTR_NR_6C.md)\n[TILEMAP_GFX_ADR_NR_6F](TILEMAP_GFX_ADR_NR_6F.md)\n[TILEMAP_TRANSPARENCY_I_NR_4C](TILEMAP_TRANSPARENCY_I_NR_4C.md)\n[TILEMAP_XOFFSET_LSB_NR_30](TILEMAP_XOFFSET_LSB_NR_30.md)\n[TILEMAP_XOFFSET_MSB_NR_2F](TILEMAP_XOFFSET_MSB_NR_2F.md)\n[TILEMAP_YOFFSET_NR_31](TILEMAP_YOFFSET_NR_31.md)\n[TRANSPARENCY_FALLBACK_COL_NR_4A](TRANSPARENCY_FALLBACK_COL_NR_4A.md)\n[TURBO_CONTROL_NR_07](TURBO_CONTROL_NR_07.md)\n[ULA_CONTROL_NR_68](ULA_CONTROL_NR_68.md)\n[ULA_XOFFSET_NR_26](ULA_XOFFSET_NR_26.md)\n[ULA_YOFFSET_NR_27](ULA_YOFFSET_NR_27.md)\n[USER_STORAGE_0_NR_7F](USER_STORAGE_0_NR_7F.md)\n[VIDEO_INTERUPT_CONTROL_NR_22](VIDEO_INTERUPT_CONTROL_NR_22.md)\n[VIDEO_INTERUPT_VALUE_NR_23](VIDEO_INTERUPT_VALUE_NR_23.md)\n[VIDEO_LINE_LSB_NR_1F](VIDEO_LINE_LSB_NR_1F.md)\n[VIDEO_LINE_MSB_NR_1E](VIDEO_LINE_MSB_NR_1E.md)\n[VIDEO_LINE_OFFSET_NR_64](VIDEO_LINE_OFFSET_NR_64.md)\n[VIDEO_TIMING_NR_11](VIDEO_TIMING_NR_11.md)\n[ZX_MEM_MAPPING_NR_8E](ZX_MEM_MAPPING_NR_8E.md)\n[registername](registername.md)\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ROM_MAPPING_NR_04": {
    "content": "# ROM_MAPPING_NR_04\r\n\r\n## Syntax\r\n\r\n```\r\nROM_MAPPING_NR_04 = $04\r\n```\r\n\r\n## Description\r\n\r\nROM_MAPPING_NR_04 = $04\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SOUNDDRIVE_DF_MIRROR_NR_2D": {
    "content": "# SOUNDDRIVE_DF_MIRROR_NR_2D\r\n\r\n## Syntax\r\n\r\n```\r\nSOUNDDRIVE_DF_MIRROR_NR_2D = $2D\r\n```\r\n\r\n## Description\r\n\r\nSOUNDDRIVE_DF_MIRROR_NR_2D = $2D\r\n\r\nMore info : https://wiki.specnext.dev/DAC_A%2BD_(mono)_mirror_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_ATTR0_INC_NR_75": {
    "content": "# SPRITE_ATTR0_INC_NR_75\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_ATTR0_INC_NR_75 = $75\r\n```\r\n\r\n## Description\r\n\r\n**SPRITE PORT-MIRROR ATTRIBUTE 0 (WITH INC) REGISTER** (W)\r\n\r\nMore info : https://wiki.specnext.dev/Sprite_port-mirror_Attribute_0_(with_INC)_Register\r\n\r\nSame as Sprite port-mirror Attribute 0 Register ($35) (write first byte of sprite-attributes), plus increments Sprite port-mirror Index Register ($34)\r\n\r\nEight low bits of X position. MSB of X-pos is in \"byte 3\".\r\n\r\nAfter write into sprite-attribute \"byte 1\" (Sprite Attribute Upload ($xx57 / 87)), the Sprite port-mirror Index Register ($34) is incremented (with all consequences stemming from such action). If the sprite 127 was modified, the result of the increment is officially \"undefined behaviour\", and code should explicitly set valid 0..127 sprite index before next sprite-attribute manipulation.  \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_ATTR0_NR_35": {
    "content": "# SPRITE_ATTR0_NR_35\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_ATTR0_NR_35 = $35\r\n```\r\n\r\n## Description\r\n\r\n**SPRITE PORT-MIRROR ATTRIBUTE 0 REGISTER** (W)\r\n\r\nMore info : https://wiki.specnext.dev/Sprite_port-mirror_Attribute_0_Register\r\n\r\nNextreg port-mirror to write directly into \"byte 1\" of Sprite Attribute Upload ($xx57 / 87).\r\n\r\nEight low bits of X position. MSB of X-pos is in \"byte 3\".\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_ATTR1_INC_NR_76": {
    "content": "# SPRITE_ATTR1_INC_NR_76\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_ATTR1_INC_NR_76 = $76\r\n```\r\n\r\n## Description\r\n\r\n**SPRITE PORT-MIRROR ATTRIBUTE 1 (WITH INC) REGISTER** (W)\r\n\r\nhttps://wiki.specnext.dev/Sprite_port-mirror_Attribute_1_(with_INC)_Register\r\n\r\nSame as Sprite port-mirror Attribute 1 Register ($36) (write second byte of sprite-attributes), plus increments Sprite port-mirror Index Register ($34)\r\n\r\nEight low bits of Y position. MSB of Y-pos is in \"byte 5\".\r\n\r\nAfter write into sprite-attribute \"byte 2\" (Sprite Attribute Upload ($xx57)), the Sprite port-mirror Index Register ($34) is incremented (with all consequences stemming from such action). If the sprite 127 was modified, the result of the increment is officially \"undefined behaviour\", and code should explicitly set valid 0..127 sprite index before next sprite-attribute manipulation.  \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_ATTR1_NR_36": {
    "content": "# SPRITE_ATTR1_NR_36\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_ATTR1_NR_36 = $36\r\n```\r\n\r\n## Description\r\n\r\n**SPRITE PORT-MIRROR ATTRIBUTE 1 REGISTER** (W)\r\n\r\nMore info : https://wiki.specnext.dev/Sprite_port-mirror_Attribute_1_Register\r\n\r\nNextreg port-mirror to write directly into \"byte 2\" of Sprite Attribute Upload ($xx57 / 87).\r\n\r\nEight low bits of Y position. MSB of Y-pos is in \"byte 5\". \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_ATTR2_INC_NR_77": {
    "content": "# SPRITE_ATTR2_INC_NR_77\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_ATTR2_INC_NR_77 = $77\r\n```\r\n\r\n## Description\r\n\r\n**SPRITE PORT-MIRROR ATTRIBUTE 2 (WITH INC) REGISTER** (W)\r\n\r\nMore info : hhttps://wiki.specnext.dev/Sprite_port-mirror_Attribute_2_(with_INC)_Register\r\n\r\nSame as Sprite port-mirror Attribute 2 Register ($37) (write third byte of sprite-attributes), plus increments Sprite port-mirror Index Register ($34)\r\n\r\nByte 3 is bitmapped\r\n\r\n**Bit**\r\n\r\n\t4-7  'Palette offset, added to each palette index from pattern before drawing\r\n\t3\t'Enable X mirror\r\n\t2\t'Enable Y mirror\r\n\t1\t'Enable rotation\r\n\t0\t'anchor sprite : MSB of X coordinate\r\n\t\t'relative sprite: enable relative Palette offset (1 = the anchor Palette offset is added, 0 = independent Palette offset)\r\n\r\nAfter write into sprite-attribute \"byte 3\" (Sprite Attribute Upload ($xx57 / 87)), the Sprite port-mirror Index Register ($34) is incremented (with all consequences stemming from such action). If the sprite 127 was modified, the result of the increment is officially \"undefined behaviour\", and code should explicitly set valid 0..127 sprite index before next sprite-attribute manipulation. \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_ATTR2_NR_37": {
    "content": "# SPRITE_ATTR2_NR_37\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_ATTR2_NR_37 = $37\r\n```\r\n\r\n## Description\r\n\r\n**SPRITE PORT-MIRROR ATTRIBUTE 2 REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/Sprite_port-mirror_Attribute_2_Register\r\n\r\nNextreg port-mirror to write directly into \"byte 3\" of Sprite Attribute Upload ($xx57 / 87).\r\n\r\nByte 3 is bitmapped\r\n\r\n**Bit**\r\n\r\n\t4-7  'Palette offset, added to each palette index from pattern before drawing\r\n\t3\t'Enable X mirror\r\n\t2\t'Enable Y mirror\r\n\t1\t'Enable rotation\r\n\t0\t'anchor sprite: MSB of X coordinate\r\n\t\t' relative sprite: enable relative Palette offset (1 = the anchor Palette offset is added, 0 = independent Palette offset)\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_ATTR3_INC_NR_78": {
    "content": "# SPRITE_ATTR3_INC_NR_78\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_ATTR3_INC_NR_78 = $78\r\n```\r\n\r\n## Description\r\n\r\n**SPRITE PORT-MIRROR ATTRIBUTE 3 (WITH INC) REGISTER** (W)\r\n\r\nMore info : https://wiki.specnext.dev/Sprite_port-mirror_Attribute_3_(with_INC)_Register\r\n\r\nSame as Sprite port-mirror Attribute 3 Register ($38) (write fourth byte of sprite-attributes), plus increments Sprite port-mirror Index Register ($34)\r\n\r\nByte 4 is bitmapped:\r\n\r\n**Bit**\r\n\r\n\t7\t'Enable visibility\r\n\t6\t'Enable fifth sprite attribute byte\r\n\t5-0  'Pattern index (\"Name\")\r\n\r\nWhen the bit 6 is \"0\", the sprite renderer will ignore value written in fifth attribute byte, for example by Sprite port-mirror Attribute 4 Register ($39), and it will use zero for all the features of fifth attribute byte (it is safe to initialize only four bytes if you are planning to use 4-byte type of sprites).\r\n\r\nIf you want the value in fifth attribute byte to apply during rendering, bit 6 here must be set to \"1\".\r\n\r\nAfter write into sprite-attribute \"byte 4\" (Sprite Attribute Upload ($xx57 / 87)), the Sprite port-mirror Index Register ($34) is incremented (with all consequences stemming from such action). If the sprite 127 was modified, the result of the increment is officially \"undefined behaviour\", and code should explicitly set valid 0..127 sprite index before next sprite-attribute manipulation.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_ATTR3_NR_38": {
    "content": "# SPRITE_ATTR3_NR_38\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_ATTR3_NR_38 = $38\r\n```\r\n\r\n## Description\r\n\r\n**SPRITE PORT-MIRROR ATTRIBUTE 3 REGISTER** (W)\r\n\r\nMore info : https://wiki.specnext.dev/Sprite_port-mirror_Attribute_3_Register\r\n\r\nNextreg port-mirror to write directly into \"byte 4\" of Sprite Attribute Upload($xx57 / 87).\r\n\r\nByte 3 is bitmapped:\r\n\r\n**Bits**\r\n\r\n\t7\t'Enable visibility\r\n\t6\t'Enable fifth sprite attribute\r\n\t5-0  'Pattern index (\"Name\")\r\n\r\nWhen the bit 6 is \"0\", the sprite renderer will ignore value written in fifth attribute byte, for example by Sprite port-mirror Attribute 4 Register ($39), and it will use zero for all the features of fifth attribute byte (it is safe to initialize only four bytes if you are planning to use 4-byte type of sprites).\r\n\r\nIf you want the value in fifth attribute byte to apply during rendering, bit 6 here must be set to \"1\".\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_ATTR4_INC_NR_79": {
    "content": "# SPRITE_ATTR4_INC_NR_79\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_ATTR4_INC_NR_79 = $79\r\n```\r\n\r\n## Description\r\n\r\n**SPRITE PORT-MIRROR ATTRIBUTE 4 (WITH INC) REGISTER** (W)\r\n\r\nMore info : https://wiki.specnext.dev/Sprite_port-mirror_Attribute_4_(with_INC)_Register\r\n\r\nThe same as Sprite port-mirror Attribute 4 Register ($39) (write fifth byte of sprite-attributes), plus increments Sprite port-mirror Index Register ($34)\r\n\r\nByte 5 is mitmapped.\r\n\r\n*For Anchor sprites:*\r\n\r\n**Bits**\r\n\r\n\t7-6  '\"H N6\" - \"H\" is 4/8 bit graphics selector, \"N6\" is sub-pattern selector for 4 bit modes.\r\n\t\t %00 ' 8-bit colour patterns (256 bytes), this sprite is \"anchor\"\r\n\t\t %01 ' this sprite is \"relative\" (4/8-bit colour is selected by \"anchor\" sprite) → see tables below\r\n\t\t %10 ' 4-bit colour pattern (128 bytes) using bytes 0..127 of pattern slot, this sprite is \"anchor\"\r\n\t\t %11 ' 4-bit colour pattern (128 bytes) using bytes 128..255 of pattern slot, this sprite is \"anchor\"\r\n\t5\t'Type for following relative sprites: 0 = \"composite\", 1 = \"big sprite\"\r\n\t4-3  'x-axis scale factor: %00 = 1x (16 pixels), %01 = 2x, %10 = 4x, %11 = 8x (128 pixels)\r\n\t2-1  'y-axis scale factor: %00 = 1x (16 pixels), %01 = 2x, %10 = 4x, %11 = 8x (128 pixels)\r\n\t0\t'MSB of Y coordinate\r\n\r\n*For Anchor sprites:*\r\n\r\n**Bits**\r\n\r\n\t7-6  %01 ' relative sprite\r\n\t5\t'\"N6\" bit, in 4-bit colour mode 0 = using bytes 0..127 of pattern slot, 1 = using bytes 128..255 of pattern slot. In 8-bit mode use 0.\r\n\t4-3  'x-axis scale factor: %00 = 1x (16 pixels), %01 = 2x, %10 = 4x, %11 = 8x (128 pixels)\r\n\t2-1  'y-axis scale factor: %00 = 1x (16 pixels), %01 = 2x, %10 = 4x, %11 = 8x (128 pixels)\r\n\t0\t'Enable relative pattern offset (1 = Pattern index is added to anchor pattern index, 0 = independent pattern index)\r\n\r\n*For big relative-sprites*\r\n\r\n**Bit**\r\n\r\n\t7-6  %01 'relative sprite\r\n\t5\t'\"N6\" bit, in 4-bit colour mode 0 = using bytes 0..127 of pattern slot, 1 = using bytes 128..255 of pattern slot. In 8-bit mode use 0.\r\n\t4-1  'use 0 (scaling is defined by anchor sprite)\r\n\t0\t'Enable relative pattern offset (1 = Pattern index is added to anchor pattern index, 0 = independent pattern index)\r\n\r\nSee Sprite Attribute Upload ($xx57 / 87) for extra notes about anchor/relative sprites, coordinates and clipping.\r\n\r\nAfter write into sprite-attribute \"byte 5\" [(Sprite Attribute Upload ($xx57 / 87)](https://wiki.specnext.dev/Sprite_Attribute_Upload), the Sprite port-mirror Index Register ($34) is incremented (with all consequences stemming from such action). If the sprite 127 was modified, the result of the increment is officially \"undefined behaviour\", and code should explicitly set valid 0..127 sprite index before next sprite-attribute manipulation.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_ATTR4_NR_39": {
    "content": "# SPRITE_ATTR4_NR_39\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_ATTR4_NR_39 = $39\r\n```\r\n\r\n## Description\r\n\r\n**SPRITE PORT-MIRROR ATTRIBUTE 4 REGISTER** (W)\r\n\r\nMore info : https://wiki.specnext.dev/Sprite_port-mirror_Attribute_4_Register\r\n\r\nNextreg port-mirror to write directly into \"byte 5\" of Sprite Attribute Upload ($xx57 / 87).\r\n\r\nByte 5 is mitmapped.\r\n\r\n*For Anchor sprites:*\r\n\r\n**Bits**\r\n\r\n|bit |  |Description|\r\n|----|--|------------------|  \r\n| 7-6 | | \"H N6\" - \"H\" is 4/8 bit graphics selector, \"N6\" is sub-pattern selector for 4 bit modes. | \r\n| . | | %00 ' 8-bit colour patterns (256 bytes), this sprite is \"anchor\" | \r\n| . | | %01 ' this sprite is \"relative\" (4/8-bit colour is selected by \"anchor\" sprite) → see tables below | \r\n| . | | %10 ' 4-bit colour pattern (128 bytes) using bytes 0..127 of pattern slot, this sprite is \"anchor\" | \r\n| 6 | | %11 ' 4-bit colour pattern (128 bytes) using bytes 128..255 of pattern slot, this sprite is \"anchor\" | \r\n| 5\t| | Type for following relative sprites: 0 = \"composite\", 1 = \"big sprite\" | \r\n| 4-3 | | x-axis scale factor: %00 = 1x (16 pixels), %01 = 2x, %10 = 4x, %11 = 8x (128 pixels) | \r\n| 2-1 | | y-axis scale factor: %00 = 1x (16 pixels), %01 = 2x, %10 = 4x, %11 = 8x (128 pixels) | \r\n| 0\t| | MSB of Y coordinate | \r\n---------------------------\r\n*For Anchor sprites:*\r\n\r\n**Bits**\r\n```\r\n7-6  ' %01 = relative sprite\r\n5    '\"N6\" bit, in 4-bit colour mode 0 = using bytes 0..127 of pattern slot, 1 = using bytes 128..255 of pattern slot. In 8-bit mode use 0.\r\n4-3  'x-axis scale factor: %00 = 1x (16 pixels), %01 = 2x, %10 = 4x, %11 = 8x (128 pixels)\r\n2-1  'y-axis scale factor: %00 = 1x (16 pixels), %01 = 2x, %10 = 4x, %11 = 8x (128 pixels)\r\n0    'Enable relative pattern offset (1 = Pattern index is added to anchor pattern index, 0 = independent pattern index)\r\n```\r\n*For big relative-sprites*\r\n\r\n**Bit**\r\n```\r\n7-6  ' %01 = relative sprite\r\n5    '\"N6\" bit, in 4-bit colour mode 0 = using bytes 0..127 of pattern slot, 1 = using bytes 128..255 of pattern slot. In 8-bit mode use 0.\r\n4-1  'use 0 (scaling is defined by anchor sprite)\r\n0    'Enable relative pattern offset (1 = Pattern index is added to anchor pattern index, 0 = independent pattern index)\r\n```\r\nSee Sprite Attribute Upload ($xx57 / 87) for extra notes about anchor/relative sprites, coordinates and clipping.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_ATTR_SLOT_SEL_NR_34": {
    "content": "# SPRITE_ATTR_SLOT_SEL_NR_34\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_ATTR_SLOT_SEL_NR_34 = $34\r\n```\r\n\r\n## Description\r\n\r\n**SPRITE PORT-MIRROR INDEX REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/Sprite_port-mirror_Index_Register\r\n\r\nSelects sprite index 0..127 to be affected by writes to other Sprite ports (and mirrors).\r\n\r\nIf sprite id lockstep in Peripheral 4 Register ($09) is enabled, write to this registers has same effect as writing to Sprite Status/Slot Select ($303B / 12347).\r\n\r\nI.e. bit 7 offsets pattern writes by 128 bytes (second half of 0..63 pattern slot), and bits 6-0 contain index 0..63 (for patterns) or 0..127 for sprite attributes, resetting those indices for ports Sprite Attribute Upload ($xx57 / 87) and Sprite Pattern Upload ($xx5B / 91) and for following NextRegs $35..$39 and $75..$79.\r\n\r\nIndex-increments caused by write to NextRegs $75..$79 will propagate also to current index of port $xx57 and reset current attribute (next write to port $xx57 after index change will modify first byte of attributes).\r\n\r\nThe index increment caused by sending full attribute set to port $xx57, or by writing to port $303B, will also propagate to this register, affecting next writes to registers $35..$39/$75..$79.\r\n\r\nIf sprite id lockstep in Peripheral 4 Register ($09) is disabled, bit 7 is ignored and bits 6-0 value selects index 0..127 for NextRegs $35..$39 and $75..$79 (decoupled from ports $xx57/$303B completely).\r\n\r\nThe read will in every mode return the sprite id (not pattern id) and bit 7 always reads back as zero.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_CONTROL_NR_15": {
    "content": "# SPRITE_CONTROL_NR_15\r\n\r\n## Syntax\r\n\r\n```\r\nNextReg(SPRITE_CONTROL_NR_15,n)\r\n```\r\n\r\n## Description\r\n\r\n**SPRITE AND LAYERS SYSTEM REGISTER**\r\n\r\nEnables/disables Sprites and Lores Layer, and chooses priority of sprites and Layer 2. Setting a value of [n] with the desired settings.\r\n\r\n**Bits**\r\n```\r\n7\t'Enable Lores Layer\r\n6\t'If 1, the sprite rendering priority is flipped, i.e. sprite 0 is on top of other sprites (0 after reset)\r\n5\t'If 1, the clipping works even in \"over border\" mode (doubling X-axis coordinates of clip window) (0 after reset)\r\n4-2  'Layers priority and mixing(below)\r\n1\t'Enable sprites over border (0 after reset)\r\n0\t'Enable sprite visibility (0 after reset)\r\n```\r\n**Bits 4-2**\r\n```\r\n%000\tS L U '(Sprites are at top, Layer 2 under, Enhanced_ULA at bottom)\r\n%001\tL S U\r\n%010\tS U L\r\n%011\tL U S\r\n%100\tU S L\r\n%101\tU L S\r\n%110\t(U|T)S(T|U)(B+L) 'Blending layer and Layer 2 combined, colours clamped to [0,7]\r\n%111\tsince core3.1.1: (U|T)S(T|U)(B+L-5) 'Blending layer and Layer 2 combined, colours clamped to [0,7]\r\n```\r\n\r\n## Remarks\r\n\r\nIn layer mixing modes (%110 and %111) the \"priority bit 7\" of Layer 2 colour is propagated through the calculation, i.e. such pixel will raise above sprites even in mixing modes. If either U|T or L layer contains transparent colour pixel, the other layer pixel is drawn unchanged (skipping mixing calculation) (modified in 3.1.1, precise description to be added).\r\n\r\nSince core3.1.1 the blending modes allow for layer non-contributing-to-blending (use ULA Control Register ($68) to configure blending sub-mode) to show independently in front of sprites, but modifies the transparency handling rules (to be documented soon)\r\n\r\nWhen both \"over border\" (bit 1) and \"clipping over border\" (bit 5) is enabled, the Sprite clipping window Clip Window Sprites Register ($19) X-axis coordinates are \"doubled\", and coordinates origin is moved from pixel [0,0] position to sprite [0,0] position ([-32,-32] pixel position). For example: setting clip coordinates as {x1:5, x2:155, y1:7, y2:248} will make sprites visible in area [10,7]..[311,248] (inclusively) in sprite coordinates, i.e. the first visible pixel is at X1\\*2 coordinate, and last visible pixel is at X2\\*2+1 coordinate.\r\n\r\n**SEE MORE** [https://wiki.specnext.dev/Sprite_and_Layers_System_Register](https://wiki.specnext.dev/Sprite_and_Layers_System_Register)\r\n\r\n## Requires: \r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n[Sprites](Sprites.md)",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_TRANSPARENCY_I_NR_4B": {
    "content": "# SPRITE_TRANSPARENCY_I_NR_4B\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_TRANSPARENCY_I_NR_4B = $4B\r\n```\r\n\r\n## Description\r\n\r\n**SPRITES TRANSPARENCY INDEX REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Sprites_Transparency_Index_Register\r\n\r\nIndex into sprite palette (of \"transparent\" colour).\r\n\r\nIndex into sprite palette, set to $E3 after reset.\r\n\r\nWhen rendering sprites, the pixel index is compared before palette-offset (byte 3 of Sprite Attribute Upload ($xx57 / 87)) is applied to it. The transparency is index-based, not colour based (contrary to Layer 2/ULA/LoRes modes, where resulting pixel colour is compared).\r\n\r\nThe 4-bit sprite compares pixel-index to low 4 bits of this register, i.e. 4-bit pixel $3 (%0011) is treated as transparent, if this register still contains default $E3 (%1110_0011) value.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TILEMAP_BASE_ADR_NR_6E": {
    "content": "# TILEMAP_BASE_ADR_NR_6E\r\n\r\n## Syntax\r\n\r\n```\r\nTILEMAP_BASE_ADR_NR_6E = $6E\r\n```\r\n\r\n## Description\r\n\r\n**TILEMAP BASE ADDRESS REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Tilemap_Base_Address_Register\r\n\r\nBase address of the 40x32 or 80x32 tile map (similar to text-mode of other computers).\r\n\r\n\tbits 7-6 ' Read back as zero, write values ignored\r\n\t bits 5-0 ' MSB of address of the tile map in Bank 5\r\n\r\nThe value written is an offset into Bank 5 allowing the [tilemap](https://wiki.specnext.dev/Tilemap) to be placed at any multiple of 256 bytes.\r\n\r\nWriting a physical MSB address as $40-$7F or $C0-$FF range is permitted (the top bits will be ignored).\r\n\r\nThe value read back may be treated as a full 8-bit value (with the top two bits equal to zero), i.e. upon writing value $45 the read of this register will produce value $05 (contrary to \"reserved\" bits in other registers, where read-value should be not assumed by code using it and masking by AND is recommended).Default value after soft reset corresponds to the address **$6C00**, i.e. default value is **$2C**.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TILEMAP_CONTROL_NR_6B": {
    "content": "# TILEMAP_CONTROL_NR_6B\r\n\r\n## Syntax\r\n\r\n```\r\nTILEMAP_CONTROL_NR_6B = $6B\r\n```\r\n\r\n## Description\r\n\r\n**TILEMAP CONTROL REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Tilemap_Control_Register\r\n\r\nControls [Tilemap](https://wiki.specnext.dev/Tilemap) mode.\r\n\r\n**Bit**\r\n\r\n\t7\t'1 to enable the tilemap\r\n\t6\t'0 for 40x32, 1 for 80x32\r\n\t5\t'1 to eliminate the attribute entry in the tilemap\r\n\t4\t'palette select (0 tilemap first, 1 second)\r\n\t3\t'enable \"text\" mode\r\n\t2\t'Reserved : must be 0\r\n\t1\t'1 to activate 512 tile mode (bit 0 of tile attribute is ninth bit of tile-id)\r\n\t\t '0 to use bit 0 of tile attribute as \"ULA over tilemap\" per-tile-selector\r\n\t0\t'1 to enforce \"tilemap over ULA\" layer priority\r\n\r\nBits 7 & 6 enable the tilemap and select resolution.\r\n\r\nBit 5 changes the structure of the tilemap so that it contains only 8-bit tilemap-id entries instead of 16-bit tilemap-id plus tile-attribute entries.\r\n\r\nIf 8-bit tilemap is selected, the tilemap contains only tile numbers and the attributes are taken from Default Tilemap Attribute Register ($6C).\r\n\r\nBit 4 selects one of two tilemap palettes used for final colour lookup.\r\n\r\nBit 3 enables \"text mode\" where the tile-graphic is defined as 1-bit B&W bitmap (same as UDG = User Defined Graphic characters on original ZX Spectrum) => one tile needs only 8 bytes to define graphics. The tile-map data are also interpreted differently, the associated flag byte is 7:1 split, the bottom bit 0 being still \"ULA over Tilemap\" or \"ninth bit of tile number\", but the top 7 bits are extended palette offset (copied as top 7 bits of palette index, the eight bottom bit is the pixel value). The transparency is then checked against the Global Transparency Register ($14) colour (after the colour lookup in the palette), not against the four bit Tilemap transparency colour-index.\r\n\r\nBit 1 enables the 512-tile-mode when the tile attribute (either global in Default Tilemap Attribute Register ($6C) or per tile in map data) contains ninth bit of tile-id value. In this mode the tiles are drawn under ULA pixels, unless bit 0 is used to force whole Tilemap over ULA.\r\n\r\nBit 0 can enforce Tilemap over ULA either in 512-tile-mode, or even override the per-tile bit selector from tile attributes. If zero, the Tilemap priority is either decided by attribute bit or in 512-tile-mode it is under ULA.   \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TILEMAP_DEFAULT_ATTR_NR_6C": {
    "content": "# TILEMAP_DEFAULT_ATTR_NR_6C\r\n\r\n## Syntax\r\n\r\n```\r\nTILEMAP_DEFAULT_ATTR_NR_6C = $6C\r\n```\r\n\r\n## Description\r\n\r\n**DEFAULT TILEMAP ATTRIBUTE REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Default_Tilemap_Attribute_Register\r\n\r\nDefault tile attribute for 8-bit only maps.\r\n\r\n**Bit**\r\n\r\n\t7-4  'Palette Offset (copied as bits 7-4 in final palette index)\r\n\t3\t'X mirror\r\n\t2\t'Y mirror\r\n\t1\t'Rotate\r\n\t0\t'If in 512-tile-mode: bit 8 of tile-id\r\n\t\t 'else draw priority: 1 = ULA over tilemap, 0 = tilemap over ULA\r\n\r\nThis attribute is used for all tiles if bit 5 of Tilemap Control Register ($6B) is set.\r\n\r\nWhen bit 1 of Tilemap Control Register ($6B) is set, the bit 0 of tile attribute works as ninth bit of tile-id (allowing 512 tiles in total), and the priority of layers is then \"ULA over Tilemap\" as default.\r\n\r\nWhen bit 3 of Tilemap Control Register ($6B) is set, the bits 7-1 works as Palette offset (copied to bits 7-1 in final palette index, bit 0 comes from pixel data) (there are no mirror/rotate bits in the \"text mode\").\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TILEMAP_GFX_ADR_NR_6F": {
    "content": "# TILEMAP_GFX_ADR_NR_6F\r\n\r\n## Syntax\r\n\r\n```\r\nTILEMAP_GFX_ADR_NR_6F = $6F\r\n```\r\n\r\n## Description\r\n\r\n**TILE DEFINITIONS BASE ADDRESS REGISTER** (R/W)\r\n\r\nMore info : hhttps://wiki.specnext.dev/Tile_Definitions_Base_Address_Register\r\n\r\nBase address of the tiles' graphics.\r\n\r\n\t bits 7-6 ' Read back as zero, write values ignored\r\n\t bits 5-0 ' bits 5-0 = MSB of address of the tile definitions in Bank 5\r\n\r\nThe value written is an offset into Bank 5 allowing [tile definitions](https://wiki.specnext.dev/Tilemap) to be placed at any multiple of 256 bytes.\r\n\r\nWriting a physical MSB address as $40-$7F or $C0-$FF range is permitted (the top bits will be ignored).\r\n\r\nThe value read back may be treated as a full 8-bit value (with the top two bits equal to zero), i.e. upon writing value $EB the read of this register will produce value $2B (contrary to \"reserved\" bits in other registers, where read-value should be not assumed by code using it and masking by AND is recommended).\r\n\r\nDefault value after soft reset corresponds to the address **$4C00**, i.e. default value is **$0C**.  \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TILEMAP_TRANSPARENCY_I_NR_4C": {
    "content": "# TILEMAP_TRANSPARENCY_I_NR_4C\r\n\r\n## Syntax\r\n\r\n```\r\nTILEMAP_TRANSPARENCY_I_NR_4C = $4C\r\n```\r\n\r\n## Description\r\n\r\n**TILEMAP TRANSPARENCY INDEX REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Tilemap_Transparency_Index_Register\r\n\r\nIndex into Tilemap palette (of \"transparent\" colour).\r\n\r\n- bits 7-4 = Reserved, must be 0\r\n-bits 3-0 = Set the index value (0xF after reset)\r\n\r\nThe pixel index (bottom 4 bits) from tile graphics is compared before the palette offset is applied to upper 4 bits, so there is always one index of the 0-15 working as \"transparent\" colour.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TILEMAP_XOFFSET_LSB_NR_30": {
    "content": "# TILEMAP_XOFFSET_LSB_NR_30\r\n\r\n## Syntax\r\n\r\n```\r\nTILEMAP_XOFFSET_LSB_NR_30 = $30\r\n```\r\n\r\n## Description\r\n\r\n**TILEMAP OFFSET X LSB REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/Tilemap_Offset_X_LSB_Register\r\n\r\nTilemap X-offset, low 8 bits of it (0 after a reset)\r\n\r\nMeaningful Range is 0-319 in 40 char mode, 0-639 in 80 char mode.\r\n\r\nThe two top bits of the offset value are stored in Tilemap Offset X MSB Register (TILEMAP_XOFFSET_MSB_NR_2F -$2F).  \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TILEMAP_XOFFSET_MSB_NR_2F": {
    "content": "# TILEMAP_XOFFSET_MSB_NR_2F\r\n\r\n## Syntax\r\n\r\n```\r\nTILEMAP_XOFFSET_MSB_NR_2F = $2F\r\n```\r\n\r\n## Description\r\n\r\n**TILEMAP OFFSET X MSB REGISTER**\r\n\r\nSets the pixel offset (two high bits) used for drawing Tilemap graphics on the screen\r\n\r\n**Bits\r\n\r\n\t7-2  'Reserved must be 0\r\n\t1-0  'Tilemap X-offset, top two bits of it (0 after a reset)\r\n\r\nMeaningful Range is 0-319 in 40 char mode, 0-639 in 80 char mode.\r\n\r\nThe low eight bits of the offset value are stored in Tilemap Offset X LSB Register (TILEMAP_XOFFSET_LSB_NR_30 $30).  \r\n\r\nMore info : https://wiki.specnext.dev/Tilemap_Offset_X_MSB_Register\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TILEMAP_YOFFSET_NR_31": {
    "content": "# TILEMAP_YOFFSET_NR_31\r\n\r\n## Syntax\r\n\r\n```\r\nTILEMAP_YOFFSET_NR_31 = $31\r\n```\r\n\r\n## Description\r\n\r\n**TILEMAP OFFSET Y REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/Tilemap_Offset_Y_Register\r\n\r\nSets the pixel offset used for drawing Tilemap graphics on the screen.\r\n\r\nTilemap Y-offset (0-255) (0 after a reset)\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TRANSPARENCY_FALLBACK_COL_NR_4A": {
    "content": "# TRANSPARENCY_FALLBACK_COL_NR_4A\r\n\r\n## Syntax\r\n\r\n```\r\nTRANSPARENCY_FALLBACK_COL_NR_4A = $4A\r\n```\r\n\r\n## Description\r\n\r\n**TRANSPARENCY COLOUR FALLBACK REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Transparency_colour_fallback_Register\r\n\r\n8-bit colour to be used when all layers contain transparent pixel.\r\n\r\nColour format is RRRGGGBB, like Palette Value Register ($41) uses.\r\n\r\nValue is 0 (black colour) on reset.\r\n\r\nThis colour is also used for PAPER and BORDER when ULANext mode is enabled, and \"full ink\" (ink mask = 255) mode is selected.  \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TURBO_CONTROL_NR_07": {
    "content": "# TURBO_CONTROL_NR_07\r\n\r\n## Syntax\r\n\r\n```\r\nTURBO_CONTROL_NR_07 = $07\r\n```\r\n\r\n## Description\r\n\r\n**CPU SPEED REGISTER** More info : https://wiki.specnext.dev/CPU_Speed_Register\r\n\r\nSets CPU Speed, reads actual speed.\r\n\r\n**Bit Read**\r\n\r\n\t7-6  'Reserved\r\n\t5-4  'Current actual CPU speed\r\n\t3-2  'Reserved\r\n\t1-0  'Programmed CPU speed\r\n\r\n**Bit Write**\r\n\r\n\t7-2  'Reserved must be 0\r\n\t1-0  'Set CPU speed (%00 on reset)\r\n\t\t%00\t' 3.5MHz\r\n\t\t%01\t' 7MHz\r\n\t\t%10\t' 14MHz\r\n\t\t%11\t' 28MHz\r\n\r\nThe CPU throttling from 14MHz to 7MHz is not happening in core 3.0+ any more (but if any configuration would require it, or 28MHz mode will be implemented with throttling, it can be seen by reading bits 5-4). The 3.5MHz speed limit when Expansion Bus is enabled is of course visible in bits 5-4 too.\r\n\r\nThe 28MHz with core 3.0.5 is adding extra wait state to every instruction opcode fetch and memory read (i.e. instruction like NOP will take 5T instead of regular 4T and DMA transfer configured to 2T+2T will take 3T+2T instead), there is some chance this may be improved in the future.   \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ULA_CONTROL_NR_68": {
    "content": "# ULA_CONTROL_NR_68\r\n\r\n## Syntax\r\n\r\n```\r\nULA_CONTROL_NR_68 = $68\r\n```\r\n\r\n## Description\r\n\r\n**ULA CONTROL REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/ULA_Control_Register\r\n\r\nDisable ULA, controls ULA mixing/blending, enable ULA+\r\n\r\n**Bit**\r\n\r\n\t7\t' 1 to disable ULA output (soft reset = 0)\r\n\t6-5  ' %00 for ULA as BLEND colour\r\n\t\t ' %10 for ULA/tilemap as BLEND colour\r\n\t\t ' %11 for tilemap as BLEND colour\r\n\t\t ' %01 for no blending\r\n\t4\t' Cancel entries in 8x5 matrix for extended keys\r\n\t3\t' ULA+ enable (soft reset = 0)\r\n\t2\t' may change (ULA half pixel scroll) (soft reset = 0)\r\n\t1\t' Reserved, must be 0\r\n\t0\t' 1 to enable stencil mode when both the ULA and tilemap are enabled\r\n\t\t ' (if either are transparent the result is transparent otherwise the result is a logical AND of both colours)\r\n\r\nBit 0 can be set to choose stencil mode for the combined output of the ULA and [Tilemap](https://wiki.specnext.dev/Tilemap).\r\n\r\nBits 6-5 determine what colour is used in SLU modes 6 & 7 where the ULA is combined with Layer 2 to generate highlighting effects []Sprite and Layers System Register ($15)](https://wiki.specnext.dev/Sprite_and_Layers_System_Register).\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ULA_XOFFSET_NR_26": {
    "content": "# ULA_XOFFSET_NR_26\r\n\r\n## Syntax\r\n\r\n```\r\nULA_XOFFSET_NR_26 = $26\r\n```\r\n\r\n## Description\r\n\r\n** ULA X OFFSET REGISTER **\r\n\r\nMore info : https://wiki.specnext.dev/ULA_X_Offset_Register\r\n\r\nPixel X offset (0..255) to use when drawing ULA Layer.  \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ULA_YOFFSET_NR_27": {
    "content": "# ULA_YOFFSET_NR_27\r\n\r\n## Syntax\r\n\r\n```\r\nULA_YOFFSET_NR_27 = $27\r\n```\r\n\r\n## Description\r\n\r\n** ULA Y OFFSET REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/ULA_Y_Offset_Register\r\n\r\nPixel Y offset (0..191) to use when drawing ULA Layer.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "USER_STORAGE_0_NR_7F": {
    "content": "# USER_STORAGE_0_NR_7F\r\n\r\n## Syntax\r\n\r\n```\r\nUSER_STORAGE_0_NR_7F = $7F\r\n```\r\n\r\n## Description\r\n\r\n**USER STORAGE 0 REGISTER** (R/W)\r\n\r\n8-bit storage for user\r\n\r\nThese bits don't affect the HW in any way, the user can write any value to them and read it back.\r\n\r\nMay be useful for syncing with running copper code or whatever else you can think of.\r\n\r\nValue is set to $FF upon soft reset.\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "VIDEO_INTERUPT_CONTROL_NR_22": {
    "content": "# VIDEO_INTERUPT_CONTROL_NR_22\r\n\r\n## Syntax\r\n\r\n```\r\nVIDEO_INTERUPT_CONTROL_NR_22 = $22\r\n```\r\n\r\n## Description\r\n\r\n**VIDEO LINE INTERRUPT CONTROL REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nControls the timing of raster interrupts and the ULA frame interrupt. (R/W)\r\n\r\n\tBit\tFunction\r\n\t7\t'(R) INT signal (even when Z80N has interrupts disabled) (1 = interrupt is requested)\r\n\t\t '(W) Reserved, must be 0\r\n\t6-3  'Reserved, must be 0 \r\n\t2\t'If 1 disables original ULA interrupt (Reset to 0 after a reset)\r\n\t1\t'If 1 enables Line Interrupt (Reset to 0 after a reset)\r\n\t0\t'MSB of Line Interrupt line value (Reset to 0 after a reset)\r\n\r\nThe line interrupt value uses coordinate system of Copper coprocessor, i.e. line 0 is the first line of pixels. But the line-interrupt happens already when the previous line's pixel area is finished (i.e. the raster-line counter still reads \"previous line\" and not the one programmed for interrupt). The INT signal is raised while display beam horizontal position is between 256-319 standard pixels, precise timing of interrupt handler execution then depends on how-quickly/if the Z80 will process the INT signal.\r\n\r\nThe LSB part of desired interrupt line is in Video Line Interrupt Value Register ($23).\r\n\r\nSince core 3.1.5 the numbering of lines can be offset by Vertical Video Line Offset Register ($64).  \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "VIDEO_INTERUPT_VALUE_NR_23": {
    "content": "# VIDEO_INTERUPT_VALUE_NR_23\r\n\r\n## Syntax\r\n\r\n```\r\nVIDEO_INTERUPT_VALUE_NR_23 = $23\r\n```\r\n\r\n## Description\r\n\r\n**VIDEO LINE INTERRUPT VALUE REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/Video_Line_Interrupt_Value_Register\r\n\r\nHolds the eight LSBs of the line on which a raster interrupt should occur.\r\n\r\nbits 7:0 = Line Interrupt value LSB (soft reset = 0)\r\n\r\nSince core 3.1.5 the numbering of lines can be offset by Vertical Video Line Offset Register ($64).\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "VIDEO_LINE_LSB_NR_1F": {
    "content": "# VIDEO_LINE_LSB_NR_1F\r\n\r\n## Syntax\r\n\r\n```\r\nVIDEO_LINE_LSB_NR_1F = $1F\r\n```\r\n\r\n## Description\r\n\r\n**ACTIVE VIDEO LINE LSB REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/Active_Video_Line_LSB_Register\r\n\r\nHolds the eight LSBs of the raster line currently being drawn.(R)\r\n\r\nThe MSB of the raster line is in Active Video Line MSB Register ($1E).\r\n\r\nThe line coordinates use coordinate system of Copper coprocessor, i.e. line 0 is the first line of pixels.\r\n\r\nSince core 3.1.5 the numbering of lines can be offset by Vertical Video Line Offset Register ($64).\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "VIDEO_LINE_MSB_NR_1E": {
    "content": "# VIDEO_LINE_MSB_NR_1E\r\n\r\n## Syntax\r\n\r\n```\r\nVIDEO_LINE_MSB_NR_1E = $1E\r\n```\r\n\r\n## Description\r\n\r\n**ACTIVE VIDEO LINE MSB REGISTER**\r\n\r\nMore info : https://wiki.specnext.dev/Active_Video_Line_MSB_Register\r\n\r\nHolds the MSB (only, as bit 0) of the raster line currently being drawn.(R)\r\n\r\nThe low 8 bit part of the raster line number is in Active Video Line LSB Register ($1F).\r\n\r\nThe line coordinates use coordinate system of Copper coprocessor, i.e. line 0 is the first line of pixels.\r\n\r\nSince core 3.1.5 the numbering of lines can be offset by Vertical Video Line Offset Register ($64).\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "VIDEO_LINE_OFFSET_NR_64": {
    "content": "# VIDEO_LINE_OFFSET_NR_64\r\n\r\n## Syntax\r\n\r\n```\r\nVIDEO_LINE_OFFSET_NR_64 = $64\r\n```\r\n\r\n## Description\r\n\r\n**VERTICAL VIDEO LINE OFFSET REGISTER** (R/W)\r\n\r\nMore info : https://wiki.specnext.dev/Vertical_Video_Line_Offset_Register\r\n\r\nOffset numbering of raster lines in copper/interrupt/active register\r\n\r\nBits 7-0 form offset value 0..255, the offset is added to Copper, Video Line Interrupt and Active Video Line readings.\r\n\r\nNormally the ULA's pixel row 0 aligns with vertical line count 0. With a non-zero offset, the ULA's pixel row 0 will align with the vertical line offset.\r\n\r\nEg, if the offset is 32 then video line 32 will correspond to the first pixel row in the ULA and video line 0 will align with the first pixel row of the Tilemap and Sprites (in the top border area). Then Copper WAIT command waiting for line 0 will happen already in top border area.\r\n\r\nAlso Copper mode %11 restarting CPC=0 at pixel [0,0] (with offset 0) will be offset to new line!\r\n\r\nSince a change in offset takes effect when the ULA reaches row 0, the change can take up to one frame to occur.\r\n\r\n(also related: Active Video Line MSB Register ($1E), Active Video Line LSB Register ($1F), Video Line Interrupt Control Register ($22), Video Line Interrupt Value Register ($23) and Copper)  \r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "VIDEO_TIMING_NR_11": {
    "content": "# VIDEO_TIMING_NR_11\r\n\r\n## Syntax\r\n\r\n```\r\nVIDEO_TIMING_NR_11 = $11\r\n```\r\n\r\n## Description\r\n\r\nVIDEO_TIMING_NR_11 = $11\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ZX_MEM_MAPPING_NR_8E": {
    "content": "# ZX_MEM_MAPPING_NR_8E\r\n\r\n## Syntax\r\n\r\n```\r\nZX_MEM_MAPPING_NR_8E = $8E\r\n```\r\n\r\n## Description\r\n\r\nZX_MEM_MAPPING_NR_8E = $8E\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SYSTEMVARIABLES": {
    "content": "# System variable for NextZXOS\r\n\r\nThe following system variables have been changed (same format as +3 manual):\r\n```\r\n1 5B5FH (23391) INKL INK colour for lo-res mode (was BAUD)\r\n1 5B60H (23392) INK2 INK colour for layer2 mode (was BAUD+1)\r\n1 5B61H (23393) ATTRULA Attributes for standard mode (was SERFL)\r\n1 5B62H (23394) ATTRHR Attributes for hi-res mode (only paper\r\ncolour in bits 3..5 is used) (was SERFL+1)\r\n1 5B63H (23395) ATTRHC Attributes for hi-colour mode (was COL)\r\n1 5B64H (23396) INKMASK Softcopy of ULANext inkmask(or 0)(was WIDTH)\r\nN1 5B65H (23397) LSBANK Temp bank in LOAD/SAVE & others (was TVPARS)\r\nX1 5B68H (23400) FLAGN Flags for the NextZXOS system (was XLOC)\r\n1 5B69H (23401) MAXBNK Maximum available RAM bank (was YLOC)\r\n1 5B73H (23411) TILEBNKL Tiles bank for lo-res (was RC LINE)\r\n1 5B74H (23412) TILEML Tilemap bank for lo-res (was RC LINE+1)\r\n1 5B75H (23413) TILEBNK2 Tiles bank for layer2 (was RC START)\r\n1 5B76H (23414) TILEM2 Tilemap bank for layer2 (was RC START+1)\r\nX1 5B77H (23415) NXTBNK Bank containing NXTLIN (was RC STEP)\r\nX1 5B78H (23416) DATABNK Bank containing DATADD (was RC STEP+1)\r\nN1 5B7BH (23419) L2SOFT Softcopy of layer2 port (was DUMPLF)\r\nX1 5C7FH (23679) GMODE Graphical layer/mode flags (was P POSN)\r\n1 5C81H (23681) STIMEOUT Screensaver control (was unused)\r\n2 5CB0H (23728) unused (was NMIADD)\r\n```\r\n\r\nThe following system variables have been inserted where STRIP1 and STRIP2 were,\r\nwithin the temporary TSTACK area. This means that there are now a guaranteed 117\r\nbytes of TSTACK when calling +3DOS:\r\n\r\n```\r\n2 5B7CH (23420) TILEWL Width of lo-res tilemap\r\n2 5B7EH (23422) TILEW2 Width of layer2 tilemap\r\n2 5B80H (23424) TILEOFFL Offset in bank for lo-res tilemap\r\n2 5B82H (23426) TILEOFF2 Offset in bank for layer2 tilemap\r\n2 5B84H (23428) COORDSX x coord of last point plotted (layer 1/2)\r\n2 5B86H (23430) COORDSY y coord of last point plotted (layer 1/2)\r\n1 5B88H (23432) PAPERL PAPER colour for lo-res mode\r\n1 5B89H (23433) PAPER2 PAPER colour for layer2 mode\r\nNx 5B8AH (23434) TMPVARS Base of temporary system variables (space shared with bottom of TSTACK)\r\n```",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "_GLOBALMEMORY": {
    "content": "# Global Memory Map\r\n\r\n## Table of Contents\r\n - [Memory Introduction](#memory-introduction)\r\n - [Z80 Visible Memory](#z80-visible-memory)\r\n\r\n# Memory Introduction \r\n\r\nThe total available RAM space of the Next is 768k on an unexpanded Next, or 1792k on a Next expanded to 2Mb. (The base Next has 1mb of memory but 256k of it is reserved for the ROMs and firmware.)\r\n\r\nThe Z80 processor in the Next can access only 64k of memory at a time, and so the memory is divided into banks which are used in determining which memory it sees. Spectrum 128k memory management, and NextBASIC, use 16k banks. Next memory management via machine code uses 8k banks.\r\n\r\n\r\n|16k-bank | 8k-bank |True Address |Size |Description\r\n|:-:|:-:|:-:|:-:|:--|\r\n|- | - | $000000-$00ffff  |64K \t| ZX Spectrum ROM | \r\n|- | - | $010000-$013fff  |16K \t| EsxDOS ROM |\r\n|- | - | $014000-$017fff  |16K \t| Multiface ROM |\r\n|- | - | $018000-$01bfff  |16K \t| Multiface Extra ROM |\r\n|- | - | $01c000-$01ffff  |16K \t| Multiface RAM |\r\n|- | - | $020000-$03ffff  |128K | DivMMC RAM |\r\n|0-7 |0-15 |$040000-$05ffff |128K |Standard 128K RAM |\r\n|8-15 |16-31 |$060000-$07ffff |128K |Extra RAM|\r\n|16-47 |32-95 |$080000-$0fffff |512K |1st extra IC RAM (available on unexpanded Next) |\r\n|48-79 |96-159 |$100000-$17ffff |512K |2nd extra IC RAM (only available on expanded Next)| \r\n|80-111 |160-223 |$180000-$1fffff |512K |3rd extra IC RAM (only available on expanded Next)|\r\n\r\nAdditionally, the first few pages have certain uses and traits summarised below:\r\n\r\n|16k-bank | 8k-bank |Description\r\n|:-:|:-:|:--|\r\n|0 | 0-1 |Standard RAM, maybe used by EsxDOS. Initially mapped to $c000-$ffff.|\r\n|1 | 2-3 |Standard RAM, contended on 128, may be used by EsxDOS, RAMdisk on NextZXOS.|\r\n|2 | 4-5 | Standard RAM. Initially mapped to $8000-$bfff.|\r\n|3 | 6-7 | Standard RAM, contended on 128, may be used by EsxDOS, RAMdisk on NextZXOS.|\r\n|4 | 8-9 | Standard RAM, contended on +2/+3, RAMdisk on NextZXOS.|\r\n|5 | 10-11 | ULA Screen, contended except on Pentagon, cannot be used by NextBASIC commands. Initially mapped to $4000-$7fff.|\r\n|6 | 12-13 | Standard RAM, contended on +2/+3, RAMdisk on NextZXOS.|\r\n|7 | 14-15 | ULA Shadow Screen, contended except on Pentagon, NextZXOS Workspace, cannot be used by NextBASIC commands |\r\n|8 | 16-17 | Next RAM, Default Layer 2, NextZXOS screen and extra data, cannot be used by NextBASIC commands |\r\n|9-10 |\t18-21 | Next RAM, Rest of default Layer 2 |\r\n|11-13|\t22-27 | Next RAM, Default Layer 2 Shadow Screen |\r\n\r\n**NOTE** Please note that NextZXOS moves the Layer 2 bank assignments. Therefore, Layer 2, after NextZXOS boots, is mapped to 16k-banks 9-11 (8k-banks 18-23). The Layer 2 shadow memory is also assigned to 16k-banks 9-11 (8k-banks 18-23).\r\nZ80 Visible Memory map\r\n\r\n## Z80 Visible Memory\r\n\r\nAt start up, the 16-bit address space of the Z80 is mapped to memory as follows:\r\n\r\n|Area |16k-slot |8k-slot |Default 16k-bank |Default 8k-bank |Description\r\n|:-:|:-:|:-:|:-:|:-:|:--|\r\n|$0000-$1fff |1 |0 |ROM |ROM (255) | Normally ROM. R/W redirect by Layer 2. IRQ and NMI routines here.\r\n|$2000-$3fff |\t|1 |ROM |(255) | Normally ROM. R/W redirect by Layer 2.\r\n|$4000-$5fff |2 |2 | 5 \t|10 | Normally used for normal/shadow ULA screen.\r\n|$6000-$7fff |\t|3 |    |11\t| Timex ULA extended attribute/graphics area.\r\n|$8000-$9fff |3\t|3 | 2 \t|4 \t| Free RAM.\r\n|$a000-$bfff |\t|5 |  \t|5  | Free RAM.\r\n|$c000-$dfff |4\t|4 | 0 \t|0 \t| Free RAM. Only this area is remappable by 128 memory management.\r\n|$e000-$ffff |\t|7 |  \t|1 \t| Free RAM. Only this area is remappable by 128 memory management. \r\n\r\n## Remarks \r\n\r\nThe ZX Spectrum Next can page in any of the 8KB memory banks into any slot using [MMU8(s,n)](MMU8.md) or via NextRegs : \r\n\r\n```\r\n#INCLUDE <nextlib.bas>\r\nNextRegA(MMU2_4000_NR_52,22)        ' sets slot 2 (2000-3fff) with bank 22\r\n```\r\n\r\nCare needs to be taken that interrupts are correctly handled (NextBuild disables system interrupts on startup).\r\n\r\n## Links \r\n\r\n[Memory](Memory.md) ",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_MEMORY": {
    "content": "# Memory \r\n\r\n## Table of contents \r\n\r\n- [Memory](#memory)\r\n  - [Table of contents](#table-of-contents)\r\n  - [Overview](#overview)\r\n- [Terminology](#terminology)\r\n- [Commands for working with banks](#commands-for-working-with-banks)\r\n  - [Example Paging](#example-paging)\r\n  - [Graphic Banks](#graphic-banks)\r\n    - [For 256x192:](#for-256x192)\r\n    - [For 320x256:](#for-320x256)\r\n  - [Traditional Banking](#traditional-banking)\r\n  - [Remarks](#remarks)\r\n    - [ASM mapping](#asm-mapping)\r\n  - [Links](#links)\r\n\r\n## Overview \r\n\r\nThe ZX Spectrum Next can page in (swap) and out up to 224 8KB memory slots in positions [0-7] of the 64KB of addressable RAM, to expand the range of visible memory the CPU can read & write. This is quite a powerful system giving you access to up to nearly 2MB of RAM (further files can be loaded from SD card too). \r\n\r\nFor information on how the memory is sliced up check the [Global Memory Map](GlobalMemory.md). NextBuild's commands support using the extended memory and does most of the heavy lifting meaning you can move things around in memory with simple commands. \r\n\r\n# Terminology \r\n\r\nTraditionally swapping memory banks has been known as `paging`, as you are turning the *page* on the memory for a clean sheet (at least one can imagine). The 128K ZX Spectrum had the ability to page in 16KB from [$c000-$ffff]. The Next supports the traditional (more cumbersome) method but also supports `paging` in banks of memory that are 8KB in size. NextZXOS refers to banks as 16KB slots, and with the two differing sizes people have wanted to have a verbal separation of the two by calling `8KB paging` and `16KB banking`. In NextBuild we almost always will be using 8KB paging, so you will see the two interchanged. \r\n\r\nWhen working with some components of the Next 16KB banks will be required, such as the [LAYER2_RAM_BANK_NR_12](LAYER2_RAM_BANK_NR_12.md). This means to set Layer2 start RAM bank from 8KB bank 32, the number is / 2. \r\n```\r\nNextRegA(LAYER2_RAM_BANK_NR12,16)                   ; sets Layer2 RAM start at 8KB 32\r\n```\r\n\r\n# Commands for working with banks\r\nA number of commands will take a bank parameter, this means the routine will use that bank as the source location, and does a clean up (stores the current bank, carries out the process, replaces the original bank). \r\n\r\n- [ClearBank](ClearBank.md)\r\n- [CopyBank](CopyBank.md)\r\n- [LoadSDBank](LoadSDBank.md)\r\n- [NextRegA](NextRegA.md)\r\n\r\nManually paging in RAM can be done using the Next Registers: \r\n\r\n- [MMU0_0000_NR_50](MMU0_0000_NR_50.md)\r\n  - $0000-$1fff *slot 0*\r\n- [MMU1_2000_NR_51](MMU1_2000_NR_51.md)\r\n  - $2000-$3fff *slot 1*\r\n- [MMU2_4000_NR_52](MMU2_4000_NR_52.md)\r\n  - $4000-$5fff *slot 2*\r\n- [MMU3_6000_NR_53](MMU3_6000_NR_53.md)\r\n  - $6000-$7fff *slot 3*\r\n- [MMU4_8000_NR_54](MMU4_8000_NR_54.md)\r\n  - $8000-$9fff *slot 4*\r\n- [MMU5_A000_NR_55](MMU5_A000_NR_55.md)\r\n  - $a000-$bfff *slot 5*\r\n- [MMU6_C000_NR_56](MMU6_C000_NR_56.md)\r\n  - $c000-$dfff *slot 6*\r\n- [MMU7_E000_NR_57](MMU7_E000_NR_57.md)\r\n\r\n## Example Paging \r\n\r\nBefore paging care must be taken that running code isn't in the same slot as that being paged out, and if paging slots [0-2] system interrupts are not being used. Some of the keywords that come with ZX Basic Compiler rely on the SYSVARS being intact (See [System Variables](SystemVariables.md)). For this reason a number of routines have been patched to include a stub file, that always pages in the system default SYSVAR memory bank (bank $0a), and neatly replacing it after the call. \r\n\r\nTo swap in bank 32 to slot 7 **[e000-ffff]**\r\n```\r\nNextRegA(MMU7_E000_NR_57,32)\r\n```\r\nsimilarly, you can specify the register value directly: \r\n\r\n```\r\nNextRegA($57,32)\r\n```\r\nAnd finally a helper routine that wraps it up:\r\n```\r\nMMU8(7, 32)                 ; page in bank 32 to slot 7\r\n```\r\n\r\n## Graphic Banks\r\n\r\nTo move graphics from memory banks to the screen a number of commands have been included. For drawing software tiles, use ```LoadSDBank``` to load the tile data into memory, and then use the ```DoTilBank8```, ```DoTilBank16``` or ```DoTileBank32``` commands to draw the tile to the screen. \r\n\r\n\r\n### For 256x192:\r\n```\r\nDoTilBank8(bank, x, y, tile)        ; draw 8x8 tile from bank (all routines draw to layer2) 8 px\r\nDoTilBank16(bank, x, y, tile)       ; draw 16x16 tile from bank \r\nDoTileBank32(bank,x, y, tile)       ; draw 32x32 tile \r\n```\r\n### For 320x256:\r\n```\r\nFDoTilBank8(bank, x, y, tile)       ; draw 8x8 tile from bank\r\nFDoTilBank16(bank, x, y, tile)      ; draw 16x16 tile from bank \r\n```\r\nSee [Graphics](_Graphics.md) for more information\r\n\r\n## Traditional Banking \r\n\r\nNextBuild does allow you to page in memory in 16KB chunks at **[$c000-$ffff]** just like the traditional system, on the Next however we are not limited to 7 banks, but can page up to 112 banks\r\n\r\n```\r\nMMU16(16)                           ; page in 16KB to [$c000-$ffff]\r\n```\r\n\r\n## Remarks \r\n\r\nIf you're looking to write the optimal code then it is recommended that you use ```NextReg``` commands inside of an asm block. \r\n\r\n### ASM mapping \r\n```\r\nasm \r\n  getreg(MMU0_0000_NR_50)\r\n  ld   b, a\r\n  nextreg MMU0_0000_NR_50, 32     ; map bank 32 to slot 0\r\n  ; do something\r\n  ld   a, b\r\n  nextreg MMU0_0000_NR_50, b      ; restore original bank\r\nend asm \r\n```\r\n\r\n## Links\r\n\r\n- [NextRegA](NextRegA.md)\r\n- [NextReg](NextReg.md)\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "AY_SOUND_REGISTERS": {
    "content": "# AY Sound Chip Registers\n\n## Register Overview\n\nThe AY-3-8912 sound chip provides 3 channels of tone generation, noise generation, and envelope control. Registers are accessed via [Sound Chip Register Write](sound_chip_register_write.md) ($BFFD) after selecting the register with [Turbo Sound Next Control](turbo_sound_next_control.md) ($FFFD).\n\n| Register | Function |\n|----------|----------|\n| 0 | Channel A Fine Tune |\n| 1 | Channel A Coarse Tune (4 bits) |\n| 2 | Channel B Fine Tune |\n| 3 | Channel B Coarse Tune (4 bits) |\n| 4 | Channel C Fine Tune |\n| 5 | Channel C Coarse Tune (4 bits) |\n| 6 | Noise Period (5 bits) |\n| 7 | Tone enable flags |\n| 8 | Channel A amplitude |\n| 9 | Channel B amplitude |\n| 10 | Channel C amplitude |\n| 11 | Envelope period fine |\n| 12 | Envelope period coarse |\n| 13 | Envelope shape |\n\n## Detailed Register Descriptions\n\n### Registers 0-5: Tone Generation\n\n#### Channel Frequency Control\n- **Registers 0,1**: Channel A frequency (12-bit value)\n- **Registers 2,3**: Channel B frequency (12-bit value)  \n- **Registers 4,5**: Channel C frequency (12-bit value)\n\n**Fine tune registers** (0,2,4): Lower 8 bits of frequency value\n**Coarse tune registers** (1,3,5): Upper 4 bits of frequency value (bits 0-3 only)\n\n**Frequency calculation**: `Tone Period = Clock Frequency / (16 × Register Value)`\n\n### Register 6: Noise Period (5 bits)\n\nControls the frequency of the noise generator. Only bits 0-4 are used.\n\n**Noise frequency**: `Noise Period = Clock Frequency / (16 × Register Value)`\n\n### Register 7: Tone/Noise Enable Flags\n\n| Bit | Function | Logic |\n|-----|----------|-------|\n| 0 | Channel A tone enable | 0 = enabled, 1 = disabled |\n| 1 | Channel B tone enable | 0 = enabled, 1 = disabled |\n| 2 | Channel C tone enable | 0 = enabled, 1 = disabled |\n| 3 | Channel A noise enable | 0 = enabled, 1 = disabled |\n| 4 | Channel B noise enable | 0 = enabled, 1 = disabled |\n| 5 | Channel C noise enable | 0 = enabled, 1 = disabled |\n| 6-7 | Unused | - |\n\n**Note**: Enable bits are **inverted** - 0 means enabled, 1 means disabled.\n\n### Registers 8-10: Channel Amplitude\n\nControls the volume and envelope settings for each channel.\n\n| Bit | Function |\n|-----|----------|\n| 0-3 | Fixed amplitude level (0-15) |\n| 4 | Amplitude mode: 0 = fixed, 1 = envelope |\n| 5-7 | Unused |\n\n- **Bit 4 = 0**: Use fixed amplitude from bits 0-3\n- **Bit 4 = 1**: Use envelope generator (bits 0-3 ignored)\n\n### Registers 11-12: Envelope Period\n\n**Register 11**: Envelope period fine (lower 8 bits)\n**Register 12**: Envelope period coarse (upper 8 bits)\n\n**Envelope frequency**: `Envelope Period = Clock Frequency / (256 × Register Value)`\n\n### Register 13: Envelope Shape\n\nControls the behavior of the envelope generator using bits 0-3:\n\n| Bit | Name | Function |\n|-----|------|----------|\n| **0** | **Hold** | 1 = perform one cycle then hold at end value<br/>0 = cycle continuously |\n| **1** | **Alternate** | 1 = alter direction after each cycle<br/>0 = reset after each cycle<br/>If Hold=1: chooses held value (0=final, 1=initial) |\n| **2** | **Attack** | 1 = count up, 0 = count down |\n| **3** | **Continue** | 0 = one cycle then drop to 0 (overrides Hold)<br/>1 = follow Hold setting |\n\n## Usage Examples\n\n### Play a Note on Channel A\n```assembly\n; Set Channel A to 440Hz (approximately)\nLD BC, $FFFD        ; Select register port\nLD A, 0             ; Register 0 (Channel A fine)\nOUT (C), A\nLD BC, $BFFD        ; Data port\nLD A, $EE           ; Fine tune value\nOUT (C), A\n\nLD BC, $FFFD        ; Select register port  \nLD A, 1             ; Register 1 (Channel A coarse)\nOUT (C), A\nLD BC, $BFFD        ; Data port\nLD A, $01           ; Coarse tune value\nOUT (C), A\n\n; Enable tone on Channel A\nLD BC, $FFFD\nLD A, 7             ; Register 7 (enable)\nOUT (C), A\nLD BC, $BFFD\nLD A, %11111110     ; Enable tone A, disable others\nOUT (C), A\n\n; Set volume\nLD BC, $FFFD\nLD A, 8             ; Register 8 (Channel A amplitude)\nOUT (C), A\nLD BC, $BFFD\nLD A, 15            ; Maximum volume, fixed amplitude\nOUT (C), A\n```\n\n### Configure Envelope\n```assembly\n; Set envelope period\nLD BC, $FFFD\nLD A, 11            ; Register 11 (envelope fine)\nOUT (C), A\nLD BC, $BFFD\nLD A, $00           ; Fine period\nOUT (C), A\n\nLD BC, $FFFD\nLD A, 12            ; Register 12 (envelope coarse)\nOUT (C), A\nLD BC, $BFFD\nLD A, $10           ; Coarse period\nOUT (C), A\n\n; Set envelope shape - attack, continue, no hold\nLD BC, $FFFD\nLD A, 13            ; Register 13 (envelope shape)\nOUT (C), A\nLD BC, $BFFD\nLD A, %00001100     ; Attack=1, Continue=1\nOUT (C), A\n\n; Use envelope on Channel A\nLD BC, $FFFD\nLD A, 8             ; Register 8 (Channel A amplitude)\nOUT (C), A\nLD BC, $BFFD\nLD A, %00010000     ; Use envelope (bit 4=1)\nOUT (C), A\n```\n\n### Enable Noise\n```assembly\n; Set noise period\nLD BC, $FFFD\nLD A, 6             ; Register 6 (noise period)\nOUT (C), A\nLD BC, $BFFD\nLD A, $10           ; Noise period value\nOUT (C), A\n\n; Enable noise on Channel A, disable tone\nLD BC, $FFFD\nLD A, 7             ; Register 7 (enable flags)\nOUT (C), A\nLD BC, $BFFD\nLD A, %11110001     ; Disable tone A, enable noise A\nOUT (C), A\n```\n\n## Frequency Tables\n\n### Common Musical Notes (Approximate Register Values)\n\n| Note | Frequency (Hz) | 12-bit Value | Fine (R0/2/4) | Coarse (R1/3/5) |\n|------|----------------|--------------|---------------|-----------------|\n| C4 | 261.63 | $0D5D | $5D | $0D |\n| D4 | 293.66 | $0BE8 | $E8 | $0B |\n| E4 | 329.63 | $0A7C | $7C | $0A |\n| F4 | 349.23 | $09D9 | $D9 | $09 |\n| G4 | 392.00 | $0894 | $94 | $08 |\n| A4 | 440.00 | $0789 | $89 | $07 |\n| B4 | 493.88 | $06AD | $AD | $06 |\n\n## Programming Tips\n\n1. **Use both tone and noise** for rich sound effects\n2. **Envelope generator** provides automatic volume control\n3. **Multiple AY chips** available on Next for complex arrangements\n4. **Register selection** must be done before data writes\n5. **Frequency calculation** helps with musical note accuracy\n\n## Related Ports\n\n- [Turbo Sound Next Control](turbo_sound_next_control.md) ($FFFD) - Register selection\n- [Sound Chip Register Write](sound_chip_register_write.md) ($BFFD) - Data writing\n- [AY Info](ay_info.md) ($BFF5) - Chip information",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DISABLEMUSIC": {
    "content": "# DISABLEMUSIC\r\n\r\n## Syntax\r\n\r\n```\r\nDisableMusic\r\n```\r\n\r\n## Description\r\n\r\nMACRO that Stops music playback. See [InitMusic()](Initmusic.md) \r\n\r\n## Requires:\r\n```\r\n#DEFINE IM2\r\n#INCLUDE <nextlib.bas>\r\n#INCLUDE <nextlib_ints.bas>  \r\n```\r\n\r\n## Links \r\n\r\n- [ENABLEMUSIC](EnableMusic.md)\r\n- [ENABLESFX](EnableSfx.md)\r\n- [InitMusic()](InitMusic.md)\r\n- [InitSFX()](InitSFX.md)\r\n- [Interrupts](Interrupts.md)\r\n- [Index](Index.md) \r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DISABLESFX": {
    "content": "# DISABLESFX\r\n\r\n## Syntax\r\n\r\n```\r\nDisableSFX\r\n```\r\n\r\n## Description\r\n\r\nMACRO that stops ayfx playback. See [InitSFX()](InitSFX.md) \r\n\r\n## Requires:\r\n```\r\n#DEFINE IM2 \r\n#INCLUDE <nextlib.bas>\r\n#INCLUDE <nextlib_ints.bas>  \r\n```\r\n\r\n## Links \r\n\r\n- [DISABLEMUSIC](DisableMusic.md)\r\n- [ENABLEMUSIC](EnableMusic.md)\r\n- [ENABLESFX](EnableSfx.md)\r\n- [InitMusic()](InitMusic.md)\r\n- [InitSFX()](InitSFX.md)\r\n- [Interrupts](Interrupts.md)\r\n- [Index](Index.md) \r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ENABLEMUSIC": {
    "content": "# ENABLEMUSIC\r\n\r\n## Syntax\r\n\r\n```\r\nEnableMusic\r\n```\r\n\r\n## Description\r\n\r\nMacro that starts music playback. You must have initialised the music engine using [InitMusic()](InitMusic.md)\r\n\r\n## Requires:\r\n```\r\n#DEFINE IM2 \r\n#INCLUDE <nextlib.bas>\r\n#INCLUDE <nextlib_ints.bas>  \r\n```\r\n\r\n## Links \r\n\r\n- [DISABLEMUSIC](DisableMusic.md)\r\n- [ENABLESFX](EnableSfx.md)\r\n- [InitMusic()](InitMusic.md)\r\n- [InitSFX()](InitSFX.md)\r\n- [Interrupts](Interrupts.md)\r\n- [Index](Index.md) \r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ENABLESFX": {
    "content": "# ENABLESFX\r\n\r\n## Syntax\r\n\r\n```\r\nEnableSfx\r\n```\r\n\r\n## Description\r\n\r\nMacro that starts `AYFX` playback. You must have initialised the `AYFX` engine using [InitSFX()](InitSFX.md)\r\n\r\nSee [InitMusic()](InitMusic.md) for more details.\r\n\r\n## Requires:\r\n```\r\n#DEFINE IM2\r\n#INCLUDE <nextlib.bas>\r\n#INCLUDE <nextlib_ints.bas>  \r\n```\r\n\r\n## Links \r\n\r\n- [DISABLEMUSIC](DisableMusic.md)\r\n- [ENABLEMUSIC](EnableMusic.md)\r\n- [ENABLESFX](EnableSfx.md)\r\n- [InitMusic()](InitMusic.md)\r\n- [Interrupts](Interrupts.md)\r\n- [Index](Index.md) ",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INITMUSIC": {
    "content": "# INITMUSIC\r\n\r\n## Syntax\r\n\r\n```\r\nInitMusic(player bank, music bank)\r\n```\r\n\r\n## Description\r\n\r\nUsed to initialise a ProTracker 3 ``(.pt3)`` file to be played back on interrupt, that is updated once per frame **(@50 / 60 Hz)**. \r\n\r\nThe commannd [SetUpIM()](SetUpIM.md) will automatically set up a system interrupt, call a replyer code to play back the music. Bundled with the player is also a version of Shiru's `AYFXEngine`. First you need to load in the binaries into your chosed banks:\r\n\r\n\t' -- Loadblock\r\n\tLoadSDBank(\"[]vt24000.bin\",0,0,0,38)\t\t' load the music replayer into bank 38\r\n\tLoadSDBank(\"[]music1.pt3\",0,0,0,39)\t\t\t' load music.pt3 into 39\r\n\tLoadSDBank(\"[]game.afb\",0,0,0,41)\t\t\t' load sfx into bank 41\r\n\r\nNote the **[]** before the filename tells NBS to load the file from the system assets stored in `Scripts/system_data`. Once these are loaded you can run the initialisation code:\r\n\r\n\t' --\r\n\tInitSFX(41)\t\t\t\t\t' init the SFX engine, sfx are in bank 41\r\n\tInitMusic(38,39,0000)\t\t' init the music engine 38 has the player, 39 the pt3, 0000 offset\r\n\tSetUpIM()\t\t\t\t\t' init the IM2 code\r\n\tEnableSFX\t\t\t\t\t' Enables the AYFX, use DisableSFX to top\r\n\tEnableMusic\t\t\t\t\t' Enables Music, use DisableMusic to stop\r\n\r\nWhen you want to play an `AYFX` use the [PlaySFX()](PlaySFX.md) command: \r\n\r\n\tPlaySFX(n)\t\t\t\t\t\r\n\r\nThe `Interrupt Vector` is automatically generated at the start of your code, just after the HEAP and is stored in the library section of the final code. This is aligned to the nearest 256 boundary, because your interrupt vector table should always start on an ALIGNed address e.g : ``$fd00``  \r\n\r\n## MyCustomISR \r\n\r\nNBS can also run a user defined `ISR` along side the system interrupt. To do this you need to create a function that will be called by the system interrupt. This function must be called `MyCustomISR` and must be declared as follows:\r\n\r\n```\r\nSub MyCustomISR()\r\n\t' Your code here\r\nEnd Sub\r\n```\r\n\r\nThen before you include the `nextlib.bas` file you need to define the `CUSTOMISR` macro, this is done by adding the following line to the top of your code:\r\n\r\n```\r\n#DEFINE CUSTOMISR\r\n```\r\n\r\n## Requires:\r\n```\r\n#DEFINE IM2\r\n#INCLUDE <nextlib.bas>\r\n#INCLUDE <nextlib_ints.bas>  \r\n```\r\n\r\n## Links \r\n\r\n- [InitSFX()](InitSFX.md)\r\n- [PlaySFX()](PlaySFX.md)\r\n- [EnableSFX()](EnableSFX.md)\r\n- [EnableMusic()](EnableMusic.md)\r\n- [DisableSFX()](DisableSFX.md)\r\n- [DisableMusic()](DisableMusic.md)\r\n- [LoadSDBank()](LoadSDBank.md)",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INITSFX": {
    "content": "# INITSFX\r\n\r\n## Syntax\r\n\r\n```\r\nInitSFX(8k bank)\r\n```\r\n\r\n## Description\r\n\r\nInitialises the `AYFX` sound effect bank, you must set up interrupts using [InitMusic()](InitSFX.md)\r\n\r\nSee [InitMusic()](InitMusic.md) for more details.\r\n\r\n## Requires:\r\n```\r\n#DEFINE IM2\r\n#INCLUDE <nextlib.bas>\r\n#INCLUDE <nextlib_ints.bas>  \r\n```\r\n\r\n## Links \r\n\r\n- [InitMusic()](InitMusic.md)\r\n- [PlaySFX()](PlaySFX.md)\r\n- [EnableSFX()](EnableSFX.md)\r\n- [EnableMusic()](EnableMusic.md)\r\n- [DisableSFX()](DisableSFX.md)\r\n- [DisableMusic()](DisableMusic.md)\r\n- [LoadSDBank()](LoadSDBank.md)",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "KEMPSTON_JOYSTICK": {
    "content": "# Kempston Joystick ($xx1F)\n\n## Port Information\n\n| Property | Value |\n|----------|-------|\n| **Port Number** | $xx1F |\n| **Decimal** | 31 |\n| **Bit Mask** | %---- ---- 0001 1111 |\n| **Readable** | Yes |\n| **Writable** | No |\n| **Subsystem** | Input |\n\n## Description\n\nReads movement of joysticks using Kempston interface.\n\n## Port Data Format\n\n| Bit | Function | Kempston Joystick | MD Controller |\n|-----|----------|-------------------|---------------|\n| **7** | 0 | - | Start button |\n| **6** | 0 | - | A button |\n| **5** | Fire 2 | Fire 2 | C button |\n| **4** | Fire 1 | Fire 1 | B button |\n| **3** | Up | Up | Up |\n| **2** | Down | Down | Down |\n| **1** | Left | Left | Left |\n| **0** | Right | Right | Right |\n\n**For all bits: 0 = not pressed / 1 = pressed**\n\n## Controller Support\n\n### Standard Kempston Joystick\n- **Bits 0-4**: Direction (Up/Down/Left/Right) and Fire buttons\n- **Bits 5-7**: Always read as 0\n\n### Mega Drive (MD) Controllers\n- **Full 6-button support** for compatible controllers\n- **Additional buttons**: A, B, C, Start mapped to upper bits\n- **Core 3.1.4+**: X/Y/Z/Mode buttons not read by FPGA\n\n## Important Notes\n\n### Button Mapping Changes (Core 3.1.4+)\nSince core 3.1.4:\n- **Fire 1** is confirmed as \"B\" button (not \"C\" as some documentation stated)\n- **X/Y/Z/Mode buttons** of 6-button controllers are not read by the FPGA\n- Previous documentation mentioning \"C\" button for Fire 1 was incorrect\n\n### Software Compatibility\n**Important for non-programmers**: The Next board reads all available buttons (Fire1/B, Fire2/C, A, Start) and provides their state through this port, but this **does not guarantee software will respond** to extra buttons.\n\n#### Legacy Software Limitations\n- **Majority of legacy software** was designed for single fire button joysticks\n- **Fire 2 support** appeared very late in ZX Spectrum's lifecycle\n- **Multi-button support** requires specific game code or patches\n\n#### Modern Support Requirements\nFor full MD controller support, software needs:\n- **Explicit multi-button code** in new ZX Next productions\n- **Patched versions** of legacy games\n- **Awareness of extended button set** in game design\n\n## Usage Examples\n\n### Read Basic Joystick State\n```assembly\nIN A, ($1F)         ; Read joystick port\nAND %00011111       ; Mask off unused bits\n; Now test individual bits:\n; bit 0 = right, bit 1 = left\n; bit 2 = down, bit 3 = up, bit 4 = fire1\n```\n\n### Test Specific Directions\n```assembly\n; Check if moving right\nIN A, ($1F)\nBIT 0, A\nJR NZ, moving_right\n\n; Check if moving up\nIN A, ($1F)\nBIT 3, A\nJR NZ, moving_up\n\n; Check diagonal movement (up-right)\nIN A, ($1F)\nAND %00001001       ; Test up and right bits\nCP %00001001        ; Both pressed?\nJR Z, moving_up_right\n```\n\n### Test Fire Buttons\n```assembly\n; Test primary fire button (Fire 1/B)\nIN A, ($1F)\nBIT 4, A\nJR NZ, fire1_pressed\n\n; Test secondary fire button (Fire 2/C)\nIN A, ($1F)\nBIT 5, A\nJR NZ, fire2_pressed\n```\n\n### Test MD Controller Extra Buttons\n```assembly\n; Test A button (MD controllers)\nIN A, ($1F)\nBIT 6, A\nJR NZ, a_button_pressed\n\n; Test Start button (MD controllers)\nIN A, ($1F)\nBIT 7, A\nJR NZ, start_pressed\n```\n\n### Complete Button Reading\n```assembly\njoystick_read:\n    IN A, ($1F)         ; Read full joystick state\n    LD B, A             ; Store in B for processing\n    \n    ; Test directions\n    BIT 0, B\n    CALL NZ, handle_right\n    BIT 1, B  \n    CALL NZ, handle_left\n    BIT 2, B\n    CALL NZ, handle_down\n    BIT 3, B\n    CALL NZ, handle_up\n    \n    ; Test fire buttons\n    BIT 4, B\n    CALL NZ, handle_fire1\n    BIT 5, B\n    CALL NZ, handle_fire2\n    \n    ; Test MD extra buttons\n    BIT 6, B\n    CALL NZ, handle_a_button\n    BIT 7, B\n    CALL NZ, handle_start\n    \n    RET\n```\n\n## Joystick Configuration\n\n### Port Assignment\nJoysticks can be configured via:\n- [Peripheral 1 Register](peripheral_1_register.md) ($05) - Basic joystick mode selection\n- **NMI Menu**: Settings → Joysticks for hardware configuration\n- **Boot Menu**: Joystick port configuration\n\n### Supported Controller Types\n- **Standard Kempston** joysticks (5 inputs: 4 directions + 1 fire)\n- **Mega Drive** 3-button controllers\n- **Mega Drive** 6-button controllers (partial support)\n- **Compatible** third-party controllers\n\n## Programming Guidelines\n\n### Multi-Button Game Design\n```assembly\n; Example: Game with multiple actions\ncheck_buttons:\n    IN A, ($1F)\n    \n    ; Primary actions (all games should support)\n    BIT 4, A            ; Fire 1/B - primary action\n    CALL NZ, primary_fire\n    \n    ; Secondary actions (enhanced games)\n    BIT 5, A            ; Fire 2/C - secondary action  \n    CALL NZ, secondary_fire\n    BIT 6, A            ; A button - special action\n    CALL NZ, special_action\n    BIT 7, A            ; Start - pause/menu\n    CALL NZ, pause_game\n    \n    RET\n```\n\n### Legacy Compatibility\n```assembly\n; Ensure compatibility with single-button games\nlegacy_fire_check:\n    IN A, ($1F)\n    AND %00010000       ; Test only Fire 1/B button\n    RET Z               ; Return if not pressed\n    ; Handle fire button press\n    CALL fire_action\n    RET\n```\n\n## Related Ports\n\n- [Kempston Joystick 2, Joystick I/O](kempston_joystick_2_joystick_io.md) ($xx37) - Secondary joystick\n- [Peripheral 1 Register](peripheral_1_register.md) ($05) - Joystick mode configuration  \n- [Extended MD Pad Buttons](extended_md_pad_buttons.md) ($B2) - Additional MD button reading\n\n## Hardware Notes\n\n### Connection Types\n- **DB9 connector** standard for most controllers\n- **Mega Drive controllers** directly compatible\n- **Adapters available** for other controller types\n\n### Button Response\n- **Immediate response** - no polling required\n- **Hardware debouncing** handled by controller\n- **Multiple buttons** can be pressed simultaneously\n\n## Compatibility Matrix\n\n| Controller Type | Directions | Fire 1 | Fire 2 | A | Start | X/Y/Z/Mode |\n|-----------------|------------|---------|---------|---|-------|------------|\n| Standard Kempston | ✓ | ✓ | ✗ | ✗ | ✗ | ✗ |\n| MD 3-button | ✓ | ✓ | ✓ | ✓ | ✓ | ✗ |\n| MD 6-button | ✓ | ✓ | ✓ | ✓ | ✓ | ✗* |\n\n*X/Y/Z/Mode buttons not read by FPGA since core 3.1.4",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SETUPIM": {
    "content": "# SETUPIM\r\n\r\n## Syntax\r\n\r\n```\r\nSetUpIM()\r\n```\r\n\r\n## Description\r\n\r\nUsed to initialise a ProTracker 3 ``(.pt3)`` file to be played back on interrupt, that is updated once per frame **(@50 / 60 Hz)**. \r\n\r\nThe commannd [SetUpIM()](SetUpIM.md) will automatically set up a system interrupt, call a replyer code to play back the music. Bundled with the player is also a version of Shiru's `AYFXEngine`. First you need to load in the binaries into your chosed banks:\r\n\r\n\t' -- Loadblock\r\n\tLoadSDBank(\"[]vt24000.bin\",0,0,0,38)\t\t' load the music replayer into bank 38\r\n\tLoadSDBank(\"[]music1.pt3\",0,0,0,39)\t\t\t' load music.pt3 into 39\r\n\tLoadSDBank(\"[]game.afb\",0,0,0,41)\t\t\t' load sfx into bank 41\r\n\r\nNote the **[]** before the filename tells NBS to load the file from the system assets stored in `Scripts/system_data`. Once these are loaded you can run the initialisation code:\r\n\r\n\t' --\r\n\tInitSFX(41)\t\t\t\t\t' init the SFX engine, sfx are in bank 41\r\n\tInitMusic(38,39,0000)\t\t' init the music engine 38 has the player, 39 the pt3, 0000 offset\r\n\tSetUpIM()\t\t\t\t\t' init the IM2 code\r\n\tEnableSFX\t\t\t\t\t' Enables the AYFX, use DisableSFX to top\r\n\tEnableMusic\t\t\t\t\t' Enables Music, use DisableMusic to stop\r\n\r\nWhen you want to play an `AYFX` use the [PlaySFX()](PlaySFX.md) command: \r\n\r\n\tPlaySFX(n)\t\t\t\t\t\r\n\r\nThe `Interrupt Vector` is automatically generated at the start of your code, just after the HEAP and is stored in the library section of the final code. This is aligned to the nearest 256 boundary, because your interrupt vector table should always start on an ALIGNed address e.g : ``$fd00`` - All this is done automatically by the [InitMusic()](InitMusic.md) command.   \r\n\r\n## Requires:\r\n```\r\n#DEFINE IM2\r\n#INCLUDE <nextlib.bas>\r\n#INCLUDE <nextlib_ints.bas>  \r\n```\r\n\r\n## Links \r\n\r\n- [InitMusic()](InitMusic.md)\r\n- [InitSFX()](InitSFX.md)\r\n- [PlaySFX()](PlaySFX.md)\r\n- [SetUpIM()](SetUpIM.md)\r\n- [EnableSFX()](EnableSFX.md)\r\n- [EnableMusic()](EnableMusic.md)\r\n- [DisableSFX()](DisableSFX.md)\r\n- [DisableMusic()](DisableMusic.md)\r\n- [LoadSDBank()](LoadSDBank.md)",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LOADBMP": {
    "content": "# LoadBMP(filename)\r\n\r\n## Syntax\r\n\r\n```\r\nLoadBMP(filename)\r\n```\r\n\r\n## Description\r\n\r\nLoads a bitmap file from the filesystem, directly into the screen buffer. The image will be automatically flipped vertically, this is because of the odd way BMP files are stored with a negative height. This is a very simplistic way to load an image into the screen buffer, and probably best to load the converted `.nxi` into a bank then point Layer2 RAM to it.\r\n\r\n**Examples**\r\n\r\nTo load a file called \"myscreen.bmp\" into the screen buffer. \r\n\r\n```\r\nLoadBMP(\"myscreen.bmp\")\r\n```\r\n\r\n**Example using LoadSDBank()**\r\n\r\n```\r\nInitLayer2(MODE256X192)   \t \r\nLoadSDBank(\"sanity_1_exported_256.nxi\",0,0,0,38)             ' load the image into bank 38\r\nNextReg(LAYER2_RAM_BANK_NR_12,38>>1)                         ' set the layer2 ram bank to 38\r\nShowLayer2(TRUE)                                             ' show the layer2\r\n```\r\nBecause memory banks are 8KB in size, [LAYER2_RAM_BANK_NR_12](LAYER2_RAM_BANK_NR_12.md) uses 16KB paging which is why we need to halve the bank number with `>>1`.\r\n\r\n**Remarks**\r\n\r\nIf you want to load larger files consider using **LoadSDBank()**\r\n\r\n**Links**\r\n\r\n- [Layer2RamBanks](LAYER2_RAM_BANK_NR_12.md)\r\n- [LoadSDBank()](LoadSDBank.md)\t\r\n- [SaveSD()](SaveSD.md)\r\n- [SaveSDBank()](SaveSDBank.md)",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LOADSD": {
    "content": "# LoadSD\r\n\r\n## Syntax\r\n\r\n```\r\nLoadSD(\"filenname\",address,size,offset)\r\n```\r\n\r\n## Description\r\n\r\nLoads a file from the filesystem. Size must be specified if the size is unknown you can use a size to set the maximum amount of data you want to load. Offset is how many bytes to skip from the start of the file.\r\n\r\n**Examples**\r\n\r\nTo load a file called \"myscreen.scr\" into memory address $4000 with the length of 6912 bytes. \r\n\r\n\tLoadSD(\"myfile.scr\",$4000,6912,0)\r\n\r\nTo load the second 4kb from file \"test.dat\"\r\n\r\n\tLoadSD(\"test.dat\",$4000,4096,4096)\r\n\r\n**Remarks**\r\n\r\nIf you want to load larger files consider using **LoadSDBank()**\r\n\r\n**Links**\r\n\r\n- [LoadSDBank()](LoadSDBank.md)\t\r\n- [SaveSD()](SaveSD.md)\r\n- [SaveSDBank()](SaveSDBank.md)",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LOADSDBANK": {
    "content": "# LoadSDBank\r\n\r\n## Syntax\r\n\r\n```\r\nLoadSDBank(\"filenname\",nn,ss,oo,b)\r\n\r\nnn = address (0000-1fff) offset in bank\r\nss = size to load \r\noo = offset into file \r\nb  = bank to start \r\n```\r\n\r\n## Description\r\n\r\nLoadSDBank() can load files of any size (depending on RAM available) into the ZX Next's RAM banks. \r\nThe routine will handle all required paging and loading, normally a startbank is all that is required.\r\n\r\n- filename = filename to load\r\n- address = 0 to $1fff and would be an offset into the start bank\r\n- size = amount of data to load, 0 will the entire file.\r\n- offset = Skip offset from the start of the file\r\n- startbank = start 8kb bank\r\n\r\n**Examples**\r\n\r\nLoad \"mytiles.til\" which is 16kb into bank 34 and 35\r\n\r\n\tLoadSDBank(\"mytiles.til\",0,0,0,34)\r\n\r\nTo load the second 4kb from a file into bank 10\r\n\r\n\tLoadSDBank(\"test.dat\",0,4096,4096,10)\r\n\r\nLoad a100kb file into banks 40 on onwards\r\n\r\n\tLoadSDBank(\"monty.mod\",0,0,0,40)\r\n\r\nWhen used with #DEFINE NEX the routine will become a macro and data will be included inside of the\r\nNEX creating a self contained file. When this happens LoadSDBanks commands will be ignored, you can \r\nuse LoadSD() or LoadSDBankRes() for loading once the application has started. \r\n\r\n**Remarks**\r\n\r\nLoadSDBank is the way to store all your datafiles inside a finalized NEX file. Make sure you use \r\n#DEFINE NEX before #INCLUDE <nextlib.bas> to disable the code for LoadSDBank.\r\n\r\n**Links**\r\n\r\n- [LoadSD()](LoadSD.md)\t\r\n- [SaveSDBank()](SaveSDBank.md)\r\n- [SaveSD()](SaveSD.md)",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SAVESD": {
    "content": "# SaveSD\r\n\r\n## Syntax\r\n\r\n```\r\nSaveSD(\"filenname\",address,size)\r\n```\r\n\r\n## Description\r\n\r\nSaves a file from memory to the filesystem. Size must be specified if the size is unknown you can use a size to set the maximum amount of data you want to load `0-65535`. Obviously the realistic size of the file you will want to save will be less than this.\r\n\r\n**Examples**\r\n\r\nTo save a file called \"myscreen.scr\" from memory address `$4000/16384` with the length of `$1b00/6912` bytes. \r\n\r\n\tSaveSD(\"myfile.scr\",$4000,6912)\r\n\r\n**Remarks**\r\n\r\nIf you want to save larger files consider using **SaveSDBank()**\r\n\r\n**Links**\r\n\r\n- [SaveSDBank()](SaveSDBank.md)\r\n- [LoadSD()](LoadSD.md)\t\r\n- [LoadSDBank()](LoadSDBank.md)\r\n\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CIRCLE2": {
    "content": "# Circle2(x, y, radius, colour)\r\n\r\n## Syntax\r\n\r\n```\r\nCircleL2(x [0-255], y [0-191], radius [0-255] , colour [0-255])\r\n```\r\n\r\n## Description\r\n\r\nDraws a circle on Layer 2 with the specified colour. Currently this command will only work correctly with 256x192. \r\n\r\n**Example**\r\n\r\n```\r\n#INCLUDE <nextlib.bas>\r\nInitLayer2(MODE256x192)\r\nClipLayer2(0,255,0,255)\r\nWaitKey() : END \r\n```\r\n**Remarks**\r\n\r\nThis command is a shortcut configuring [CLIP_LAYER2_NR_18](CLIP_LAYER2_NR_18) 4 times. \r\n\r\nRequires: \r\n\r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n\r\n## Links \r\n\r\n[Index](Index.md)\r\n\r\n\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CLEARLAYER2": {
    "content": "# ClearLayer2(nColour)\r\n\r\n## Syntax\r\n\r\n```\r\nClearLayer2(nColour)\r\n```\r\n\r\n## Description\r\n\r\nClears Layer2 with colour n. This routine will take the screen mode set by [InitLayer2](INITLAYER2.md). \r\n\r\n**Example**\r\n\r\n```\r\nInitLayer2(MODE320X256)     ' Set screen mode to 320x256\r\nClearLayer2($ff)            ' Clear Layer2 with palette index $ff, default is white.\r\nShowLayer2(TRUE)            ' Show Layer2\r\n```\r\n\r\n## See also\r\n\r\n* [InitLayer2()](INITLAYER2.md)\r\n* [ShowLayer2()](SHOWLAYER2.md)\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CLIPLAYER2": {
    "content": "# ClipLayer2(x1, x2, y1, y2)\r\n\r\n## Syntax\r\n\r\n```\r\nClipLayer2(x1, x2, y1, y2)\r\n```\r\n\r\n## Description\r\n\r\nSets the visible clip area of Layer2.\r\n\r\n**Example**\r\n\r\nClip Layer2 to maximum visible size :\r\n\r\n```\r\nClipLayer2(0,255,0,255)\r\n```\r\n**Remarks**\r\n\r\nThis command is a shortcut configuring [CLIP_LAYER2_NR_18](CLIP_LAYER2_NR_18) 4 times. \r\n\r\nRequires: \r\n\r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n\r\n## Links \r\n\r\n[Index](Index.md)\r\n\r\n\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CLIPSPRITE": {
    "content": "# CLIPSPRITE(x1, x2, y1, y2)\r\n\r\n## Syntax\r\n\r\n```\r\nClipSprite(x1, x2, y1, y2)\r\n```\r\n\r\n## Description\r\n\r\nSets the visible clip area of Layer2.\r\n\r\n**Example**\r\n\r\nClip Sprites window to maximum visible size :\r\n\r\n```\r\nClipSprite(0,255,0,255)\r\n```\r\n**Remarks**\r\n\r\nThis command is a shortcut configuring [CLIP_SPRITE_NR_19](CLIP_SPRITE_NR_19) 4 times. \r\n\r\nRequires: \r\n\r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n\r\n## Links \r\n\r\n[Index](Index.md)\r\n\r\n\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CLIPTILE": {
    "content": "# CLIPTILE\r\n\r\n## Syntax\r\n\r\n```\r\nClipTile(x1, x2, y1, y2)\r\n```\r\n\r\n## Description\r\n\r\nSets the visible clip area of Tilemap layer. \r\n\r\n**Example**\r\n\r\nClip Tilempa window to maximum visible size :\r\n\r\n```\r\nClipTile(0,255,0,255)\r\n```\r\n\r\n**Remarks**\r\n\r\nThis command is a shortcut configuring [CLIP_TILEMAP_NR_1B](CLIP_TILEMAP_NR_1B) 4 times. \r\n\r\n## Requires:\r\n\r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n\r\n## Links \r\n\r\n[Index](Index.md)",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CLIPULA": {
    "content": "# CLIPULA\r\n\r\n## Syntax\r\n\r\n```\r\nClipULA(x1, x2, y1, y2)\r\n```\r\n\r\n## Description\r\n\r\nSets the visible clip area of ULA layer. \r\n\r\n**Example**\r\n\r\nClip ULA window to maximum visible size :\r\n\r\n```\r\nClipULA(0,255,0,255)\r\n```\r\n\r\n**Remarks**\r\n\r\nThis command is a shortcut configuring [CLIP_ULA_LORES_NR_1A](CLIP_ULA_LORES_NR_1A.md) 4 times. \r\n\r\n## Requires:\r\n\r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n\r\n## Links \r\n\r\n[Index](Index.md)",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CLS256": {
    "content": "# CLS256 {deprecated}\r\n\r\n## Syntax\r\n\r\n```\r\nCLS256(n ubyte)\r\n```\r\n\r\n## Description\r\n\r\nClears Layer2 256x192 mode with colour n. This will not properly clear 320x256 Layer 2, If you are in 320x256 mode \r\nyou should use:\r\n\r\n\tCLS320(n)\r\n\r\n> **NOTE**: This command has been deprcated and replaced with the more flexible [ClearLayer2(nColour)](CLEARLAYER2.md )\r\n\r\n## See also\r\n\r\n* [InitLayer2()](INITLAYER2.md)\r\n\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DOTILE8": {
    "content": "# DOTILE8 (DEPRECATED)\r\n\r\n## Syntax\r\n\r\n```\r\nDoTile8(byVal X as ubyte, byval Y as ubyte, byval T as ubyte)\r\n```\r\n\r\n## Description\r\n\r\nDraws a ``software`` 8x8pixel tile, starting from ``$c000`` on to Layer2 256x192 using 256 colours. The x and y coordinates are in a grid of `0-31` for x and `0-23` for y respectively.\r\n\r\n### NOTICE \r\n\r\nThis is a deprecated routine. Use [DoTileBank8](DoTileBank8.md) instead. This routine is still available for backwards compatibility, but is woefully inefficient due to the requirement of having to page in the tiles to ``$c000``, which will limit your available memory.\r\n\r\n**Examples**\r\n\r\n```\t\r\ndim tile as ubyte = 20 \r\ndim bank as ubyte = 34\r\ndim x, y as ubyte \r\nx = 10 : y = 10 \r\n\r\nLoadSDBank(\"my8x8.spr\",0,0,0,34) \t' Load tiles to bank 34\r\nNextRegA($57,34)                    ' Set MMU7 $c000 to bank 34\r\nDoTile8(x,y,tile)                   ' Draw tile 20 at 10,10 from $c000\r\nNextRegA($57,1)                     ' Restore MMU7 $c000 to bank 1\r\n\r\n```\r\n[DoTile8](DoTile8.md)\r\n[DoTileBank8](DoTileBank8.md)\r\n[LoadSDBank](LoadSDBank.md)\r\n[Graphics](_graphics.md)\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DOTILEBANK16": {
    "content": "# DOTILEBANK16\r\n\r\n## Syntax\r\n\r\n```\r\nDoTileBank16(x 0-19,y 0-15,tile id 0 - 255, bank)\r\n```\r\n\r\n## Description\r\n\r\nDraws a ``software`` 16x16pixel tile, starting from ``bank`` on to Layer2 256x192 using 256 colours. This routine will handle all paging requirements automatically. The x and y coordinates are in a grid of `0-19` for x and `0-15` for y respectively. The maximum number of tiles is 256.\r\n\r\n**Examples**\r\n\r\n\r\n```\t\r\ndim tile as ubyte = 20 \r\ndim bank as ubyte = 34\r\ndim x, y as ubyte \r\nx = 10 : y = 10 \r\n\r\nLoadSDBank(\"my16x16.spr\",0,0,0,34) \t' Load tiles to bank 34\r\nDoTileBank16(x,y,tile,bank) \t\t' Draw tile 20 at 10,10 from bank 34\r\n```\r\n[DoTile8](DoTile8.md)\r\n[DoTileBank8](DoTileBank8.md)\r\n[LoadSDBank](LoadSDBank.md)\r\n[Graphics](_graphics.md)\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DOTILEBANK8": {
    "content": "# DOTILEBANK8\r\n\r\n## Syntax\r\n\r\n```\r\nDoTileBank8(x 0-31,y 0-23,tile id 0 - 255, bank)\r\n```\r\n\r\n## Description\r\n\r\nDraws a ``software`` 8x8pixel tile, starting from ``bank`` on to Layer2 256x192 using 256 colours. This routine will handle all paging requirements automatically. The x and y coordinates are in a grid of `0-31` for x and `0-23` for y respectively. The maximum number of tiles is 256.\r\n\r\n**Examples**\r\n\r\n```\t\r\ndim tile as ubyte = 20 \r\ndim bank as ubyte = 34\r\ndim x, y as ubyte \r\nx = 10 : y = 10 \r\n\r\nLoadSDBank(\"my8x8.spr\",0,0,0,34) \t' Load tiles to bank 34\r\nDoTileBank8(x,y,tile,bank) \t\t    ' Draw tile 20 at 10,10 from bank 34\r\n```\r\n[DoTile8](DoTile8.md)\r\n[DoTileBank8](DoTileBank8.md)\r\n[LoadSDBank](LoadSDBank.md)\r\n[Graphics](_graphics.md)\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "FDOTILE16": {
    "content": "# FDOTILE16\r\n\r\n## Syntax\r\n\r\n```\r\nFDoTile16(tile id,x 0-19,y 0-15, bank)\r\n```\r\n\r\n## Description\r\n\r\nDraws an ``software`` 16x16pixel tile from ``bank`` on to Layer2 320x256 in 256 colours. This routine will handle all paging requirements automatically. The x and y coordinates are in a grid of `0-19` for x and `0-15` for y respectively.\r\n\r\n**Examples**\r\n\r\n```\r\ndim tile as ubyte = 20 \r\ndim bank as ubyte = 34\r\ndim x, y as ubyte \r\nx = 10 : y = 10 \r\n\r\nLoadSDBank(\"my16x16.spr\",0,0,0,34) \t' Load tiles to bank 34\r\nFDoTile16(tile,x,y,bank) \t\t\t' Draw tile 20 at 10,10 from bank 34\r\n```\r\n\r\n[FDoTile8](FDoTile8.md)\r\n[LoadSDBank](LoadSDBank.md)\r\n[Graphics](_graphics.md)\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "FDOTILE8": {
    "content": "# FDOTILE8\r\n\r\n## Syntax\r\n\r\n```\r\nFDoTile8(tile id,x 0-39,y 0-31,bank)\r\n```\r\n\r\n## Description\r\n\r\nDraws an ``software`` 8x8pixel tile from \"bank\" on to Layer2 320x256 in 256 colours. This routine will handle all paging requirements automatically. The x and y coordinates are in a grid of `0-39` for x and `0-31` for y respectively.\r\n\r\n**Examples**\r\n\r\n```\r\ndim tile as ubyte = 20 \r\ndim bank as ubyte = 34\r\ndim x, y as ubyte \r\nx = 10 : y = 10 \r\n\r\nLoadSDBank(\"my8x8.spr\",0,0,0,34) \t' Load tiles to bank 34\r\nFDoTile8(tile,x,y,bank) \t\t\t' Draw tile 20 at 10,10 from bank 34\r\n```\r\n\r\n[FDoTile16](FDoTile16.md)\r\n[LoadSDBank](LoadSDBank.md)\r\n[Graphics](_graphics.md)\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "FL2TEXT": {
    "content": "# FL2Text(x,y,string,bank)\r\n\r\n## Syntax\r\n\r\n```\r\nFL2Text(x, y, string, bank)\r\n```\r\n\r\n## Description\r\n\r\nDraws a string of text using a bitmap 8x8 256 colour font in \"bank\" on to Layer2 set to 320x256 mode. For 256x192 use [L2Text()](L2Text.md) instead.\r\n\r\n**Example**\r\n\r\nLoad a font and print some text on Layer2 320x256\r\n\r\n```\r\nInitLayer2(MODE320X256)\t\t                ' set layer2 to 320x256 mode\t\r\nLoadSDBank(\"[]font3.spr\",0,0,0,34) \t\t\t' load a font from the system assets into bank 34\r\nFL2Text(0,0,\"HELLO NEXTBUILD\",34)\r\nDO : LOOP\r\n```\r\n\r\n**Remarks**\r\n\r\nNote the use of [] in the filename, this tells the compiler to load the font from the system assets. There are around 1-25 fonts supplied in the system assets and can be loaded with [LoadSDBank()](LoadSDBank.md) and file names like `[]font3.spr`.\r\n\r\n## Links\r\n\r\n- [L2Text()](L2Text.md)\r\n- [LoadSDBank()](LoadSDBank.md)\r\n- [NextReg()](NextReg.md)\r\n- [NextRegA()](NextRegA.md)\r\n\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INITLAYER2": {
    "content": "# InitLayer2\r\n\r\n## Syntax\r\n\r\n```\r\nInitLayer2(SCREEN_MODE)\r\n```\r\n\r\n## Description\r\n\r\nIntialises Layer 2 in one of the following modes:\r\n\r\n- MODE256X192\r\n- MODE320X256\r\n- MODE640X256\r\n\r\nThis command takes care of setting up the screen mode and clearing to colour 0 (usually black). A list of registers can be \r\n\r\n**Examples**\r\n```\r\n#DEFINE LAYER2\r\n#INCLUDE <nextlib.bas>\r\nInitLayer2(MODE320X256)\t\t\t\t\t' initialise 320 x 256 x 256 Colours\r\nShowLayer2(TRUE)\t\t\t\t\t    ' enable Layer2\r\n```\r\n\r\n## Links\r\n\r\n* [Layer2](_Layer2.md)\r\n* [ShowLayer2](ShowLayer2.md)\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INITSPRITES": {
    "content": "# InitSprites(nr, address)\r\n\r\n## Syntax\r\n\r\n```\r\nInitSprites(*nr*,*address*)\r\n```\r\n\r\n## Description\r\n\r\nUsed to upload sprite data from *address* to sprite ram. It is recommended to use [InitSprites2()](InitSprites2.md) instead.\r\n\r\n**Example**\r\n```\r\n' Say we want to upload 64 sprites with the data at $c000\r\nInitSprites(63,$c000)\r\n```\r\nOnce upload the data in ram can be discarded. \r\n\r\n## Links \r\n\r\n- [InitSprites2()](InitSprites2.md)\r\n- [UpdateSprite()](UpdateSprite.md)\r\n- [NextRegister](_registers.md)\r\n- [NextReg()](NextReg.md)\r\n- [NextRegA()](NextRegA.md)\r\n\r\n\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "INITSPRITES2": {
    "content": "# InitSprites2(nr, address, bank)\r\n\r\n## Syntax\r\n\r\n```\r\nInitSprites2(nr, address, bank)\r\n```\r\n\r\n## Description\r\n\r\nUsed to upload sprite data from a bank with offset *address* to sprite ram. This routine takes a bank number as an argument, which will be used to upload the data to sprite ram. This routine manages the memory paging for you.\r\n\r\nThe routine will page in the banks to slots 0 & 1 ``$0000-$3FFF``, then upload to the data to the sprite ram, then restore the default banks.\r\n\r\nYou can leave *address* as 0 to upload to upload from the start of the specified bank.\r\n\r\n**Example**\r\n\r\n```\r\n' Say we want to upload 64 sprites with the data at $c000 (bank 1 is in slot 7 by default)\r\nInitSprites2(63,$c000,1)\r\n```\r\n\r\n```\r\n' Upload 64 sprites from bank 38 \r\nInitSprites2(63,0,38)\r\n```\r\n\r\nOnce upload the data in ram can be discarded\r\n\r\n## Links \r\n\r\n- [InitSprites()](InitSprites.md)\r\n- [UpdateSprite()](UpdateSprite.md)\r\n- [NextRegister](_registers.md)\r\n- [NextReg()](NextReg.md)\r\n- [NextRegA()](NextRegA.md)\r\n\r\n\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "L2TEXT": {
    "content": "# L2Text(x,y,string,bank,colour mask)\r\n\r\n## Syntax\r\n\r\n```\r\nL2Text(x, y, string, bank, colour mask)\r\n```\r\n\r\n## Description\r\n\r\nDraws a string of text using a bitmap 8x8 256 colour font in `bank` on to Layer2 set to 256x192 mode. For 320x256 use [FL2Text()](FL2Text.md) instead.\r\n\r\n**Example**\r\n\r\nLoad a font and print some text on Layer2 256x192\r\n```\r\n#INCLUDE <nextlib.bas> \r\nLoadSDBank(\"[]font3.spr\",0,0,0,34) \t\t\t' load a font from the system assets into bank 34\r\nL2Text(0,0,\"HELLO NEXTBUILD\",34)\r\nDO : LOOP\r\n```\r\n\r\n**Remarks**\r\n\r\nNote the use of [] in the filename, this tells the compiler to load the font from the system assets. There are around 1-25 fonts supplied in the system assets and can be loaded with [LoadSDBank()](LoadSDBank.md) and file names like `[]font3.spr`.\r\n\r\n## Links\r\n\r\n- [InitLayer2()](InitLayer2.md)\r\n- [ShowLayer2()](ShowLayer2.md)\r\n- [LoadSDBank()](LoadSDBank.md)\r\n\r\n\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LAYER_2_ACCESS_PORT": {
    "content": "# Layer 2 Access Port ($123B)\r\n\r\n## Port Information\r\n\r\n| Property | Value |\r\n|----------|-------|\r\n| **Port Number** | $123B |\r\n| **Decimal** | 4667 |\r\n| **Bit Mask** | %0001 0010 0011 1011 ?? |\r\n| **Readable** | Yes |\r\n| **Writable** | Yes |\r\n| **Subsystem** | Layer 2 |\r\n\r\n## Description\r\n\r\nEnables Layer 2 and controls paging of layer 2 screen into lower memory.\r\n\r\n## Port Data Format\r\n\r\n### Read or Write-with-bit-4-zero (soft reset = 0)\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| **7-6** | **Video RAM bank select (write/read paging)** |\r\n|  | 00 = first 16K of layer 2 in the bottom 16K |\r\n|  | 01 = second 16K of layer 2 in the bottom 16K |\r\n|  | 10 = third 16K of layer 2 in the bottom 16K |\r\n|  | 11 = first 48K of layer 2 in the bottom 48K (since core 3.0) |\r\n| **5** | Reserved, write 0 |\r\n| **4** | 0 |\r\n| **3** | 0 = map [Layer 2 RAM Page Register](layer_2_ram_page_register.md) ($12), 1 = map [Layer 2 RAM Shadow Page Register](layer_2_ram_shadow_page_register.md) ($13) |\r\n| **2** | Enable mapping for memory reads |\r\n| **1** | Layer 2 visible - [Layer 2 RAM Page Register](layer_2_ram_page_register.md) ($12)<br/>Since core 3.0 this bit has mirror in [Display Control 1 Register](display_control_1_register.md) ($69) |\r\n| **0** | Enable mapping for memory writes |\r\n\r\n### Write-with-bit-4-set (since core 3.0.7) (soft reset = 0)\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| **7-5** | Reserved, write 0 |\r\n| **4** | 1 |\r\n| **3** | Reserved, write 0 |\r\n| **2-0** | 16ki bank relative offset (+0 .. +7) applied to Layer 2 memory mapping |\r\n\r\n## Layer 2 Memory Mapping\r\n\r\n### Basic Mapping Modes\r\n\r\nThe Layer 2 screen can be mapped into the Z80's address space for direct memory access:\r\n\r\n- **Bits 7-6** select which portion of Layer 2 RAM to map\r\n- **Bit 0** enables write access to the mapped area\r\n- **Bit 2** enables read access to the mapped area\r\n- **Bit 3** selects between main ($12) and shadow ($13) Layer 2 banks\r\n\r\n### Display vs Memory Mapping\r\n\r\n**Important**: The Layer 2 data being displayed are always driven by [Layer 2 RAM Page Register](layer_2_ram_page_register.md) ($12). The \"shadow\" register $13 affects only the memory mapping feature (when bit 3 is set), never the display data. To \"flip\" the data being displayed, write new bank value into register $12.\r\n\r\n## Bank Offset Feature (Core 3.0.7+)\r\n\r\nThe bit 4 = 1 functionality was added in core 3.0.7 together with new Layer 2 display modes:\r\n\r\n### Usage Pattern\r\n1. Set up initial mapping like `%00'00'??'1'?` or `%11'00'??'1'?` to map first bank into bottom 16ki or 48ki of memory\r\n2. Switch the mapped bank by writing relative offset value 0..7 to the port with bit 4 set\r\n3. Example: `%0001'0011` modifies mapping to start with fourth (+3) bank of Layer 2\r\n\r\n### Extended Mode Support\r\n- Original mapping covered only first three banks (256x192 Layer 2 mode)\r\n- New Layer 2 modes 320x256x8bpp and 640x256x4bpp occupy full five 16kiB banks\r\n- Relative offsetting allows access to any of the five banks even with \"first bank into bottom 16ki\" mapping\r\n\r\n## Usage Examples\r\n\r\n### Enable Layer 2 Display\r\n```assembly\r\nLD A, %00000010     ; Enable Layer 2 visibility\r\nLD BC,$123B\r\nOUT (C),A\r\n```\r\n\r\n### Map First 16K for Writing\r\n```assembly\r\nLD A, %00000001     ; Map first 16K, enable write\r\nLD BC,$123B\r\nOUT (C),A\r\n; Now write to $0000-$3FFF to access Layer 2\r\n```\r\n\r\n### Map Second 16K for Read/Write\r\n```assembly\r\nLD A, %01000101     ; Map second 16K, enable read+write\r\nLD BC,$123B\r\nOUT (C),A\r\n; Access second third of Layer 2 at $0000-$3FFF\r\n```\r\n\r\n### Map Full 48K (Core 3.0+)\r\n```assembly\r\nLD A, %11000001     ; Map all 48K, enable write\r\nLD BC,$123B\r\nOUT (C),A\r\n; Access entire Layer 2 at $0000-$BFFF\r\n```\r\n\r\n### Use Shadow Bank for Mapping\r\n```assembly\r\nLD A, %00001001     ; Map shadow bank, enable write\r\nLD BC,$123B\r\nOUT (C),A\r\n; Write to shadow bank while display shows main bank\r\n```\r\n\r\n### Set Bank Offset (Core 3.0.7+)\r\n```assembly\r\n; First set up base mapping\r\nLD A, %00000001     ; Map first bank, enable write\r\nLD BC,$123B\r\nOUT (C),A\r\n\r\n; Then set offset to access 4th bank\r\nLD A, %00010011     ; Bit 4 set, offset +3\r\nLD BC,$123B\r\nOUT (C),A\r\n; Now $0000-$3FFF accesses 4th Layer 2 bank\r\n```\r\n\r\n## Layer 2 Display Modes\r\n\r\n### 256x192 Mode (Standard)\r\n- Uses 3 16KB banks (48KB total)\r\n- Each bank = 64 lines × 256 pixels\r\n- 1 byte per pixel (8-bit color)\r\n\r\n### 320x256 Mode (Core 3.0+)\r\n- Uses 5 16KB banks (80KB total)\r\n- 320×256 pixels\r\n- 1 byte per pixel (8-bit color)\r\n\r\n### 640x256 Mode (Core 3.0+)\r\n- Uses 5 banks (80KB total)  \r\n- 640×256 pixels\r\n- 4 bits per pixel (16 colors)\r\n\r\n## Important Notes\r\n\r\n### Memory Safety\r\n- **Always disable system interrupts** when changing Layer 2 mapping\r\n- **Original mapping** disabling writes will restore mapping to default\r\n- **Be careful with stack placement** when mapping to lower memory\r\n\r\n### Read/Write Control\r\n- **Bit 0**: Controls write access to mapped area\r\n- **Bit 2**: Controls read access to mapped area\r\n- **Both can be enabled simultaneously** for full read/write access\r\n\r\n### Core Version Dependencies\r\n- **Core 3.0**: Added 48K mapping mode (bits 7-6 = 11)\r\n- **Core 3.0.7**: Added bank offset feature (bit 4 = 1)\r\n\r\n## Related Registers\r\n\r\n- [Layer 2 RAM Page Register](layer_2_ram_page_register.md) ($12) - Controls displayed bank\r\n- [Layer 2 RAM Shadow Page Register](layer_2_ram_shadow_page_register.md) ($13) - Shadow bank for mapping\r\n- [Layer 2 Control Register](layer_2_control_register.md) ($70) - Display mode control\r\n- [Display Control 1 Register](display_control_1_register.md) ($69) - Layer 2 visibility mirror\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PALUPLOAD": {
    "content": "# PalUpload(address,nrOfColours,StartOffset,bank)\r\n\r\n## Syntax\r\n\r\n```\r\nPalUpload(address,nrOfColours,StartOffset,bank)\r\n```\r\n\r\n## Description\r\n\r\nUploads a 9-bit palette (2 bytes per colour) to the selected palette. The palette to upload to can be selected before you call the command like so\r\n```\r\nNextReg($43,%00010000) : REM palette select register for Layer2 first palette\r\nPalUpload(@palette,0,0) : REM upload from label \"palette\", 0 = full 256 colours, starting at index 0\r\nDO : LOOP : REM loop forever\r\npalette:\r\nasm\r\n\tincbin \"pal1.nxp\"\r\nend asm\r\n```\r\nThe palette select register is as follows https://wiki.specnext.dev/Enhanced_ULA_Control_Register\r\n\r\n\tBit\r\n\t7\t\t1 to disable palette index write auto-increment\r\n\t6-4\t\tSelect palette for writing\r\n\t3\t\tSelects Sprites palette (0=first,1 second)\r\n\t2\t\tSelects Layer 2 palette (0=first,1 second)\r\n\t0\t\tEnable ULANext mode if 1\r\n\r\nBits 6-4\r\n\r\n\t%000\tULA first\r\n\t%100\tULA second\r\n\t%001\tLayer 2 first\r\n\t%101\tLayer 2 second\r\n\t%010\tSprites first\r\n\t%110\tSprites Second\r\n\t%011\tTilemap first\r\n\t%111\tTilemap second\r\n\r\n**Remarks**\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PLOTL2": {
    "content": "# PlotL2(x,y,c)\r\n\r\n## Syntax\r\n\r\n```\r\nPlotL2(x, y, c)\r\n```\r\n\r\n## Description\r\n\r\nPlots a pixel at screen position x,y on Layer 2 using the colour index c\r\nx : 0 - 255 \r\ny : 0 - 191\r\nc : 0 - 255\r\n\r\n**Examples**\r\n\r\nPlotL2(10,10,255)\t\t\t\t; Plot white pixel at x,y\r\n\r\n## Links\r\n\r\n* [InitLayer2](InitLayer2)\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "REMOVESPRITE": {
    "content": "# RemoveSprite(sprite id,visibility)\r\n\r\n## Syntax\r\n\r\n```\r\nRemoveSprite(sprite id,0=off|1=on)\r\n```\r\n\r\n## Description\r\n\r\nRemove a sprite from the screen\r\n```\r\nRemoveSprite(0,1) : ' Remove sprite 0\r\n```",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SCROLLLAYER": {
    "content": "# ScrollLayer\r\n\r\n## Syntax\r\n\r\n```\r\nScrollLayer(x, y)\r\n```\r\n\r\n## Description\r\n\r\nScroll Layer 2 by x and y pixels. Valid values for x and y [0-255]. If you wish to scroll \r\n\r\n**Examples**\r\n```\r\nFor x = 0 to 254\r\n\tScrollLayer(x,0)\t\t\t\t; Scroll screen right\r\n\tWaitRaster(192)\t\t\t\t\t; wait for raster line 192\r\nNext x\r\n```\r\n\r\n## Links\r\n\r\n* [LAYER_2_X_OFFSET_REGISTER](LAYER_2_X_OFFSET_REGISTER.md)\r\n\r\n* [NextRegister](NextRegister)\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SHOWLAYER2": {
    "content": "# ShowLayer2(0=off|1=on)\r\n\r\n## Syntax\r\n\r\n```\r\nShowLayer2(0=off|1=on)\r\n```\r\n\r\n## Description\r\n\r\nShow or disable Layer2\r\n\r\n\tShowLayer(1) : ' Show Layer2\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SHOWSPRITES": {
    "content": "# ShowSprites(0=off|1=on)\r\n\r\n## Syntax\r\n\r\n```\r\nShowSprites(0=off|1=on)\r\n```\r\n\r\n## Description\r\n\r\nShow or disable sprites\r\n```\r\nShowSprites(1) : ' Show sprites\r\n```",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "UPDATESPRITE": {
    "content": "# UpdateSprite(x,y,sprite id, sprite image, attribute 3, attribute 4)\r\n\r\n## Syntax\r\n\r\n```\r\nUpdateSprite(x,y,sprite id, sprite image, attribute 3, attribute 4)\r\n```\r\n\r\n## Description\r\n\r\nUpdates a specified sprite according to its \"sprite id\". Sprites must first be upload to sprite ram. Once this has been done the UpdateSprite command can then be used to control the sprites.\r\n\r\n- Sprites can be full screen over the border, x int - x position 0 - 319\r\n- y as byte - y position 0 -255\r\n- sprite id = 0 - 127 sprites id\r\n- sprite image = image associate with the id\r\n- Sprite attribute 3\r\n- Sprite attribute 4\r\n\r\nSprite attributes 3 and 4 can control rotation, scaling, flipping, anchoring, and 4 bit mode. See [Sprites](Sprites.md) for more information.\r\n\r\n**Examples**\r\n\r\nLoad and show sprite id 0 with image 0, not that x / y position 0,0 is in the top left hand corner and behind the border until we places sprite on top.\r\n\r\n```\r\nInitSprites(8,@Sprites) : ' init 8 sprites from address label Sprite:\r\n' update sprite 0, using image 1 at x,y position 32,32, \r\nUpdateSprite(32,32,10,1,0,0) \r\n```\r\n\r\n\r\n**Remarks**\r\n\r\n## Links \r\n\r\n- [InitSprites()](InitSprites.md)\r\n- [InitSprites2()](InitSprites2.md)",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "WAITRASTER": {
    "content": "# WaitRaster\r\n\r\n## Syntax\r\n\r\n```\r\nWaitRaster(raster line)\r\n```\r\n\r\n## Description\r\n\r\nWaits for \"raster line\" before continuing. Use this for timing. \r\n\r\n**Example**\r\n```\r\n' Wait for raster line 192\r\nDO\r\n\tBORDER 2\r\n\tWaitRaster(192)\r\n\tBORDER 0\r\nLOOP\r\n```\r\n**Remarks**\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n\r\nUse instead of PAUSE 0\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "WAITRETRACE": {
    "content": "# WAITRETRACE\r\n\r\n## Syntax\r\n\r\n```\r\nWaitRetrace(nrOfFrames)\r\n```\r\n\r\n## Description\r\n\r\nWaits for rasterline 0 for a number of loops (nrOfTimes), ignores keypresses.\r\n\r\n**Example**\r\n\r\nTo use instead of **PAUSE 1**\r\n\r\n\tDO\r\n\t\tPRINT a\r\n\t\ta = a + 1\r\n\t\tWaitRetrace(1)\r\n\tLOOP\r\n\r\n**Remarks**\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n\r\nUse instead of PAUSE 1\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "WAITRETRACE2": {
    "content": "# WAITRETRACE2\r\n\r\n## Syntax\r\n\r\n```\r\nWaitRetrace2(nrOfFrames)\r\n```\r\n\r\n## Description\r\n\r\nThis command is deprecated, use [WaitRaster()](WaitRaster.md) instead.\r\nClassic Nextlib rasterline wait (nrOfFrames), ignores keypresses, doesn't disable interrupts.\r\n\r\n**Example**\r\n\r\nTo use instead of **PAUSE 1**\r\n\r\n\tDO\r\n\t\tPRINT a\r\n\t\ta = a + 1\r\n\t\tWaitRetrace2(1)\r\n\tLOOP\r\n\r\n**Remarks**\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n\r\nYou can now use WaitRaster() which is easier to read. \r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "_ADVANCEDSPRITES": {
    "content": "# ZX Spectrum Next Sprite Programming Guide\r\n\r\n## Table of Contents\r\n- [ZX Spectrum Next Sprite Programming Guide](#zx-spectrum-next-sprite-programming-guide)\r\n  - [Table of Contents](#table-of-contents)\r\n  - [Overview](#overview)\r\n  - [Notice](#notice)\r\n  - [Sprite Coordinate System](#sprite-coordinate-system)\r\n  - [Basic Sprite Setup](#basic-sprite-setup)\r\n    - [Sprite Attributes Structure](#sprite-attributes-structure)\r\n  - [Advanced Sprite Features](#advanced-sprite-features)\r\n    - [Palette Offset](#palette-offset)\r\n    - [Mirror and Rotate](#mirror-and-rotate)\r\n    - [Scaling](#scaling)\r\n  - [Big Sprites with Relative Sprites](#big-sprites-with-relative-sprites)\r\n  - [Code Examples](#code-examples)\r\n    - [Example 1: Basic Single Sprite](#example-1-basic-single-sprite)\r\n    - [Example 2: Animated Sprite](#example-2-animated-sprite)\r\n    - [Example 3: Big Sprite (2x2)](#example-3-big-sprite-2x2)\r\n    - [Example 4: Composite Relative Sprites](#example-4-composite-relative-sprites)\r\n    - [Example 5: Unified Big Sprite](#example-5-unified-big-sprite)\r\n  - [Tips and Best Practices](#tips-and-best-practices)\r\n  - [Common Patterns](#common-patterns)\r\n    - [Moving Platform (4 sprites)](#moving-platform-4-sprites)\r\n    - [Rotating Enemy](#rotating-enemy)\r\n\r\n## Overview\r\n\r\n## Notice \r\n\r\nThis page is a work in progress. It is not complete and may contain errors. For now, please refer to [https://wiki.specnext.dev/Sprites](https://wiki.specnext.dev/Sprites) for more information.\r\n\r\nThe ZX Spectrum Next sprite system provides hardware-accelerated sprites with:\r\n- 128 sprites total\r\n- 16×16 pixel sprites (can be scaled 2x, 4x, or 8x)\r\n- 8-bit (256 colors) or 4-bit (16 colors) patterns\r\n- Hardware rotation, mirroring, and scaling\r\n- Relative sprite system for complex objects\r\n\r\n## Sprite Coordinate System\r\n\r\nThe sprite coordinate system uses 9-bit values (0-511) with wrap-around:\r\n- **ULA Screen area**: Top-left at [32,32], bottom-right at [287,223]\r\n- **Over-border area**: Full visible area is [0,0] to [319,255]\r\n- **Wrap-around**: Position 511 acts as -1, 510 as -2, etc.\r\n\r\n```\r\n+---------------------------+\r\n| Border (32px)             |\r\n|   +-------------------+   |\r\n|   | ULA Screen        |   |\r\n|   | (256x192)         |   |\r\n|   | [32,32]-[287,223] |   |\r\n|   +-------------------+   |\r\n| [0,0] to [319,255]        |\r\n+---------------------------+\r\n```\r\n\r\n## Basic Sprite Setup\r\n\r\nTo display a sprite, you need to:\r\n1. Upload a pattern to sprite pattern memory\r\n2. Set sprite attributes (position, visibility, pattern)\r\n3. Enable sprite display\r\n\r\n### Sprite Attributes Structure\r\n\r\nEach sprite has 4-5 attribute bytes:\r\n\r\n| Byte | Description |\r\n|------|-------------|\r\n| 1 | X position (bits 0-7) |\r\n| 2 | Y position (bits 0-7) |\r\n| 3 | Palette offset, effects, X bit 8 |\r\n| 4 | Visibility, pattern index, enable byte 5 |\r\n| 5 | (Optional) Scale, sprite type, Y bit 8 |\r\n\r\n## Advanced Sprite Features\r\n\r\n### Palette Offset\r\n- 4-bit value added to pattern color indices\r\n- Allows recoloring sprites without changing patterns\r\n\r\n### Mirror and Rotate\r\n- X/Y mirroring for flipping sprites\r\n- 90-degree clockwise rotation\r\n- Applied in order: rotate, then mirror\r\n\r\n### Scaling\r\n- Independent X/Y scaling: 1x, 2x, 4x, 8x\r\n- Reduces number of sprites per scanline when scaled\r\n\r\n## Big Sprites with Relative Sprites\r\n\r\nTwo types of relative sprites:\r\n1. **Composite**: Independent sprites positioned relative to anchor\r\n2. **Unified**: Sprites that rotate/scale/mirror as one unit with anchor\r\n\r\n## Code Examples\r\n\r\n### Example 1: Basic Single Sprite\r\n\r\n```asm\r\n; Display a simple sprite at position [100, 80]\r\n\r\n    ; First, enable sprites globally\r\n    ld bc, $243B\r\n    ld a, $15       ; Sprite and Layers System Register\r\n    out (c), a\r\n    ld bc, $253B\r\n    ld a, %00000001 ; Enable sprites\r\n    out (c), a\r\n\r\n    ; Select sprite 0 for attribute upload\r\n    ld bc, $303B\r\n    ld a, 0\r\n    out (c), a\r\n    \r\n    ; Upload sprite attributes via port $57\r\n    ld bc, $57\r\n    \r\n    ; Byte 1: X position LSB\r\n    ld a, 100\r\n    out (c), a\r\n    \r\n    ; Byte 2: Y position LSB\r\n    ld a, 80\r\n    out (c), a\r\n    \r\n    ; Byte 3: Palette offset and effects\r\n    ld a, %00000000  ; No palette offset, no effects, X bit 8 = 0\r\n    out (c), a\r\n    \r\n    ; Byte 4: Visibility and pattern\r\n    ld a, %10000001  ; Visible, no byte 5, pattern 1\r\n    out (c), a\r\n```\r\n\r\n### Example 2: Animated Sprite\r\n\r\n```asm\r\n; Animate sprite by changing pattern index\r\n\r\n    ; Select sprite 0\r\n    ld bc, $303B\r\n    ld a, 0\r\n    out (c), a\r\n    \r\n    ; Keep position same, update pattern\r\n    ld bc, $57\r\n    \r\n    ; Skip position bytes (auto-increment works)\r\n    ld a, 100       ; X position\r\n    out (c), a\r\n    ld a, 80        ; Y position\r\n    out (c), a\r\n    ld a, 0         ; No effects\r\n    out (c), a\r\n    \r\n    ; Update pattern for animation\r\n    ld a, (frame_counter)\r\n    and %00000111   ; Use patterns 0-7\r\n    or %10000000    ; Keep visible\r\n    out (c), a\r\n```\r\n\r\n### Example 3: Big Sprite (2x2)\r\n\r\n```asm\r\n; Create a 32x32 sprite using 4 sprites in a 2x2 pattern\r\n; Using NextReg interface for clarity\r\n\r\n    ; Sprite 0 - Top-left (anchor)\r\n    NextReg $34, 0     ; Select sprite 0\r\n    NextReg $35, 100   ; X position\r\n    NextReg $36, 80    ; Y position\r\n    NextReg $37, %00000000  ; No effects\r\n    NextReg $38, %11000001  ; Visible, enable byte 5, pattern 1\r\n    NextReg $39, %00010000  ; Anchor sprite, composite relatives, 2x scale\r\n\r\n    ; Sprite 1 - Top-right (relative)\r\n    NextReg $34, 1     ; Select sprite 1\r\n    NextReg $35, 16    ; +16 pixels right (relative)\r\n    NextReg $36, 0     ; Same Y as anchor (relative)\r\n    NextReg $37, %00010000  ; Mirror X to use same pattern\r\n    NextReg $38, %11000001  ; Visible, enable byte 5, same pattern\r\n    NextReg $39, %01010001  ; Relative sprite, 2x scale, relative pattern\r\n\r\n    ; Sprite 2 - Bottom-left (relative)\r\n    NextReg $34, 2     ; Select sprite 2\r\n    NextReg $35, 0     ; Same X as anchor (relative)\r\n    NextReg $36, 16    ; +16 pixels down (relative)\r\n    NextReg $37, %00100000  ; Mirror Y\r\n    NextReg $38, %11000001  ; Visible, enable byte 5, same pattern\r\n    NextReg $39, %01010001  ; Relative sprite, 2x scale, relative pattern\r\n\r\n    ; Sprite 3 - Bottom-right (relative)\r\n    NextReg $34, 3     ; Select sprite 3\r\n    NextReg $35, 16    ; +16 right (relative)\r\n    NextReg $36, 16    ; +16 down (relative)\r\n    NextReg $37, %00110000  ; Mirror X and Y\r\n    NextReg $38, %11000001  ; Visible, enable byte 5, same pattern\r\n    NextReg $39, %01010001  ; Relative sprite, 2x scale, relative pattern\r\n```\r\n\r\n### Example 4: Composite Relative Sprites\r\n\r\n```asm\r\n; Create a spaceship with separate moving parts\r\n; Main body (anchor) with turrets (relatives)\r\n\r\n    ; Main ship body (anchor)\r\n    NextReg $34, 10    ; Sprite 10\r\n    NextReg $35, 160   ; Center screen X\r\n    NextReg $36, 120   ; Center screen Y\r\n    NextReg $37, %00100000  ; Palette offset 2\r\n    NextReg $38, %11000101  ; Visible, enable byte 5, pattern 5\r\n    NextReg $39, %00000000  ; Normal anchor, composite relatives\r\n\r\n    ; Left turret (relative)\r\n    NextReg $34, 11    ; Sprite 11\r\n    NextReg $35, $F0   ; -16 pixels left (signed byte)\r\n    NextReg $36, $F8   ; -8 pixels up\r\n    NextReg $37, %00100000  ; Same palette as main\r\n    NextReg $38, %11000110  ; Visible, pattern 6\r\n    NextReg $39, %01000000  ; Composite relative\r\n    \r\n    ; Right turret (relative)  \r\n    NextReg $34, 12    ; Sprite 12\r\n    NextReg $35, 16    ; +16 pixels right\r\n    NextReg $36, $F8   ; -8 pixels up\r\n    NextReg $37, %00100000  ; Same palette\r\n    NextReg $38, %11000110  ; Visible, pattern 6\r\n    NextReg $39, %01000000  ; Composite relative\r\n```\r\n\r\n### Example 5: Unified Big Sprite\r\n\r\n```asm\r\n; Create a big sprite that rotates as one unit\r\n; 2x2 sprite that maintains formation when rotated\r\n\r\n    ; Anchor sprite with rotation\r\n    NextReg $34, 20    ; Sprite 20\r\n    NextReg $35, 150   ; X position\r\n    NextReg $36, 100   ; Y position\r\n    NextReg $37, %00000010  ; Enable rotation\r\n    NextReg $38, %11000008  ; Visible, enable byte 5, pattern 8\r\n    NextReg $39, %00100000  ; Anchor, unified relatives\r\n\r\n    ; Top-right relative\r\n    NextReg $34, 21    ; Sprite 21\r\n    NextReg $35, 16    ; +16 right in local space\r\n    NextReg $36, 0     ; Same Y in local space\r\n    NextReg $37, %00000000  ; No local transform\r\n    NextReg $38, %11000009  ; Pattern 9\r\n    NextReg $39, %01000000  ; Unified relative\r\n\r\n    ; Bottom-left relative\r\n    NextReg $34, 22    ; Sprite 22\r\n    NextReg $35, 0     ; Same X in local space\r\n    NextReg $36, 16    ; +16 down in local space\r\n    NextReg $37, %00000000  ; No local transform\r\n    NextReg $38, %11000010  ; Pattern 10\r\n    NextReg $39, %01000000  ; Unified relative\r\n\r\n    ; Bottom-right relative\r\n    NextReg $34, 23    ; Sprite 23\r\n    NextReg $35, 16    ; +16 right in local space\r\n    NextReg $36, 16    ; +16 down in local space\r\n    NextReg $37, %00000000  ; No local transform\r\n    NextReg $38, %11000011  ; Pattern 11\r\n    NextReg $39, %01000000  ; Unified relative\r\n```\r\n\r\n## Tips and Best Practices\r\n\r\n1. **Sprite Ordering**: Sprites are drawn in order 0-127. Use lower numbers for background sprites.\r\n\r\n2. **Pattern Memory Management**: \r\n   - 8-bit patterns: 64 slots (256 bytes each)\r\n   - 4-bit patterns: 128 slots (128 bytes each)\r\n\r\n3. **Performance Considerations**:\r\n   - Scaled sprites use more rendering time\r\n   - Keep sprites on-screen to avoid wrap-around calculations\r\n   - Use relative sprites to reduce attribute updates\r\n\r\n4. **Animation Techniques**:\r\n   - Change pattern index for frame animation\r\n   - Use palette offset for color cycling\r\n   - Combine rotation/mirror for more variations\r\n\r\n5. **Debugging Tips**:\r\n   - Start with simple static sprites\r\n   - Use distinct colors/patterns to identify issues\r\n   - Check sprite enable bit in register $15\r\n   - Verify pattern upload before displaying sprite\r\n\r\n## Common Patterns\r\n\r\n### Moving Platform (4 sprites)\r\n```asm\r\n; Create a 64x16 platform using 4 sprites\r\nplatform_sprites:\r\n    ; Leftmost section (anchor)\r\n    db 32, 200      ; X, Y position\r\n    db %00000000    ; No effects\r\n    db %11000001    ; Visible, pattern 1\r\n    \r\n    ; Middle-left section\r\n    db 16, 0        ; +16 relative X, same Y\r\n    db %00000000    ; No effects  \r\n    db %11000001    ; Same pattern\r\n    db %01000001    ; Relative, use same pattern\r\n    \r\n    ; Middle-right section\r\n    db 32, 0        ; +32 relative X\r\n    db %00000000    ; No effects\r\n    db %11000001    ; Same pattern  \r\n    db %01000001    ; Relative\r\n    \r\n    ; Rightmost section\r\n    db 48, 0        ; +48 relative X\r\n    db %00000000    ; No effects\r\n    db %11000001    ; Same pattern\r\n    db %01000001    ; Relative\r\n```\r\n\r\n### Rotating Enemy\r\n```asm\r\n; Enemy that rotates while moving\r\nupdate_enemy:\r\n    ; Update position\r\n    ld a, (enemy_x)\r\n    inc a\r\n    ld (enemy_x), a\r\n    \r\n    ; Set rotation based on frame\r\n    ld a, (frame_counter)\r\n    and %00000011   ; 0-3 for 4 rotation states\r\n    rlca\r\n    rlca            ; Shift to bits 2-1\r\n    or %10000000    ; Add X mirror if needed\r\n    \r\n    ; Update sprite\r\n    NextReg $34, 30\r\n    NextReg $35, (enemy_x)\r\n    NextReg $36, (enemy_y)\r\n    NextReg $37, a   ; Rotation state\r\n    NextReg $38, %11000100  ; Visible, pattern 4\r\n```\r\n* [Sprites](_sprites.md)\r\n* [Graphics](_graphics.md)\r\n* [NextReg](_nextreg.md)\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_SPRITES": {
    "content": "# ZX Spectrum Next Sprites Reference\r\n\r\n## Table of Contents\r\n\r\n- [Overview](#overview)\r\n- [Sprite Characteristics](#sprite-characteristics) \r\n- [Sprite Patterns](#sprite-patterns)\r\n  - [Pattern Number](#pattern-number)\r\n  - [8-Bit Sprite Patterns](#8-bit-sprite-patterns)\r\n  - [4-Bit Sprite Patterns](#4-bit-sprite-patterns)\r\n  - [Sprite Palette](#sprite-palette)\r\n- [Sprite Attributes](#sprite-attributes)\r\n  - [Sprite Attribute 0](#sprite-attribute-0---x-coordinate-lsb)\r\n  - [Sprite Attribute 1](#sprite-attribute-1---y-coordinate-lsb)\r\n  - [Sprite Attribute 2](#sprite-attribute-2)\r\n  - [Sprite Attribute 3](#sprite-attribute-3)\r\n  - [Sprite Attribute 4](#sprite-attribute-4)\r\n- [Relative Sprites](#relative-sprites)\r\n  - [Composite Sprites](#composite-sprites)\r\n  - [Unified Sprites](#unified-sprites)\r\n- [Programming Sprites](#programming-sprites)\r\n  - [IO Ports](#io-ports)\r\n  - [Nextreg Interfaces](#nextreg-interfaces)\r\n- [Global Control of Sprites](#global-control-of-sprites)\r\n\r\n## Overview\r\n\r\nThe Spectrum Next hardware sprite system provides:\r\n- 128 total sprites\r\n- Display surface of 320×256 pixels\r\n- Minimum 100 sprites per scanline\r\n- 512 colours per pixel\r\n- 16×16 pixel sprite size (can be magnified 2x, 4x, or 8x)\r\n- Sprite mirroring and rotation capabilities\r\n- Sprite grouping functionality\r\n- 16K pattern memory for sprite images\r\n\r\n## Sprite Characteristics\r\n\r\n- **Total sprites**: 128\r\n- **Display surface**: 320×256 (overlaps ULA screen by 32 pixels on each side)\r\n- **Minimum sprites per scanline**: 100†\r\n- **Color depth**: 512 colors per pixel\r\n- **Sprite size**: 16×16 pixels\r\n- **Magnification options**: 2x, 4x, or 8x horizontally and vertically\r\n- **Features**: Can be mirrored, rotated, and grouped\r\n- **Pattern memory**: 16K (can hold 64 8-bit or 128 4-bit sprite images)\r\n\r\n† The actual limit depends on 28MHz clock cycles in a scanline. The hardware ensures sprites are not partially plotted.\r\n\r\n## Sprite Patterns\r\n\r\n### 1.1 Pattern Number\r\n\r\nThe pattern number is a 7-bit value that identifies sprite images in pattern memory:\r\n\r\n| Bit Position | Name | Description |\r\n|-------------|------|-------------|\r\n| 6 | N5 | Most significant bit |\r\n| 5 | N4 | Pattern number bit 4 |\r\n| 4 | N3 | Pattern number bit 3 |\r\n| 3 | N2 | Pattern number bit 2 |\r\n| 2 | N1 | Pattern number bit 1 |\r\n| 1 | N0 | Pattern number bit 0 |\r\n| 0 | N6 | Least significant bit (despite the name) |\r\n\r\n**Note**: For 8-bit sprites, N6=0 always. The remaining 6 bits can identify 64 patterns.\r\n\r\n### 1.2 8-Bit Sprite Patterns\r\n\r\n- Uses 8 bits per pixel (256 colors)\r\n- Requires 256 bytes of pattern memory\r\n- Transparent color determined by Sprite Transparency Index register (default 0xE3)\r\n\r\n### 1.3 4-Bit Sprite Patterns\r\n\r\n- Uses 4 bits per pixel (16 colors)\r\n- Requires 128 bytes of pattern memory\r\n- Two pixels stored per byte (left pixel in upper 4 bits, right pixel in lower 4 bits)\r\n- Transparent color uses lower 4 bits of Sprite Transparency Index register (default 0x3)\r\n\r\n### 1.4 Sprite Palette\r\n\r\nThe sprite palette system works as follows:\r\n\r\n1. **Color Index Calculation**:\r\n\r\n   **8-bit Sprite**:\r\n   ```\r\n   PPPP0000 + IIIIIIII = SSSSSSSS\r\n   ```\r\n   \r\n   **4-bit Sprite**:\r\n   ```\r\n   PPPP0000 + 0000IIII = PPPPIIII\r\n   ```\r\n   \r\n   Where:\r\n   - PPPP = 4-bit palette offset from sprite attributes\r\n   - I = Pixel value from sprite pattern\r\n   - S = Final sprite index\r\n\r\n2. The final 8-bit sprite index is passed through the sprite palette lookup table to get the 9-bit RGB333 color.\r\n\r\n## Sprite Attributes\r\n\r\nEach sprite is defined by 4 or 5 attribute bytes:\r\n\r\n### Sprite Attribute 0 - X Coordinate LSB\r\n\r\n| Bits | Description |\r\n|------|-------------|\r\n| 7-0 | X coordinate (bits 0-7) |\r\n\r\n### Sprite Attribute 1 - Y Coordinate LSB\r\n\r\n| Bits | Description |\r\n|------|-------------|\r\n| 7-0 | Y coordinate (bits 0-7) |\r\n\r\n### Sprite Attribute 2\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7-4 | Palette offset (4 bits) |\r\n| 3 | X mirror |\r\n| 2 | Y mirror |\r\n| 1 | Rotate (90° clockwise) |\r\n| 0 | X8/PR (9th bit of X coordinate or relative palette flag) |\r\n\r\n**Note**: Rotation is applied before mirroring. For relative sprites, bit 0 becomes PR flag.\r\n\r\n### Sprite Attribute 3\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7 | Visible flag (1 = displayed) |\r\n| 6 | Enable attribute byte 4 |\r\n| 5-0 | Sprite pattern number (0-63) |\r\n\r\nIf E=0: Sprite is an 8-bit anchor sprite using patterns 0-63\r\nIf E=1: Sprite is described by attribute byte 4\r\n\r\n### Sprite Attribute 4\r\n\r\nThis byte has three different formats:\r\n\r\n#### A. Extended Anchor Sprite\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7 | H (1 = 4-bit pattern) |\r\n| 6 | N6 (7th pattern bit for 4-bit patterns) |\r\n| 5 | T (relative sprite type: 0=composite, 1=unified) |\r\n| 4-3 | X magnification (00=1x, 01=2x, 10=4x, 11=8x) |\r\n| 2-1 | Y magnification (00=1x, 01=2x, 10=4x, 11=8x) |\r\n| 0 | Y8 (9th bit of Y coordinate) |\r\n\r\n**Note**: {H,N6} must not equal {0,1} as this indicates a relative sprite.\r\n\r\n#### B. Relative Sprite - Composite Type\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7 | 0 (fixed) |\r\n| 6 | 1 (fixed) |\r\n| 5 | N6 (7th pattern bit for 4-bit patterns) |\r\n| 4-3 | X magnification (00=1x, 01=2x, 10=4x, 11=8x) |\r\n| 2-1 | Y magnification (00=1x, 01=2x, 10=4x, 11=8x) |\r\n| 0 | PO (pattern offset relative to anchor) |\r\n\r\n#### C. Relative Sprite - Unified Type\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7 | 0 (fixed) |\r\n| 6 | 1 (fixed) |\r\n| 5 | N6 (7th pattern bit for 4-bit patterns) |\r\n| 4-0 | Must be 0 except bit 0 |\r\n| 0 | PO (pattern offset relative to anchor) |\r\n\r\n## Relative Sprites\r\n\r\n### 3.1 Composite Sprites\r\n\r\nComposite sprites inherit from their anchor:\r\n- Visibility (AND operation with anchor visibility)\r\n- X/Y position (8-bit signed offset from anchor)\r\n- Palette offset (if PR bit set)\r\n- Pattern number (if PO bit set)\r\n- 4-bit pattern flag\r\n\r\nThey act as independent sprites tied to an anchor.\r\n\r\n### 3.2 Unified Sprites\r\n\r\nUnified sprites inherit everything composite sprites do, plus:\r\n- Rotation\r\n- Mirroring  \r\n- Scaling\r\n\r\nThey form a single large sprite controlled by the anchor, with automatic coordinate adjustments.\r\n\r\n## Programming Sprites\r\n\r\n### 4.1 I/O Ports\r\n\r\n#### Sprite Status/Slot Select ($303B / 12347)\r\n\r\n**Write Format**:\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7 | X (unused) |\r\n| 6-0 | Sprite/Pattern select number |\r\n\r\n**Read Format**:\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7-2 | Always 0 |\r\n| 1 | M (max sprites per line exceeded) |\r\n| 0 | C (sprite collision detected) |\r\n\r\n#### Sprite Attribute Upload ($xx57 / 87) - Write Only\r\n\r\nWrites sprite attributes sequentially after selecting via port $303B.\r\n\r\n#### Sprite Pattern Upload ($xx5B / 91) - Write Only\r\n\r\nWrites pattern data sequentially after selecting via port $303B.\r\n\r\n### 4.2 Nextreg Interfaces\r\n\r\n#### Register $34 (52) - Sprite Number\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7 | Pattern address offset (if in lockstep mode) |\r\n| 6-0 | Sprite number (0-127) |\r\n\r\nSelects sprite for following attribute registers.\r\n\r\n#### Register $35/$75 - Sprite Attribute 0\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7-0 | X coordinate LSB |\r\n\r\nRegister $75 includes auto-increment of sprite number.\r\n\r\n#### Register $36/$76 - Sprite Attribute 1\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7-0 | Y coordinate LSB |\r\n\r\n#### Register $37/$77 - Sprite Attribute 2\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7-4 | Palette offset |\r\n| 3 | X mirror |\r\n| 2 | Y mirror |\r\n| 1 | Rotate |\r\n| 0 | X coordinate MSB |\r\n\r\n#### Register $38/$78 - Sprite Attribute 3\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7 | Visible flag |\r\n| 6 | Extended attribute enable |\r\n| 5-0 | Pattern number (0-63) |\r\n\r\n#### Register $39/$79 - Sprite Attribute 4\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7 | H (4-bit pattern flag) |\r\n| 6 | N6 (pattern bit 6) |\r\n| 5 | Relative sprite type |\r\n| 4-3 | X scaling |\r\n| 2-1 | Y scaling |\r\n| 0 | Y coordinate MSB |\r\n\r\n## 5. Global Control of Sprites\r\n\r\n### Peripheral 4 Register ($09)\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7 | AY 2 mono setting |\r\n| 6 | AY 1 mono setting |\r\n| 5 | AY 0 mono setting |\r\n| 4 | Sprite ID lockstep |\r\n| 3 | Disable Kempston port |\r\n| 2 | Disable divMMC ports |\r\n| 1-0 | Scanline intensity |\r\n\r\n### Sprite and Layers System Register ($15)\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7 | LoRes mode enable |\r\n| 6 | Sprite priority |\r\n| 5 | Enable sprite clipping |\r\n| 4-2 | Layer priorities |\r\n| 1 | Over border |\r\n| 0 | Sprites visible |\r\n\r\n### Clip Window Sprites Register ($19)\r\n\r\nDefines sprite clipping window coordinates with four sequential writes:\r\n1. X1 position\r\n2. X2 position  \r\n3. Y1 position\r\n4. Y2 position\r\n\r\n### Clip Window Control Register ($1C)\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7-4 | Reserved (must be 0) |\r\n| 3 | Reset tilemap clip index |\r\n| 2 | Reset ULA/LoRes clip index |\r\n| 1 | Reset sprite clip index |\r\n| 0 | Reset Layer 2 clip index |\r\n\r\n### Enhanced ULA Control Register ($43)\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7 | Disable palette auto-increment |\r\n| 6-4 | Select palette for read/write |\r\n| 3 | Select sprites palette |\r\n| 2 | Select Layer 2 palette |\r\n| 1 | Select ULA palette |\r\n| 0 | Enable ULANext mode |\r\n\r\n### Palette Index Register ($40)\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7-0 | Palette index selection |\r\n\r\n### Palette Value Register ($41)\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7-0 | Color value (RRRGGGBB format) |\r\n\r\n### Enhanced ULA Palette Extension ($44)\r\n\r\nUsed for 9-bit color writes:\r\n\r\n**First Write**:\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7-0 | RRRGGGBB color bits |\r\n\r\n**Second Write**:\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7 | Priority flag (L2 palettes only) |\r\n| 6-1 | Reserved (must be 0) |\r\n| 0 | Blue LSB |\r\n\r\n### Sprites Transparency Index Register ($4B)\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7-0 | Transparency index value |\r\n\r\nFor 4-bit sprites, only bits 3-0 are used.\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_TILEMAPS": {
    "content": "# Tilemap\n\n## Notice \n\nThis page is a work in progress. It is not complete and may contain errors. For now, please refer to [https://wiki.specnext.dev/Tilemap](https://wiki.specnext.dev/Tilemap) for more information.\n\n## Overview\n\nThe Tilemap is a hardware-accelerated character-based display mode for the ZX Spectrum Next that provides a fast way to display backgrounds, game maps, or text. It offers higher resolution than the standard ULA mode and supports color attributes without the classic attribute clash limitations.\n\n## Specifications\n\nThe Tilemap provides:\n\n- Two resolution modes: 40×32 (320×256 pixels) or 80×32 (640×256 pixels)\n- 16-color tiles (4-bit color per pixel) or monochrome text mode\n- Hardware scrolling in both X and Y directions\n- Tile rotation and mirroring capabilities\n- Support for up to 512 unique tiles\n- Two independent palettes\n- Transparent color support\n- Independent control of display priority relative to other layers\n\nThe visible display area overlaps the standard ULA 256×192 area by 32 pixels on all sides. When using HDMI output, the top and bottom character rows may be cut off, making the visible area effectively 40×30 or 80×30.\n\n## Memory Organization\n\nThe Tilemap system uses two data structures, both located in bank 5 (and optionally the first half of bank 7):\n\n1. **Tile Definitions**: Contains the graphical data for each tile\n   - Each standard tile is 32 bytes (8×8 pixels with 4 bits per pixel)\n   - In text mode, each tile needs only 8 bytes (1 bit per pixel, like UDG characters)\n\n2. **Tilemap**: Contains the map data specifying which tiles appear in which positions\n   - Each entry in the tilemap is normally 2 bytes (tile number + attributes)\n   - Can be configured to use 1 byte per entry (tile number only) with global attributes\n\n## Enabling the Tilemap\n\nTo enable and configure the Tilemap, use the Tilemap Control Register (NR $6B):\n\n```\nbit 7: 0=disable tilemap, 1=enable tilemap\nbit 6: 0=40×32 resolution, 1=80×32 resolution\nbit 5: 0=attributes in tilemap, 1=no attributes in tilemap (use global)\nbit 4: 0=primary palette, 1=secondary palette\nbit 3: 0=normal mode, 1=text mode (8 bytes per tile, monochrome)\nbit 2: Reserved, must be 0\nbit 1: 0=256 tile mode, 1=512 tile mode\nbit 0: 0=normal priority, 1=tilemap over ULA\n```\n\nExample:\n```\n; Enable tilemap, 40×32 resolution with attributes\nNextReg $6B, %10000000\n\n; Enable tilemap, 80×32 resolution with global attributes\nNextReg $6B, %11100000\n\n; Enable tilemap in text mode with 512 tiles\nNextReg $6B, %10001010\n```\n\n## Setting Tile Data Locations\n\nTwo registers define where the tilemap data and tile definitions are stored:\n\n### Tilemap Base Address Register (NR $6E)\n\n```\nbits 7-6: Reserved, must be 0\nbits 5-0: MSB of address of the tilemap in Bank 5\n```\n\nIf bit 7 is set (using NextReg $6E, 128+value), the tilemap is located in the first half of bank 7 instead of bank 5.\n\n### Tile Definitions Base Address Register (NR $6F)\n\n```\nbits 7-6: Reserved, must be 0\nbits 5-0: MSB of address of tile definitions in Bank 5\n```\n\nExample:\n```\n; Set tilemap base address to $6000 in bank 5\nNextReg $6E, $60\n\n; Set tile definitions to start at $4000 in bank 5\nNextReg $6F, $40\n\n; Set tilemap base address to $2000 in bank 7\nNextReg $6E, $20 | %10000000\n```\n\n## Tile Attributes\n\nEach tile in the tilemap can have attributes that modify its appearance. When attributes are used (bit 5 of NR $6B is 0), each tilemap entry consists of two bytes:\n\n1. Tile number (0-255 or 0-511 in 512-tile mode)\n2. Attribute byte:\n\n```\nbits 7-4: Palette offset\nbit 3: Mirror X (horizontal flip)\nbit 2: Mirror Y (vertical flip) \nbit 1: Rotate\nbit 0: ULA over tilemap (in 256-tile mode) or bit 8 of tile number (in 512-tile mode)\n```\n\nIn text mode, the attributes change:\n```\nbits 7-1: Palette offset (0-127)\nbit 0: ULA over tilemap or bit 8 of tile number\n```\n\nIf global attributes are enabled (bit 5 of NR $6B is 1), all tiles use the same attributes from the Default Tilemap Attribute Register (NR $6C):\n\n```\nbits 7-4: Palette offset\nbit 3: Mirror X\nbit 2: Mirror Y\nbit 1: Rotate\nbit 0: ULA over tilemap (or bit 8 of tile number in 512-tile mode)\n```\n\nExample:\n```\n; Set default tile attributes:\n; - Palette offset 2\n; - X mirroring enabled\n; - No Y mirroring\n; - No rotation\n; - ULA over tilemap\nNextReg $6C, %00101001\n```\n\n## Transparency and Clipping\n\n### Tilemap Transparency Index Register (NR $4C)\n\nSets which color index (0-15) is treated as transparent, allowing background layers to show through:\n\n```\nbits 7-4: Reserved, must be 0\nbits 3-0: Transparency index (default is $F)\n```\n\n### Clip Window Tilemap Register (NR $1B)\n\nDefines a rectangular clipping window for the tilemap. Requires four consecutive writes:\n\n```\n1st write: X1 position (left)\n2nd write: X2 position (right)\n3rd write: Y1 position (top)\n4th write: Y2 position (bottom)\n```\n\nThe origin (0,0) of the clip window is the top-left corner of the full tilemap area, which is 32 pixels above and to the left of the standard ULA display area.\n\nExample:\n```\n; Set transparency color to index 0\nNextReg $4C, $00\n\n; Set clip window to match ULA display area (32,32 to 32+256,32+192)\nNextReg $1B, 32    ; X1 = 32\nNextReg $1B, 287   ; X2 = 32+255\nNextReg $1B, 32    ; Y1 = 32\nNextReg $1B, 223   ; Y2 = 32+191\n```\n\n## Hardware Scrolling\n\nThe tilemap supports hardware scrolling through three registers:\n\n### Tilemap Offset X MSB Register (NR $2F)\n\n```\nbits 7-2: Reserved, must be 0\nbits 1-0: MSB of X Offset (meaningful range is 0-319 in 40-char mode, 0-639 in 80-char mode)\n```\n\n### Tilemap Offset X LSB Register (NR $30)\n\n```\nbits 7-0: LSB X Offset (meaningful range is 0-319 in 40-char mode, 0-639 in 80-char mode)\n```\n\n### Tilemap Offset Y Register (NR $31)\n\n```\nbits 7-0: Y Offset (0-255)\n```\n\nExample:\n```\n; Scroll tilemap 48 pixels right and 24 pixels down\nNextReg $2F, 0        ; X offset MSB = 0\nNextReg $30, 48       ; X offset LSB = 48\nNextReg $31, 24       ; Y offset = 24\n\n; Scroll to X position 320 (requires MSB to be set)\nNextReg $2F, %00000001 ; X offset MSB = 1\nNextReg $30, 64        ; X offset LSB = 64 (320 = 256 + 64)\n```\n\n## Palette Control\n\nThe tilemap has its own pair of palettes, each with 256 entries. Select which palette to write to using the Enhanced ULA Control Register (NR $43):\n\n```\nbit 7: 1=disable palette auto-increment, 0=enable\nbits 6-4: Select palette:\n    011 = Tilemap first palette\n    111 = Tilemap second palette\nbits 3-0: Other settings (not related to Tilemap)\n```\n\nOnce selected, use Palette Index Register (NR $40) to select a palette entry, then write the color value using either:\n\n- Palette Value Register (NR $41) for 8-bit RRRGGGBB format\n- Enhanced ULA Palette Extension (NR $44) for 9-bit RRRGGGBBB format\n\nExample:\n```\n; Select the first Tilemap palette for writing\nNextReg $43, %00000011\n\n; Set entry 0 to bright red (RRRGGGBB format)\nNextReg $40, 0       ; Select palette index 0\nNextReg $41, %11100000 ; Bright red color\n\n; Set entry 1 to bright green\nNextReg $40, 1\nNextReg $41, %00011100\n```\n\n## Example: Basic Tilemap Setup\n\nHere's a complete example showing how to set up a basic tilemap:\n\n```\n; 1. Initialize tilemap system\nNextReg $6B, %10000000    ; Enable tilemap, 40×32, with attributes\n\n; 2. Set up memory locations\nNextReg $6E, $60          ; Tilemap data at $6000 in bank 5\nNextReg $6F, $40          ; Tile definitions at $4000 in bank 5\n\n; 3. Set default attributes (if needed)\nNextReg $6C, %00000000    ; Default attributes: no flips, rotations, etc.\n\n; 4. Set transparency color\nNextReg $4C, $0F          ; Set transparency to color index 15\n\n; 5. Select palette for configuration\nNextReg $43, %00000011    ; Select first tilemap palette, auto-increment on\n\n; 6. Set up a few palette entries\nNextReg $40, 0            ; Start with palette index 0\nNextReg $41, %00000000    ; Black\nNextReg $41, %11100000    ; Red\nNextReg $41, %00011100    ; Green\nNextReg $41, %11111100    ; Yellow\n\n; 7. Optional: Set initial scroll position\nNextReg $2F, 0\nNextReg $30, 0\nNextReg $31, 0\n```\n\n## Example: Smooth Scrolling a Tilemap\n\nThe following example shows how to implement smooth scrolling for a tilemap:\n\n```\n; Start with tilemap scrolled to position (0,0)\nNextReg $2F, 0\nNextReg $30, 0\nNextReg $31, 0\n\n; Scroll right by increments of 1 pixel\nscroll_right:\n    ; Read current X LSB\n    NextReg $30, 0        ; Select register $30 for reading\n    in a, ($253B)         ; Read current value\n    inc a                 ; Increment by 1\n    NextReg $30, a        ; Write back the new value\n    \n    ; Check if we've reached 255\n    cp 255\n    jr nz, scroll_done\n    \n    ; If we hit 255, increment the MSB\n    NextReg $2F, 0        ; Select register $2F for reading\n    in a, ($253B)         ; Read current value\n    inc a                 ; Increment by 1\n    and %00000011         ; Ensure only bits 1-0 are affected\n    NextReg $2F, a        ; Write back the new value\n\nscroll_done:\n    ; Continue with other code\n```\n\n## Example: Creating a Text Display Using Tilemap Text Mode\n\nThis example shows how to use the Tilemap in text mode:\n\n```\n; Set up tilemap in text mode\nNextReg $6B, %10001000    ; Enable tilemap, 40×32, text mode\n\n; Set up memory locations\nNextReg $6E, $60          ; Tilemap at $6000 in bank 5\nNextReg $6F, $40          ; Tile definitions at $4000 in bank 5\n\n; Set palette for text mode (text uses entry 0 for paper, entry 1 for ink)\nNextReg $43, %00000011    ; Select first tilemap palette\nNextReg $40, 0            ; Select palette index 0\nNextReg $41, %00000000    ; Black paper\nNextReg $40, 1            ; Select palette index 1\nNextReg $41, %11111100    ; Yellow ink\n\n; After this, you would need to upload your character set to tile definitions\n; and populate the tilemap with character codes\n```\n\n## Advanced Techniques\n\n### 512-Tile Mode\n\nTo use 512 unique tiles instead of 256:\n\n```\n; Enable 512-tile mode\nNextReg $6B, %10000010    ; Enable tilemap with 512-tile mode\n\n; For tiles 0-255, bit 0 of the attribute byte should be 0\n; For tiles 256-511, bit 0 of the attribute byte should be 1\n```\n\n### Stencil Mode\n\nWhen both ULA and Tilemap are enabled, you can use stencil mode for special effects:\n\n```\n; Enable stencil mode in ULA Control Register\nNextReg $68, %00000001    ; Bit 0 = enable stencil mode\n```\n\nIn stencil mode, a pixel is transparent if both ULA and Tilemap pixels are transparent. Otherwise, the final pixel is an AND of both colors, allowing one layer to act as a cut-out for the other.\n\n## Remarks\n\n- The Tilemap is tied to the ULA display timing, so it works seamlessly with the standard ULA screen.\n- Unlike the ULA, the Tilemap doesn't suffer from attribute clash as each pixel can have its own color.\n- NextBASIC doesn't currently have native commands for the hardware Tilemap, but you can control it using NextReg commands.\n- For best performance, keep tile definitions and tilemap data in bank 5 or 7 where the hardware can access them directly.\n- Text mode can be useful for fast text displays without the limitations of the standard ULA character display.\n\n## See also\n\n* [NextReg](nextreg.md)\n* [Tilemap Control Register ($6B)](tilemap_control_register_nr_6b.md)\n* [Default Tilemap Attribute Register ($6C)](default_tilemap_attribute_register_nr_6c.md)\n* [Tilemap Base Address Register ($6E)](tilemap_base_address_register_nr_6e.md)\n* [Tile Definitions Base Address Register ($6F)](tile_definitions_base_address_register_nr_6f.md)\n* [Clip Window Tilemap Register ($1B)](clip_window_tilemap_register_nr_1b.md)\n* [Tilemap Offset X MSB Register ($2F)](tilemap_offset_x_msb_register_nr_2f.md)\n* [Tilemap Offset X LSB Register ($30)](tilemap_offset_x_lsb_register_nr_30.md)\n* [Tilemap Offset Y Register ($31)](tilemap_offset_y_register_nr_31.md)\n* [Tilemap Transparency Index Register ($4C)](tilemap_transparency_index_register_nr_4c.md)\n* [Layer 2](layer_2.md)\n* [Sprites](sprites.md)\n* [Palettes](palettes.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "__LAYER_2_RAW": {
    "content": "# Layer 2\r\n\r\n## Notice\r\n\r\n> **Work in Progress**\r\n>\r\n> This page is a work in progress. It is not complete and may contain errors. For now, please refer to [the official Layer 2 documentation](https://wiki.specnext.dev/Layer2) where this information is taken from.\r\n\r\n---\r\n\r\n## Overview\r\n\r\nLayer 2 provides an additional screen layer at:\r\n- **256x192** (256 colours)\r\n- **320x256** (256 colours)\r\n- **640x256** (16 colours)\r\n\r\nIn these modes, every pixel is individually coloured. Layer 2 may appear in place of, behind, or above the ULA-generated/Tilemap layer.\r\n\r\n- The Layer 2 screen occupies **48kiB** or **80kiB**, stored in 3 (or 5) consecutive banks.\r\n- By default, banks **9-11** are used for the visible and \"shadow\" Layer 2 screen (the HW after power-on defaults to 8-10 for displayed and 11-13 for shadow screen, but that gets modified by NextZXOS booting up).\r\n- These can be set using:\r\n  - `Layer 2 RAM Page Register` (`$12`)\r\n  - `Layer 2 RAM Shadow Page Register` (`$13`)\r\n\r\n> **Note:** Avoid banks 5, 7, and 8 for Layer 2 screen unless you are familiar with SRAM/BRAM and ULA screen memory handling in the Next's FPGA.\r\n\r\nEach pixel of Layer 2 is assigned **1 byte of video memory** (in 8bpp modes):\r\n- **256x192**: 48kiB (3 banks of 16kiB)\r\n- **320x256/640x256**: 80kiB (5 banks of 16kiB)\r\n\r\n### Bank Layout\r\n- **256x192**: Divided horizontally into 3 banks of 64 lines each (16kiB per bank)\r\n- **320x256/640x256**: Divided vertically into 5 banks of 64 (128) columns each\r\n\r\n---\r\n\r\n## Layer 2 Control\r\n\r\nLayer 2 is controlled via:\r\n- `Layer 2 Access Port` (`$123B` / `4667`)\r\n- `Layer 2 Control Register` (`$70`)\r\n\r\nThe port is bit-mapped as follows:\r\n\r\n| Bit | Description |\r\n|-----|-------------|\r\n| 7-6 | Video RAM bank select (write/read paging) |\r\n| 5-4 | Reserved, write 0 |\r\n| 3   | Use Shadow Layer 2 for paging - `Layer 2 RAM Shadow Page Register` (`$13`) |\r\n| 2   | Enable Layer 2 read-only paging |\r\n| 1   | Layer 2 visible - `Layer 2 RAM Page Register` (`$12`) |\r\n| 0   | Enable Layer 2 write-only paging |\r\n\r\n> Since core 3.0, this bit has a mirror in `Display Control 1 Register` (`$69`).\r\n\r\n---\r\n\r\n## Paging and Memory Mapping\r\n\r\n- When **bit 0** of `$123B` is set to 1, the appropriate area of Layer 2 video memory (as set by bits 6-7) is accessed by writes into slot 1 (`$0000-$3fff`).\r\n  - **Note:** You cannot read Layer 2 via this mapping; reads return ROM/RAM as usual.\r\n- When **bit 2** is set to 1 (core 3.0+), `$0000-$3fff` is remapped for read, allowing read access into Layer 2 bank selected by bits 3, 6, and 7 (writes still go to regular ROM/RAM).\r\n- With **bits 0 and 2** set, you create alternative read+write mapping of RAM (like MM0+MMU1 registers).\r\n\r\n> **Special Memory Note:**\r\n> Bank 5 and first half of Bank 7, when accessed by regular means, are overshadowed by fast BRAM for ULA/Tilemap graphics. Layer 2 mapping circumvents this, accessing main SRAM. Avoid using bank 5, 7, and 8 for Layer 2 unless you know what you're doing.\r\n\r\n### Bank Selection\r\n- **Bits 6 and 7**: Select which third of Layer 2 is mapped (0..2)\r\n- **Value 3** (core 3.0+): Whole 48kiB of Layer 2 is mapped into `$0000-$bfff` (be careful with code, stack, and interrupts)\r\n\r\n### Bank Offset Feature (core 3.x)\r\n- Set bank-offset variable (0..7) by writing value 16..23 to the port (bit 4 set)\r\n- Example: If first bank is 9, and you use value 21 (+5 offset), bank 14 (9+5) is mapped into `$0000..$3FFF`\r\n- This allows mapping full 80kiB of pixel data into the bottom 16kiB/48kiB window\r\n\r\n---\r\n\r\n## Layer 2 Control Register (`$70`)\r\n- Select Layer 2 mode\r\n- Modify palette offset (added to top four bits of each pixel)\r\n- Set up Layer 2 clip window for each mode (`Clip Window Layer 2 Register` (`$18`))\r\n\r\n---\r\n\r\n## Accessing Layer 2 Memory\r\n\r\n- You can use regular banking ports to switch in one of the Layer 2 banks in slot at `$C000` (or use ZX Next MMU registers to map RAM elsewhere)\r\n- This allows normal read/write access\r\n- Write to Layer 2 via slot 1 for convenience and fast graphics data copying\r\n\r\n---\r\n\r\n## Pixel Layout\r\n\r\n- **256x192 mode:**\r\n  - Pixels in English reading order, no ULA-style interlacing\r\n  - 256 pixels per line\r\n  - Upper byte of address = Y coordinate (within selected third)\r\n  - Lower byte = X coordinate\r\n\r\n- **320x256 (8bpp) mode:**\r\n  - Pixels stored top-to-bottom, left-to-right\r\n  - 256 pixels per column\r\n  - Upper byte of address = X coordinate (for a range)\r\n  - Lower byte = Y coordinate\r\n  - 80kiB total pixel memory (5 banks)\r\n\r\n- **640x256 (4bpp) mode:**\r\n  - Same as 320x256, but each byte = 2 pixels (top nibble = left, bottom nibble = right)\r\n\r\n---\r\n\r\n## Tips & Notes\r\n\r\n- **Clear Layer 2** before drawing; it may contain random data at startup.\r\n- **Scrolling:** Use `Layer 2 X Offset Register` (`$16`), `Layer 2 X Offset MSB Register` (`$71`), and `Layer 2 Y Offset Register` (`$17`).\r\n- **Visibility:** Since core 3.0, Layer 2 visibility is not affected by ZX128 ULA-shadow (Bank 7) screen.\r\n- **Performance:** (Obsolete for core 3.0+) Visible Layer 2 would slow CPU to 7MHz.\r\n\r\n---\r\n\r\n## Double Buffering\r\n\r\nTo use a double-buffered scheme for Layer 2:\r\n- `Layer 2 RAM Page Register` (`$12`) is **display related** (change to display new Layer 2 when ready, or modify during frame to compose from various memory areas)\r\n- `Layer 2 RAM Shadow Page Register` (`$13`) is **write-over-ROM paging** only (Layer 2 Access Port `$123B` / `4667`) ",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "NEXTREG": {
    "content": "# NextReg(register,constant)\r\n\r\n## Syntax\r\n\r\n```\r\nNextReg(register,constant)\r\n```\r\n\r\n## Description\r\n\r\nSets Next register reg with a constant value. \r\n```\r\nNextReg(MMU1_2000_NR_51,38)\t\t\t'Sets register $51 in bank 1, $2000-$3fff to bank 38\r\n```\r\nNote that at compilation time this becomes a macro so will only work with constant values, if you want to use a variable you must use [NextRegA()](NextRegA.md)\r\n\r\n## Links\r\n\r\n* [NextRegA()](NextRegA.md)\r\n* [NextRegisters](_registers.md)\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "NEXTREGA": {
    "content": "# NextRegA(register,variable)\r\n\r\n## Syntax\r\n\r\n```\r\nNextRegA(register,variable)\r\n```\r\n\r\n## Description\r\n\r\nSets Next register with value. \r\n\r\n```\r\na = 38\r\nNextRegA(MMU1_2000_NR_51,a) : 'Sets reg $51 memory slot 1, $2000-$3fff to value in a, 38. \r\n```\r\n\r\n## Links\r\n\r\n* [NextReg()](NextReg.md)\r\n* [NextRegister](_registers.md)\r\n\r\n\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "GETKEY": {
    "content": "# GetKey\n\nLibrary: `#include <keys.bas>`\n\nWait for a key to be pressed (using [INKEY$](../../inkey.md)), and return its ASCII Code.\n\n\n### Syntax\n`GetKey()`\n\nWaits for a key pressed and returns its ASCII code. It cannot detect multiple keys pressed.\nThis is useful, for example, to program options menus in games were only a single option\ncan be selected.\n\n## Examples\n\n```\n# include <keys.bas>\n\nPRINT \"PRESS A KEY\"\nx = GetKey\nPRINT \"You pressed the \"; CHR x; \" key\"\n```\nWill print the key pressed. Unlike [INKEY$](../../inkey.md) it returns an Ubyte (ASCII code)\nwhich is more efficient that working with strings.\n\n### See also\n\n* [GetKeyScanCode](getkeyscancode.md)\n* [MultiKeys](multikeys.md)\n\n\nBack to parent page: [Keys library](../keys.bas.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "GETKEYSCANCODE": {
    "content": "# GetKey\n\nLibrary: `#include <keys.bas>`\n\nReturns the Key Scan code of the key pressed or 0 if no keypress is detected.\n\n\n### Syntax\n`GetKeyScanCode()`\n\nExamines the keyboard and returns 0 if no key is pressed (Unlike [GetKey](getkey.md), it\ndoes not way for a key press).\n\nIf there is at least a key pressed, returns all of them ORed (bitwise).\n\n## Examples\n\n```\n# include <keys.bas>\n\nPRINT \"PRESS H, L or both\"\nDO\nLOOP UNTIL GetKeyScanCode()\nPAUSE 10\nx = GetKeyScanCode()\n\nIF x = KEYH THEN PRINT \"You pressed the H key\"\nIF x = KEYL THEN PRINT \"You pressed the L key\"\nIF x = KEYL bOR KEYH THEN PRINT \"You pressed both\"\n```\nTo detect more than one key, they must be in the same \"row half\" (see [keys.bas library](../keys.bas.md))\nfor further explanation.\n\n### See also\n\n* [GetKey](getkey.md)\n* [MultiKeys](multikeys.md)\n\n\nBack to parent page: [Keys library](../keys.bas.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "WAITKEY": {
    "content": "# WAITKEY\r\n\r\n## Syntax\r\n\r\n```\r\nWaitKey()\r\n```\r\n\r\n## Description\r\n\r\nWaits for a keypress or Kempston interface fire buttons.\r\n\r\n**Example**\r\n\r\n\tPRINT \"HELLO\"\r\n\t\tWaitKey() : REM program will wait for keypress\r\n\tPRINT \"Key pressed\"\r\n\r\n**Remarks**\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n\r\nUse instead of PAUSE 0\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ASC.BAS": {
    "content": "# Asc.bas\n\n# ASC\n\nConverts a specified character of a given string into the ASCII code equivalent.\n\n## Syntax\n\n```basic\nvariable = asc(A$,n)\n```\nWhere `A$` is a string variable and `N` defines which character in the string we are interested in.\n\n##Requirements\n\nASC is a library function that must be included before it can be used. Use the following directive:\n\n```\n#include <asc.bas>\n```\n\n\n## Remarks\n\n* This function is for FreeBASIC compatibility. See [FreeBasic - ASC](http://www.freebasic.net/wiki/wikka.php?wakka=KeyPgAsc) for details.\n* The return on this function is generally identical to that of `CODE(A$(n))`, though it will return 0, not an error,\nif invoked to return the ascii code of a character beyond the length of the string.\n\n## See also\n\n* [ CODE ](../code.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ATTR": {
    "content": "## Requirements\n\nATTR is a library function to be included with the following command:\n\n```\n# include <attr.bas>\n```\n\n## Description\n`ATTR(row, col)`\n\nReturns the ATTR (color attribute) of the given screen coordinate at the given row and column.\n\n\n## Sample usage\n\n```\n# include <attr.bas>\n\nPRINT AT 9, 10;PAPER 4; \"A\"\nLET s = ATTR$(9, 10)\nPRINT AT 0, 0; \"The attribute of screen position 9, 10 is \"; s\n```\n\n## Remarks\n\n* This function extends the one in Sinclair BASIC (and it's compatible with it) since it also allows rows 22 and 23.\n\n\n\n## See also\n\n* [ CSRLIN ](csrlin.md)\n* [ POS](pos.md)\n* [ AT ](../at.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ATTRADDRESS": {
    "content": "# AttrAddress\n\n# attrAdress(x,y)\n\nThis function will return the address of the byte that controls\nthe attributes of a given X-Y print position co-ordinate.\n\n\n```\nFUNCTION attrAddress (x as uByte, y as uByte) as uInteger\n'This function returns the memory address of the Character Position\n'x,y in the attribute screen memory.\n'Adapted from code by Jonathan Cauldwell.\n'Rebuilt for ZX BASIC by Britlion from NA_TH_AN's fourspriter, with permission.\n\nAsm\n         ld      a,(IX+7)  ;ypos\n         rrca\n         rrca\n         rrca              ; Multiply by 32\n         ld      l,a       ; Pass to L\n         and     3         ; Mask with 00000011\n         add     a,88      ; 88 * 256 = 22528 - start of attributes.\n         ld      h,a       ; Put it in the High Byte\n         ld      a,l       ; We get y value *32\n         and     224       ; Mask with 11100000\n         ld      l,a       ; Put it in L\n         ld      a,(IX+5)  ; xpos\n         add     a,l       ; Add it to the Low byte\n         ld      l,a       ; Put it back in L, and we're done. HL=Address.\n\nEnd Asm\nEND FUNCTION\n```\n\n## Usage\n\nExample:\n```\npoke attrAddress(10,10),43\n```\n\nWill change the attributes of print position 10, 10 to 43 - (magenta ink on cyan paper)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CLEARBOX": {
    "content": "# ClearBox\n\nThis routine will blank a portion of the screen from character square X, Y of Width and Height defined.\n\nGood for clearing out the portion of the screen you need cleared - e.g. just the game window.\n\n```\nSUB clearBox(x as uByte, y as uByte, width as uByte, height as uByte)\n' This subroutine will blank the pixels for a box, measured in Character Squares\n' from print positions X,Y to X + Width, Y + height.\n'\n' Expected to be useful for clearing a window of space - perhaps in a game.\n' because of this THE ERROR CHECKING IS NONEXISTENT.\n' Please make sure you send sensible data -\n' 0 < x < 32, 0 < y < 23, x + width < 32 and y + height < 23\n' Britlion 2012.\n\nASM\n    ld b,(IX+5)     ;' get x value\n    ld c,(IX+7)     ;' get y value\n\n    ld a, c         ;' Set HL to screen byte for this character.\n    and 24\n    or 64\n    ld h, a\n    ld a, c\n    and 7\n    rra\n    rra\n    rra\n    rra\n    add a, b\n    ld l, a\n\n    ld b, (IX+11)   ;' get height\n    ld c,(IX+9)     ;' get width\n\nclearbox_outer_loop:\n    xor a\n    push bc       ;' save height.\n    push hl       ;' save screen address.\n    ld d, 8       ;' 8 rows to a character.\n\nclearbox_mid_loop:\n    ld e,l        ;' save screen byte lower half.\n    ld b,c        ;' get width.\n\nclearbox_inner_loop:\n    ld (hl), a    ;' write out a zero to the screen.\n\n    inc l         ;' go right.\n    djnz clearbox_inner_loop    ;' repeat.\n\n    ld l,e        ;' recover screen byte\n    inc h         ;' down a row\n\n    dec d\n    jp nz, clearbox_mid_loop  ;' repeat for this row.\n\n    pop hl        ;' get back address at start of line\n    pop bc        ;' get back char count.\n\n    ld a, 32      ;' Go down to next character row.\n    add a, l\n    ld l, a\n    jp nc, clearbox_row_skip\n\n    ld a, 8\n    add a, h\n    ld h, a\n\nclearbox_row_skip:\n    djnz clearbox_outer_loop\nEND ASM\nEND SUB\n```\n\nExample:\n\n```\ncls\n\nfor n=1 to 300\nprint n;\nnext n\n\nclearBox(2,3,18,11)\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "CSRLIN": {
    "content": "# CSRLIN\n\n## Syntax\n\n```\nCSRLIN()\n```\n\n## Description\n\nReturns the row (line) position of the text cursor (0 means the top line).\n\n## Requirements\n\nCSRLIN is a library function to be included with the following command:\n\n```\n# include <csrlin.bas>\n```\n\n## Remarks\n\n* This function is not available in Sinclair BASIC.\n\n## See also\n\n* [ AT ](../at.md)\n* [ SCREEN ](screen.md)\n* [ POINT ](point.md)\n* [ POS](pos.md)",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DISTANCE.BAS": {
    "content": "# Distance.bas\n\nThis calculates an approximation for the distance formula **r=`SQR`(x<sup>2</sup> + y<sup>2</sup>)**,\nbased on two parameters, `x` and `y`. The return value is not guaranteed to be accurate -\nand indeed can be as high as 10% inaccurate as x and y approach 255 (the upper limit for input).\nThe return value is an integer - chosen because screen is 256 pixels wide, and the diagonal across the screen\nis bigger than 1 byte can hold.\n\nIf you need accurate results, you should go with `iSqrt` or `fSqrt` from this library.\n\nFor speed, this can't be beaten, however.\n\nComparing -\n`answer = distance(i, j)` against\n`answer = iSqrt(i * i + j * j)` shows over a range of `i` and `j` `1..250`:\n\n * distance 8.98 seconds<br />\n   iSqrt 50.1 seconds\n\nDistance is definitely faster, if you're willing to accept the greater inaccuracy (you probably are).\n\nBy the by - standard floating point square root:\n\n * `fSqrt` function: 44 minutes (2625.14 seconds)\n * `SQR` (ROM) - 122 minutes. (7336.86 seconds)\n\nShows how awful that ROM SQR routine really is...\n\nFormula is: in a right angle triangle with sides A and B, and hypotenuse H, as an estimate of length of H,\nit returns (A + B) - (half the smallest of A and B) - (1/4 the smallest of A and B) + (1/16 the smallest of A and B)\n\n\n```\nFUNCTION fastcall distance (a as ubyte, b as ubyte) as uInteger\n\nREM returns a fast approximation of SQRT (a^2 + b^2) - the distance formula, generated from taylor series expansion.\nREM This version fundamentally by Alcoholics Anonymous, improving on Britlion's earlier version - which itself\nREM was suggested, with thanks, by NA_TH_AN.\n\nasm\n POP HL ;' return address\n ;' First parameter in A\n POP BC ;' second parameter -> B\n PUSH HL ;' put return back\n\n ;' First find out which is bigger - A or B.\n cp b\n ld c,b\n jr nc, distance_AisMAX\n ld c,a\n\ndistance_AisMAX:\n\n ;' c = MIN(a,b)\n\n srl c     ;' c = MIN/2\n sub c   ;' a = A - MIN/2\n srl c    ;' c = MIN/4\n sub c   ;' a = A - MIN/2 - MIN/4\n srl c\n srl c    ;' c = MIN/16\n add a,c   ;' a = A - MIN/2 - MIN/4 + MIN/16\n add a,b   ;' a = A + B - MIN/2 - MIN/4 + MIN/16\n\n ld l,a\n ld h,0     ;' hl = result\n ret nc\n inc h      ;' catch 9th bit\nEND ASM\nEND FUNCTION\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DOUBLESIZEPRINT.BAS": {
    "content": "# DoubleSizePrint.bas\n\nThis routine will print out Strings at double size. It will stop if it reaches the end of the screen, however\n- so you have to deal with new rows on your own! (143 bytes long for main routine)\n\nThe core subroutine is capable of printing one character on screen at specified location, in double size.\nOf course, this is the basis for the second subroutine, that takes a string and prints it all.\n\nBoth routines are capable of printing from the User Definable Graphics locations.\n\nUsage:\n\n```\nREM Requires ascii code of character to print.\ndoubleSizePrintChar(y, x, code(\"a\"))\n```\n```\nREM This version calls the first one, and will print a whole string.\ndoubleSizePrint(y, x, thingToPrint$)\n```\n\nCode:\n\n```\nSUB doubleSizePrintChar(y as uByte, x as uByte, thingToPrint as uByte)\n' Prints a single character double sized.\n' Takes X and Y values as character positions, like print.\n' takes an ascii code value for a character.\n' By Britlion, 2012.\n\nASM\nLD A,(IX+5) \t;' Y value\nCP 22\nJP NC, doubleSizePrintCharEnd\n\n;' A=y value\nLD E,A\nAND 24\t\t\t ; calculate\nOR 64\t\t\t ; screen\nLD H,A\t\t\t ; address\nLD A,E\t\t\t ; for\nAND 7\t\t\t ; row\nOR a\t\t\t ; Y\nRRA\nRRA\nRRA\nRRA\nLD E,A\n\nLD A,(IX+7) \t;' X Value\nCP 30\nJP NC, doubleSizePrintCharEnd\n\nADD A,E\t\t\t;' correct address for column value. (add it in)\nLD L,A\nEX DE,HL\t\t;' Save it in DE\n\nLD A,(IX+9) \t;'Character\n\nCP 164 \t\t;' > UDG \"U\" ?\nJP NC, doubleSizePrintCharEnd\n\nCP 32  \t\t;' < space+1?\nJP C, doubleSizePrintCharEnd\n\nCP 144 \t\t;' >144?\nJP NC, doubleSizePrintCharUDGAddress\n\nLD L,A\nLD H,0\n\nADD HL,HL\nADD HL,HL\nADD HL,HL\t;' multiply by 8.\nLD BC,(23606)\t;' Chars\nADD HL,BC \t;' Hl -> Character data.\nEX DE,HL\t;' DE -> character data, HL-> screen address.\nJP doubleSizePrintCharRotateLoopCharStart\n\ndoubleSizePrintCharUDGAddress:\nLD HL,(23675)    ;'UDG address\nSUB 144\nADD A,A         ;multiply by 8.\nADD A,A\nADD A,A\nADD A,L\nLD L,A\n\nJR NC, doubleSizePrintCharUDGAddressNoCarry\nINC H\ndoubleSizePrintCharUDGAddressNoCarry:\n\n;' At this point HL -> Character data in UDG block.\nEX DE,HL ;' DE -> character data, HL-> screen address.\n\ndoubleSizePrintCharRotateLoopCharStart:\nLD C,2 ;' 2 character rows.\ndoubleSizePrintCharRotateLoopCharRowLoopOuter:\nLD b,4 ;' 4 source bytes to count through per character row.\ndoubleSizePrintCharRotateLoopCharRowLoopInner:\n   PUSH BC\n\n   LD A,(DE) ;' Grab a bitmap.\n   PUSH DE\n\n   LD B,4\n   LD C,A ; Copy byte so we can put two into the big version.\n   doubleSizePrintCharRotateLoop1:\n      RRA  ; one bit into carry\n      RR E ; one bit into result\n      RR C ; same bit into carry again\n      RR E ; duplicated bit into result\n   DJNZ doubleSizePrintCharRotateLoop1\n\n   LD B,4\n   doubleSizePrintCharRotateLoop2:\n       RRA\n       RR D ; Other register for other half of big 16 bit line.\n       RR C\n       RR D\n   DJNZ doubleSizePrintCharRotateLoop2\n\n   LD (HL),D\t;' Output first byte\n   INC HL\t;' Move right\n   LD (HL),E\t;' Second half.\n   DEC HL\t;' Move left\n   INC H\t;' Move down\n   LD (HL),D\t;' Output second row (copy of first), first byte.\n   INC HL\t;' Move right\n   LD (HL),E\t; Output second row, second byte\n   DEC HL\t; Move left\n   INC H\t; Move down.\n   POP DE\n   INC DE\n   POP BC\n\nDJNZ doubleSizePrintCharRotateLoopCharRowLoopInner\n; CALL __DECY+2 \t;'Jump into the DRAW next_line_down routine, at a convenient point (accounting for the INC H above)\n; Can't seem to call to this at the moment! Here in longhand form:\n\nld a, h\nand 7\njr nz, doubleSizePrintCharRotateNextCharRow\nld a, l\nadd a, 32\nld l, a\njr c, doubleSizePrintCharRotateNextCharRow\nld a, h\nsub 8\nld h, a\n\ndoubleSizePrintCharRotateNextCharRow:\n\nDEC C\nJR NZ, doubleSizePrintCharRotateLoopCharRowLoopOuter\n\ndoubleSizePrintCharEnd:\nEND ASM\nEND SUB\n```\n```\nSUB doubleSizePrint(y as uByte, x as uByte, thingToPrint$ as String)\n'Uses doubleSizePrintChar subroutine to print a string.\n'By Britlion, 2012\n\n   DIM n as uByte\n   for n=0 to LEN thingToPrint - 1\n      doubleSizePrintChar(y,x,CODE thingToPrint$(n) )\n      x=x+2\n   next n\n\nEND SUB\n```\n\nExample:\n\n```\ncls\ndoubleSizePrintChar(0,0,145)\ndoubleSizePrint(10,0,\"Hello World\")\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "FASTPLOT": {
    "content": "# FastPlot\n\nThis plots a single over0 point on the screen, at speed.\n\nIt's been tested at a fill rate of over 8,500 points per second.\n\n```\nSUB fastPlot (x as uByte, y as uByte)\nASM\n    ld d,(IX+5) ;'X\n    ld e,(IX+7) ;'Y\n\n    ld a, 191\n    sub e\n    ret c\n    ld e, a\n    and a\n    rra\n    scf\n    rra\n    and a\n    rra\n    xor e\n    and 248\n    xor e\n    ld h, a\n    ld a, d\n    rlca\n    rlca\n    rlca\n    xor e\n    and 199\n    xor e\n    rlca\n    rlca\n    ld l, a\n    ld a, d\n    and 7\n    ld b, a\n    inc b\n    ld a, 254\n\nplotPoint_loop:\n    rrca\n    djnz plotPoint_loop\n    ld b, 255\n    xor b\n    ld b, a\n    ld a, (hl)\n    or b\n    ld (hl), a\nEND ASM\nEND SUB\n```\n\nEven faster, if you want to use the screen tables, is to lookup the screen address.\n`HRPrintFast()` also uses the same table - it's important to only include it once -\nthere's absolutely no benefit from including more than one copy.\nThere, the magic is `include once` - and just have one copy of the source, to be sure\nit's the same one! You have to include this table (and the label \"ScreenTables\"\nsomewhere in memory so the spectrum can find it.\n\nThis version has been tested with a fill rate of about 10,000 pixels per second (over 20% of the screen per second!).\n\n```\nSUB fastPlot (x as uByte, y as uByte)\nASM\n    ld d,a ;'X\n    ld a, 191\n    sub (IX+7) ;' y\n    jr c, plotPoint_end\n    ld l,a\n    ld h,ScreenTables/256\n    ld a,(HL)\n    inc h\n    ld l,(HL)\n    ld h,a\n    ld a,d\n    RRCA\n    RRCA\n    RRCA\n    AND 31\n    add a,l\n    ld l,a\n\n    ld a, d\n    and 7\n    ld b, a\n    inc b\n    ld a, 1\n\nplotPoint_loop:\n    rrca\n    djnz plotPoint_loop\n    ld b, a\n    ld a, (hl)\n    or b\n    ld (hl), a\nplotPoint_end:\nEND ASM\nEND SUB\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "FSIN.BAS": {
    "content": "# FSin.bas\n\n## Introduction\n\n`fSin` is the basis for the alternatives, since `COS(x)` can be calculated\nfrom `SIN(x)` and `TAN(x)` from `COS(x)` and `SIN(x)`.\n\nThe functions should be accurate to about 0.25%, and significantly faster.\nIf you need a lot of trig in your code, and it doesn't need to be pinpoint accuracy, these are good alternatives.\nNote that they more or less acknowledge they are less accurate by returning values of type `Fixed` instead of type `Float`.\nI did this because it should be fine for the actual accuracy returned,\nand `Fixed` numbers process faster and smaller than `Float` ones.\n\n* Note that you need only include `fSin` if you only want Sines, but you need fSin to use `fCos` or `fTan`.\n\n* Note that these functions use degrees, not radians.\n\n## SINE Function\n\n```\nFUNCTION fSin(num as FIXED) as FIXED\nDIM quad as byte\nDIM est1,dif as uByte\n\n'This change made now that MOD works with FIXED types.\n'This is much faster than the repeated subtraction method for large angles (much > 360)\n'while having some tiny rounding errors that should not significantly affect our results.\n'Note that the result may be positive or negative still, and for SIN(360) might come out\n'fractionally above 360 (which would cause issued) so the below code still is required.\n\nIF num >= 360 THEN\n  num = num MOD 360\nELSEIF num < 0 THEN\n  num = 360 - ABS(num) MOD 360\nEND IF\n\nIF num>180 then\n  quad=-1\n  num=num-180\nELSE\n  quad=1\nEND IF\n\nIF num>90 then num=180-num\n\nnum=num/2\ndif=num : rem Cast to byte loses decimal\nnum=num-dif : rem so this is just the decimal bit\n\n\nest1=PEEK (@sinetable+dif)\ndif=PEEK (@sinetable+dif+1)-est1 : REM this is just the difference to the next up number.\n\nnum=est1+(num*dif): REM base +interpolate to the next value.\n\nreturn (num/255)*quad\n\n\nsinetable:\nasm\nDEFB 000,009,018,027,035,044,053,062\nDEFB 070,079,087,096,104,112,120,127\nDEFB 135,143,150,157,164,171,177,183\nDEFB 190,195,201,206,211,216,221,225\nDEFB 229,233,236,240,243,245,247,249\nDEFB 251,253,254,254,255,255\nend asm\nEND FUNCTION\n```\n\n## COSINE Function\n\n```\nFUNCTION fCos(num as FIXED) as FIXED\n    return fSin(90-num)\nEND FUNCTION\n```\n\n## TANGENT Function\n\n```\nFUNCTION fTan(num as FIXED) as FIXED\n    return fSin(num)/fSin(90-num)\nEND FUNCTION\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "FSQRT.BAS": {
    "content": "# FSqrt.bas\n\n## fSqrt\n\nZX BASIC uses the ZX Spectrum ROM routine to calculate many of the floating point math functions.\nUnfortunately, some of the functions are notoriously slow. Square root being one of them -\nthere wasn't enough space in the original ROM design to do a good routine, so they cheated.\nThey calculate x<sup>0.5</sup> instead, and roll straight into the exponent routine.\nIt turns out that though this works, it's exceptionally slow.\n\nThis function uses the Newton Raphson method. It produces exactly the same full floating point result\n(it even uses the ROM calculator), but it does it about six times faster.\nIf you have a program that's calculating lots of square roots, this will make a big difference.\nHowever, note that integer square roots are faster still, and if you are games programming,\naccuracy might not be so critical. See [iSqrt.bas](isqrt.bas.md) for details.\n\n\n```\nREM Fast floating Point Square Root Function\nREM Adapted and modified for Boriel's ZX BASIC\nREM By Britlion\n\nFUNCTION FASTCALL fSqrt (radicand as FLOAT) as FLOAT\nASM\n        push namespace core\n\n        ; FLOAT value arrives in A ED CB\n        ; A is the exponent.\n          AND   A               ; Test for zero argument\n          RET   Z               ; Return with zero.\n\n          ;Strictly we should test the number for being negative and quit if it is.\n          ;But let's assume we like imaginary numbers, hmm?\n          ; If you'd rather break it change to a jump to an error below.\n          ;BIT   7,E          ; Test the bit.\n          ;JR    NZ,REPORT       ; back to REPORT_A\n                                ; 'Invalid argument'\n          RES 7,E               ; Now it's a positive number, no matter what.\n\n          call __FPSTACK_PUSH   ; Okay, We put it on the calc stack. Stack contains ABS(x)\n\n          ;   Halve the exponent to achieve a good guess.(accurate with .25 16 64 etc.)\n\n                                ; Remember, A is the exponent.\n          XOR   $80             ; toggle sign of exponent\n          SRA   A               ; shift right, bit 7 unchanged.\n          INC   A               ;\n          JR    Z,ASIS          ; forward with say .25 -> .5\n          JP    P,ASIS          ; leave increment if value > .5\n          DEC   A               ; restore to shift only.\n\nASIS:     XOR   $80             ; restore sign.\n          call __FPSTACK_PUSH   ; Okay, NOW we put the guess on the stack\n          rst  28h   ; ROM CALC    ;;guess,x\n          DEFB $C3              ;;st-mem-3\n          DEFB $02              ;;delete\n\nSQRLOOP:  DEFB  $31             ;;duplicate\n          DEFB  $E3             ;;get-mem-3\n          DEFB  $C4             ;;st-mem-4\n          DEFB  $05             ;;div\n          DEFB  $E3             ;;get-mem-3\n          DEFB  $0F             ;;addition\n          DEFB  $A2             ;;stk-half\n          DEFB  $04             ;;multiply\n          DEFB  $C3             ;;st-mem-3\n          DEFB  $E4             ;;get-mem-4\n          DEFB  $03             ;;subtract\n          DEFB  $2A             ;;abs\n          DEFB  $37             ;;greater-0\n          DEFB  $00             ;;jump-true\n\n          DEFB  SQRLOOP - $     ;;to sqrloop\n\n          DEFB  $02             ;;delete\n          DEFB  $E3             ;;get-mem-3\n          DEFB  $38             ;;end-calc              sqr x.\n\n          jp __FPSTACK_POP\n\n          pop namespace\n\nEND ASM\nEND FUNCTION\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "HMIRROR.BAS": {
    "content": "# HMirror.bas\n\nThis Function takes a byte in, and returns the byte that has reflected the bits around the x axis,\nsuch that bits 7,6,5,4,3,2,1,0 become bits 0,1,2,3,4,5,6,7.\n\nThis can be useful if you elect to make all your graphics face in one direction -\nyou can mirror the bytes (perhaps to a buffer or a UDG) before you print them.\nIt's faster to store them facing both ways, but you can make quite a memory saving if you just choose one way.\n\n\n```\nFunction fastcall hMirror (number as uByte) as uByte\nasm\n   ld c,a\n; unrolled loop for speed. Still quite small - costs 10 bytes over the loop version, and saves over half the time.\n; 25 bytes and 96 clock cycles\n\n   RR C\n   RLA\n   RR C\n   RLA\n   RR C\n   RLA\n   RR C\n   RLA\n   RR C\n   RLA\n   RR C\n   RLA\n   RR C\n   RLA\n   RR C\n   RLA\nend asm\nEND FUNCTION\n```\n\nThe above function is basically deprecated, but may be easier to understand than the following.\nThis one below is faster, and smaller. You should use this one:\n\n\n```\nFunction fastcall hMirror (number as uByte) as uByte\nasm\n;17 bytes and 66 clock cycles\nReverse:\n    ld b,a       ;b=ABCDEFGH\n    rrca         ;a=HABCDEFG\n    rrca         ;a=GHABCDEF\n    xor b\n    and %10101010\n    xor b        ;a=GBADCFEH\n    ld b,a       ;b=GBADCFEH\n    rrca         ;a=HGBADCFE\n    rrca         ;a=EHGBADCF\n    rrca         ;a=FEHGBADC\n    rrca         ;a=CFEHGBAD\n    xor b\n    and %01100110\n    xor b        ;a=GFEDCBAH\n    rrca         ;a=HGFEDCBA\nend asm\nend function\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "HRPRINT.BAS": {
    "content": "# HRprint.bas\n\nThe High Resolution printing routine allows standard sized characters to be positioned anywhere on the screen.\n\n##Usage\nThere is a an example program that uses this at the end of the page.\n\n```\nHRPrint(x,y,character,attribute,over)\n```\n\nWhere\n* x is the x value in pixel co-ordinates\n* y is the y value in pixel co-ordinates\n* character is the memory address of the UDG style bytes for the character being printed.\n  To print standard characters, use the address of the character from the ROM table.\n* attribute is the attribute byte value (As you'd get from the ATTR function)\n* over is 0 or 1, and chooses whether to print in OVER 0 or OVER 1 mode.\n\n\nPrints the character to the screen at the given pixel co-ordinates.\n\n> NOTE: The ZX Spectrum's attribute system is encoded into the hardware as a 32 character grid.\n> HRPrint does its best, but changing the paper/bright/flash colour from the background is likely to\n> look imperfect as the attribute blocks cannot line up well with the character printed unless it overlaps -\n> as a result, the colour of attribute squares nearby is likely to be changed.\n\n\n##CODE\n\n```\nSUB HRPrint (x as uByte, y as uByte, char as uInteger, attribute as uByte, overprint as uByte)\n'High res Printing, based on code produced, with thanks, by Turkwel over on the WOS boards.\n'Brought to ZX Basic by Britlion, June 2010.\n'For overprint use:\n'     0 -> Nop. Direct write\n'     0xB6 -> OR  (i.e. Normal \"sprite\" write)\n'     0xAE -> XOR (i.e. Like PRINT OVER 1)\n\nAsm\n      ld a,(IX+13) ; Get overprint value\n      LD (HRPOver1),a\n      LD (HRPOver2),a\n\n      ld b,(IX+7)\n      ld c,(IX+5)\n      push bc ; save our co-ordinates.\n\n;print_char:\n      ld d,(IX+09)\n      inc d\n      dec d\n      jr z, HRPrint_From_Charset\n      ld e,(IX+08)\n      ex de, hl\n      jp HR_Print\n\n\nHRPrint_From_Charset:\n      ld  de,(23606)\n      ld  h,0\n      ld  l,(IX+8) ; character\n      add  hl,hl\n      add  hl,hl\n      add  hl,hl\n      add  hl,de\n\nHR_Print:\n      call HRPat\n\n;convert the Y and X pixel values to the correct Screen Address  - Address in DE\n      ld a,8\n\n;set counter to 8 - Bytes of Character Data to put down\nHRPrint0:\n      push af\n      ;save off Counter\n\n      ld a,b\n      cp 192\n      jr c,HRprint1\n      pop af\n      jp HRPrintEnd\n\n;don't print character if  > 191 - off the bottom of the screen - restore AF and exit Print routine\n;[this can be removed if you are keeping tight control of your Y values]\nHRprint1:\n      push hl\n      push de\n      push de\n\n;save off Address of Character Data, Screen Address, Screen Address\n      ld a,c\n      and 7\n      ld d,a\n\n;get lowest 3 bits of Screen address\n      ld e,255\n\n;set up E with the Mask to use - 11111111b = All On\n      ld a,(hl)\n      jr z,HRprint3\n\n;get a Byte of Character Data to put down - but ignore the following Mask shifting\n;if the the X value is on an actual Character boundary i.e. there's no need to shift anything\nHRprint2:\n      rrca\n      srl e\n      dec d\n      jp nz,HRprint2\n\n;Rotate the Character Data Byte D times - and Shift the Mask Byte as well, forcing Zeroes into the\n;Left hand side. The Mask will be used to split the Rotated Character Data over a Character boundary\nHRprint3:\n      pop hl\n;POP one of the Screen Addresses (formerly in DE) into HL\n      ld d,a\n      ld a,e\n      and d\n\nHRPOver1:\n      or (hl)\n      ld (hl),a\n\n;take the Rotated Character Data, mask it with the Mask Byte and the OR it with what's already on the Screen,\n;this takes care of the first part of the Byte\n;[remove the OR (HL) if you just want a straight write rather than a merge]\n      inc l\n      ld a,l\n      and 31\n      jr z,HRprint4\n\n;Increment the Screen Address and check to see if it's at the end of a line,\n;if so then there's no need to put down the second part of the Byte\n      ld a,e\n      cpl\n      and d\n\nHRPOver2:\n      or (hl)\n      ld (hl),a\n\n;Similar to the first Byte, we need to Invert the mask with a CPL so we can put down the second part of the Byte\n;in the next Character location\n;[again, remove the OR (HL) if you just want a straight write rather than a merge]\nHRprint4:\n      pop de\n      inc d\n      inc b\n\n;get the Screen Address back into DE, increment the MSB so it points the the Address immediately below\n;it and Increment the Y value in B as well\n      ld a,b\n      and 7\n      call z,HRPat\n\n;now check if the Y value has gone over a Character Boundary i.e. we will need to recalculate the Screen\n;Address if we've jumped from one Character Line to another - messy but necessary especially for lines 7 and 15\n      pop hl\n      inc hl\n\n;get the Address of the Character Data back and increment it ready for the next byte of data\n      pop af\n      dec a\n      jp nz,HRPrint0\n\n;get the Counter value back, decrement it and go back for another write if we haven't reached the end yet\n      jp HRPrintAttributes\n\n;HRPAT is a subroutine to convert pixel values into an absolute screen address\n;On Entry - B = Y Value C = X Value   On Exit - DE = Screen Address\nHRPat:\n      ld a,b\n      srl a\n      srl a\n      srl a\n      ld e,a\n      and 24\n      or 64\n      ld d,a\n      ld a,b\n      and 7\n      add a,d\n      ld d,a\n      ld a,e\n      and  7\n      rrca\n      rrca\n      rrca\n      ld e,a\n      ld a,c\n      srl a\n      srl a\n      srl a\n      add a,e\n      ld  e,a\n      ret\n\nHRPrintAttributes:\n      pop bc ; recover our X-Y co-ordinates.\n      ld d,0\n      ld a,(IX+11) ; attribute\n      and a\n      jr z, HRPrintEnd  ; if attribute=0, then we don't do attributes.\n      ld e,a ; pass to e\n\n;transfer Attribute Byte to e for easier use\n      ld a,b\n      cp 192\n      jr nc, HRPrintEnd\n\n;check Y position and exit if off bottom of screen\n      push bc\n\n;save off Y and X values for later\n      and 248\n      ld h,22\n      ld l,a\n      add hl,hl\n      add hl,hl\n      srl c\n      srl c\n      srl c\n      ld b,d\n      add hl,bc\n\n;calculate the correct Attribute Address for the Y\\X values\n      ld (hl),e\n\n;set the Attribute - this is ALWAYS set no matter what the valid Y\\X values used\n      pop bc\n\n;get the Y and X values back into BC\n      ;call print_attribute2\n\n;call the subroutine to see if an adjacent Horizontal Attribute needs to be set\nprint_attributes1:\n      ld a,c\n      cp 248\n      jr nc,endPrintAttributes1\n\n;check to see if we are at Horizontal character 31 - if so then no need to set adjacent Horizontal Attribute\n      and 7\n      jr z, endPrintAttributes1\n\n;and don't set the adjacent Horizontal Attribute if there's no need to\n      inc l\n      ld (hl),e\n      dec l\n\n;increment the Attribute address - set the adjacent horizontal Attribute - then set the Attribute Address back\nendPrintAttributes1:\n      ld a,b\n      cp 184\n      jr nc, HRPrintEnd\n\n;check to see if we are at Vertical character 23 - if so then no need to set adjacent Vertical Attribute & Exit routine\n      and 7\n      jr z, HRPrintEnd\n\n;and don't set the adjacent Vertical Attribute if there's no need to & Exit routine\n      ld a,l\n      add a,32\n      ld l,a\n      ld a,d\n      adc a,h\n      ld h,a\n      ld (hl),e\n\n;set the Attribute address to the line below  - and set the adjacent Vertical Attribute\n;\n;drop through now into adjacent Horizontal Attribute subroutine - all RETs will now Exit the routine completely\n;\nHRPrintAttribute2:   ld a,c\n      cp 248\n      jr nc, HRPrintEnd\n\n;check to see if we are at Horizontal character 31 - if so then no need to set adjacent Horizontal Attribute\n      and 7\n      jr z, HRPrintEnd\n\n;and don't set the adjacent Horizontal Attribute if there's no need to\n      inc l\n      ld (hl),e\n      dec l\n\n;increment the Attribute address - set the adjacent horizontal Attribute - then set the Attribute Address back\n      ;ret\n\nHRPrintEnd:\nEnd Asm\nEND SUB\n```\n\n\n## Usage Example\nHere is a short program that demonstrates the HRPrint routine in use - in this case to animate a sprite.\nFour calls to the routine put the four characters of the sprite onto the screen, and similarly erase it.\n\n```\n#include \"hrprint.bas\"\n\nCLS\n\nDIM x,y AS UBYTE\nDIM xd,yd AS BYTE\nx=100\ny=10\nxd=1\nyd=1\n\nDO\n    PAUSE 2\n    HRPrint(x,y,32,56,0): REM Erase with a space (CHR$ 32)\n    HRPrint(x+8,y,32,56,0)\n    HRPrint(x,y+8,32,56,0)\n    HRPrint(x+8,y+8,32,56,0)\n\n    x=x+xd\n    y=y+yd\n\n    HRPrint(x,y,@gentle,76,0)\n    HRPrint(x+8,y,@gentle+8,76,0xAE)\n    HRPrint(x,y+8,@gentle+16,76,0)\n    HRPrint(x+8,y+8,@gentle+24,76,0xAE)\n\n    IF x<=0 OR x>=247 THEN xd=-xd\n    IF y<=0 OR y>=184 THEN yd=-yd\nLOOP\nEND\n\ngentle:\nASM\n    defb 15,15,15,15,15,15,13,15\n    defb 240,144,208,208,240,240,176,240\n    defb 15,14,63,0,0,12,26,30\n    defb 176,112,252,0,0,24,104,120\nEND ASM\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "HRPRINTFAST.BAS": {
    "content": "# HRPrintFast.bas\n\nThe High Resolution printing routine allows standard sized characters to be positioned anywhere on the screen.\n\n## Usage\nThere is a an example program that uses this at the end of the page.\n\n```\nHRPrint(x,y,character,attribute,over)\n```\n\nWhere\n* x is the x value in pixel co-ordinates\n* y is the y value in pixel co-ordinates\n* character is the memory address of the UDG style bytes for the character being printed.\n  To print standard characters, use the address of the character from the ROM table.\n* attribute is the attribute byte value (As you'd get from the ATTR function)\n* over is 0 or 1, and chooses whether to print in OVER 0 or OVER 1 mode.\n\n\n\nPrints the character to the screen at the given pixel co-ordinates.\n\n> NOTE: The ZX Spectrum's attribute system is encoded into the hardware as a 32 character grid.\n> HRPrint does its best, but changing the paper / bright / flash colour from the background is likely to\n> look imperfect as the attribute blocks cannot line up well with the character printed unless it\n> overlaps - as a result, the colour of attribute squares nearby is likely to be changed.\n\n## CODE\nThis code is too large to place in full, since it requires Britlion's Screen and Rotate Tables,\nand this wiki does not allow attachments. Please download HRPrintFast from the forum posting:\nhttp://boriel.com/mybb/showthread.php?tid=532&pid=3318#pid3318\n\n```\nSUB HRPrintFast (x AS UBYTE, y AS UBYTE, char AS UInteger, attribute AS UBYTE, overprint AS UBYTE)\nREM High res Printing, based on code produced, with thanks, by Turkwel over on the WOS boards.\nREM Brought to ZX Basic by Britlion, June 2010.\n\nASM\n    ld a,(IX+13) ; Get overprint value\n    AND a ; zero?\n    JR Z,HRP_No_Over\n    LD a,182\n    JP HRP_Change_Code\n\nHRP_No_Over:\n    XOR A ; faster than LD a,0\n\nHRP_Change_Code:\n    LD (HRPOver1),a\n    LD (HRPOver2),a\n    ld b,(IX+7)\n    ld c,(IX+5)\n    push BC ; SAVE our co-ordinates.\n\n;print_char:\n    ld  d,(IX+09)\n    inc d\n    dec d\n    jr z, HRPrint_From_Charset\n    ld e,(IX+08)\n    jp HR_Print\n\nHRPrint_From_Charset:\n    ld  de,(23606)\n    ld  h,0\n    ld  l,(IX+8) ; character\n    add  hl,hl\n    add  hl,hl\n    add  hl,hl\n    add  hl,de\n\nHR_Print:\n    ;call HRPat\n    ;PUSH HL\n    EX DE,HL  ; Save HL out in DE\n\n    LD H, HRPScreenTables/256\n    LD L,B\n    LD A,(HL)\n\n    INC H\n    LD L,(HL)\n    LD H,A\n\n    LD A,C\n    SRL A\n    SRL A\n    SRL A\n\n    ADD A,L\n    LD L,A\n    EX DE,HL ; swap HL and DE Back\n\n;convert the Y AND X pixel values TO the correct Screen Address  - Address in DE\n    ld a,8\n\n;set counter TO 8 - Bytes of Character Data TO put down\nHRPrint0:\n    push af\n\n;save off Counter\n    ;ld a,b\n    ;cp 192\n    ;jr c,HRprint1\n    ;pop af\n    ;jp HRPrintEnd\n\n;don't print character if  > 191 - off the bottom of the screen - restore AF and exit Print routine\n;[this can be removed IF you are keeping tight control of your Y values]\nHRprint1:\n    push hl\n    push de\n    push de\n\n;save off Address of Character Data, Screen Address, Screen Address\n    ld a,c\n    AND 7\n    ld d,a\n\n;get lowest 3 bits of Screen address\n    ;ld e,255\n\n;set up E with the Mask TO use - 11111111b = All On\n    ld a,(hl)\n    jr nz,HRprint2\n\n;get a BYTE of Character Data TO put down - but ignore the following Mask shifting\n;if the the X value is on an actual Character boundary i.e. there's no need to shift anything\n    ; rrca\n    ; srl e\n    ; dec d\n    ; jp nz,HRprint2\n\n    ld e,0\n    jp HRprint3\n\nHRprint2:\n;Rotate the Character Data BYTE D times - AND Shift the Mask BYTE AS well, forcing Zeroes into the\n;Left hand side. The Mask will be used TO split the Rotated Character Data OVER a Character boundary\n\n; New version: Grab into DE, the split rotation values.\n     LD E,A ; Put our working byte safe\n     LD A,D ; Grab our number of rotates\n     EX DE,HL ; Save HL\n     DEC A ; decrease so 1->0\n     SLA A ; Multiply by 2 because we have double tables.\n     ADD A, RotateTables/256 ; Add in the base for rotate tables.\n     LD H,A ; put it into our lookup.\n     LD A,(HL) ; get high byte\n     INC H\n     LD L,(HL) ; get low byte\n     LD H,A\n     EX DE,HL ; put result in DE, and restore HL.\n\n\nHRprint3:\n    pop hl\n\n;POP one of the Screen Addresses (formerly in DE) into HL\n    ;ld d,a\n    ;ld a,e\n    ;AND d\n    ld a,d ; get our first byte\n\nHRPOver1:\n    OR (hl)\n    ld (hl),a\n\n;take the Rotated Character Data, mask it with the Mask BYTE AND the OR it with what's already on the Screen,\n;this takes care of the first part of the BYTE\n;[remove the OR (HL) IF you just want a straight write rather than a merge]\n    inc l\n    ld a,l\n    AND 31\n    jr z, HRprint4\n\n;Increment the Screen Address AND check TO see IF it's at the end of a line,\n;if so THEN there's no need to put down the second part of the Byte\n    ld a,e\n    ;cpl\n    ;AND d\n\nHRPOver2:\n    OR (hl)\n    ld (hl),a\n\n;Similar TO the first BYTE, we need TO Invert the mask with a CPL so we can put down the second part of the BYTE\n;in the NEXT Character location\n;[again, remove the OR (HL) IF you just want a straight write rather than a merge]\nHRprint4:\n    pop de\n    inc d\n    inc b\n\n;get the Screen Address back into DE, increment the MSB so it points the the Address immediately below\n;it AND Increment the Y value in B AS well\n    ld a,b\n    AND 7\n\n    ;call z,HRPat\n    jr nz, HRPatSkip\n\n    EX DE,HL  ; Save HL out in DE\n\n    LD H, ScreenTables/256\n    LD L,B\n    LD A,(HL)\n\n    INC H\n    LD L,(HL)\n    LD H,A\n\n    LD A,C\n    SRL A\n    SRL A\n    SRL A\n\n    ADD A,L\n    LD L,A\n    EX DE,HL ; swap HL and DE Back\n\nHRPatSkip:\n\n;now check IF the Y value has gone OVER a Character Boundary i.e. we will need TO recalculate the Screen\n;Address IF we've jumped from one Character Line to another - messy but necessary especially for lines 7 and 15\n      pop hl\n      inc hl\n\n;get the Address of the Character Data back AND increment it ready FOR the NEXT BYTE of data\n      pop af\n      dec a\n      jp nz,HRPrint0\n\n;get the Counter value back, decrement it AND GO back FOR another write IF we haven't reached the end yet\n      ; jp HRPrintAttributes (No need to jump around this now)\n\nHRPrintAttributes:\n      POP BC ; recover our X-Y co-ordinates.\n      ld d,0\n      ld a,(IX+11) ; attribute\n      AND a\n      jp z, HRPrintEnd  ; IF attribute=0, THEN we don't do attributes.\n      ld e,a ; pass TO e\n\n;transfer Attribute BYTE TO e FOR easier use\n      ld a,b\n      cp 192\n      jp nc, HRPrintEnd\n\n;check Y position AND EXIT IF off bottom of screen\n      push bc\n\n;save off Y AND X values FOR later\n      AND 248\n      ld h,22\n      ld l,a\n      add hl,hl\n      add hl,hl\n      srl c\n      srl c\n      srl c\n      ld b,d\n      add hl,bc\n\n;calculate the correct Attribute Address FOR the Y\\X values\n      ld (hl),e\n\n;set the Attribute - this is ALWAYS set no matter what the valid Y\\X values used\n      pop bc\n\n;get the Y AND X values back into BC\n      ;call print_attribute2\n\n;call the subroutine TO see IF an adjacent Horizontal Attribute needs TO be set\nprint_attributes1:\n      ld a,c\n      cp 248\n      jr nc,endPrintAttributes1\n\n;check TO see IF we are AT Horizontal character 31 - IF so THEN no need TO set adjacent Horizontal Attribute\n      AND 7\n      jr z, endPrintAttributes1\n\n;and don't set the adjacent Horizontal Attribute if there's no need to\n      inc l\n      ld (hl),e\n      dec l\n\n;increment the Attribute address - set the adjacent horizontal Attribute - THEN set the Attribute Address back\nendPrintAttributes1:\n      ld a,b\n      cp 184\n      jp nc, HRPrintEnd\n\n;check TO see IF we are AT Vertical character 23 - IF so THEN no need TO set adjacent Vertical Attribute & EXIT routine\n      AND 7\n      jp z, HRPrintEnd\n\n;and don't set the adjacent Vertical Attribute if there's no need to & Exit routine\n      ld a,l\n      add a,32\n      ld l,a\n      ld a,d\n      adc a,h\n      ld h,a\n      ld (hl),e\n\n;set the Attribute address TO the line below  - AND set the adjacent Vertical Attribute\n;drop through now into adjacent Horizontal Attribute subroutine - all RETs will now EXIT the routine completely\nHRPrintAttribute2:\n      ld a,c\n      cp 248\n      jp nc, HRPrintEnd\n\n;check TO see IF we are AT Horizontal character 31 - IF so THEN no need TO set adjacent Horizontal Attribute\n      AND 7\n      jp z, HRPrintEnd\n\n;and don't set the adjacent Horizontal Attribute if there's no need to\n      inc l\n      ld (hl),e\n      dec l\n\n;increment the Attribute address - set the adjacent horizontal Attribute - THEN set the Attribute Address back\n      ;ret\n      jp HRPrintEnd\n\n# include once \"Screentables.asm\"\n# include once \"RotateTables.asm\"\n\nHRPrintEnd:\n\nEND ASM\nEND SUB\n\n```\n\n## EXAMPLE OF USE\n\n```\nCLS\n\nDIM x,y,x2,y2 as uByte\nDIM xd,yd as fixed\nDIM counter as uInteger\nDIM time,endtime as uLong\n\nx=100\ny=10\nx2=x\ny2=y\nxd=2\nyd=2\n\n\nDO\n\nx2=x+xd\ny2=y+yd\n\n' Timing loop to make the sprite update clean on the screen.\n' Instead of a waste of time loop here, you could go off and do something for the equivalent time span of the loop. and then come back here to update the sprites.\n' You could call subroutines to update numbers in memory, play some sound for a while, see if a key is pressed...all sorts of things!\n' The point is you need to do a halt, and then get to the sprite update bit a little while later - after the electron beam has moved off the screen.\n' This version below clearly wastes over 130,000 T states per frame.\n\nasm\nhalt\nhalt\nhalt\npush hl ;11\npush af ; 11\n\nld hl,5000 ;10\nquickloop:\ndec hl     ;6\nld a,l     ;4\nor h       ;4\n\njr nz, quickloop   ; 12 (usually - one iteration of 7)\npop af     ; 10\npop hl     ;10\nend asm\n\nHRPrintFast(x,y,32,56,0)\nHRPrintFast(x+8,y,32,56,0)\nHRPrintFast(x,y+8,32,56,0)\nHRPrintFast(x+8,y+8,32,56,0)\n\n\nHRPrintFast(x2,y2,@gentle,76,0)\nHRPrintFast(x2+8,y2,@gentle+8,76,1)\nHRPrintFast(x2,y2+8,@gentle+16,76,0)\nHRPrintFast(x2+8,y2+8,@gentle+24,76,1)\n\nx=x2\ny=y2\n\n\nIF x<=0 OR x>=245 THEN xd=-xd : END IF\nIF y<=0 OR y>=175 THEN yd=-yd : END IF\n\nLOOP\nend\n\ngentle:\nasm\n    defb 15,15,15,15,15,15,13,15\n    defb 240,144,208,208,240,240,176,240\n    defb 15,14,63,0,0,12,26,30\n    defb 176,112,252,0,0,24,104,120\nend asm\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ISQRT.BAS": {
    "content": "# ISqrt.bas\n\nAn Integer square root is the nearest whole number smaller than the full square root answer.\nSo the integer square root of 10 is 3 instead of 3.162277. You'd get the same answer as `INT(SQR(x))`\nwith an integer square root function.\n\nFor things like games programming, this is often near enough - for example, the distance formula,\nbased on Pythagoras' equation A<sup>2</sup> = B<sup>2</sup> + C<sup>2</sup> only works if you square root the answer.\nIf you need to find the distances between your items, then you're going to be doing a lot of square roots,\nand you're going to need to do them FAST (that said the even faster solution might be this one:\n[distance.bas](distance.bas.md) or if you don't need the actual distance just the answer to\nthe question _\"which one is further away?\"_ then not square rooting is needed, and comparing distance1<sup>2</sup> with\ndistance2<sup>2</sup> still tells you which is nearer.\n[Berksman](http://www.worldofspectrum.org/infoseekid.cgi?id=0027713) written in ZX Basic,\ndoes this trick of never doing the square root part, for example.\n\nAnyway, this function returns integer square roots. For numbers less than 65536, it's about 100 times faster,\nbecause it can do 16 bit calculation. For longer numbers, it has to do 32 bit calculations,\nwhich are less than optimal on an 8 bit processor! It's still about 50 times faster than the ROM routine, however.\n\nIf you want completely accurate results, you should use\nthe floating point fast routine over at [fSqrt.bas](fsqrt.bas.md).\n\n\n```\nFUNCTION FASTCALL iSqrt (num as uLong) as uInteger\nREM incoming is DEHL\nREM output is HL\n\nasm\n    LD A,D\n    OR E\n    JP Z, sqrtLF16bit ; we're inside a 16 bit number. We can use the faster version.\n\n    LD b,16 ; b times round\n    EXX ; Out to root and rem - we're doing most of this in alternate registers.\n    LD DE,0\n    LD HL,0 ; DEHL = remainder\n    LD BC,0 ; BC = root\n    EXX   ;back to num and loop\nsqrtLFasmloop:\n    EXX  ; out to root and rem\n\n    SLA  C ; root <<= 1\n    RL  B   ;\n\n    SLA L ; rem=rem<<1\n    RL  H  ;\n    RL  E    ;\n    RL  D     ;\n\n    SLA L ; rem=rem<<1\n    RL  H  ;\n    RL  E    ;\n    RL  D     ;\n    EXX  ; back to Num and loop\n\n    LD a,d    ; A = inputnum>>30\n    AND 192\n    RLCA\n    RLCA\n\n    SLA  L ; num <<= 1\n    RL  H\n    RL  E\n    RL  D\n\n    SLA  L ; num <<= 1\n    RL  H\n    RL  E\n    RL  D\n\n    EXX  ; out to root and rem\n\n    ADD A,L     ; a=a+L              ; REM=REM+num>>30\n    LD L,A      ; a-> L               ;\n    JR NC, sqrtLFasmloophop1           ;\n    INC H\n    JR NC, sqrtLFasmloophop1\n    INC DE      ;\n\nsqrtLFasmloophop1:\n    INC BC                       ; root=root+1\n\nsqrtLFasmloophop2:\n    ; DEHL = Remainder\n    ; BC = root\n\n    ; if rem >= root then\n    LD A,D\n    OR E\n    JR NZ, sqrtLFasmthen ; if rem > 65535 then rem is definitely > root and we go to true\n\n    LD A, H\n    CP B\n    JR C, sqrtLFasmelse ; H<B - that is rem<root so rem>=root is false and we go to else\n    JR NZ, sqrtLFasmthen ; H isn't zero though, so we could do a carry from it, so we're good to say HL is larger.\n\n    ; if h is out, then it's down to L and C\n    LD A,L\n    CP C\n    JR C, sqrtLFasmelse ; L<C - that is rem<root so rem>=root is false and we go to else\n    ; must be true - go to true.\n\nsqrtLFasmthen:\n    ;remainder=remainder-root\n    AND A ; clear carry flag\n    SBC HL,BC ; take root away from the lower half of rem.\n    JP NC, sqrtLFasmhop3 ; we didn't take away too much, so we're okay to loop round.\n\n    ; if we're here, we did take away too much. We need to borrow from DE\n    DEC DE ; borrow off DE\n\nsqrtLFasmhop3:\n    INC BC ;root=root+1\n    JP sqrtLFasmloopend\n\n    ;else\nsqrtLFasmelse:\n    DEC BC ;root=root-1\n    ;end if\n\n\nsqrtLFasmloopend:\n    EXX  ; back to num\n    DJNZ sqrtLFasmloop\n\n    EXX ; out to root and rem\n    PUSH BC\n\n    EXX ; back to normal\n    POP HL\n    SRA  H\n    RES 7,H\n    RR  L       ; Hl=HL/2 - root/2 is the answer.\n    jr sqrtLFexitFunction\n\nsqrtLF16bit:\n\n    ld  a,l\n    ld  l,h\n    ld   de,0040h   ; 40h appends \"01\" to D\n    ld   h,d\n    ld b,7\n\nsqrtLFsqrt16loop:\n    sbc   hl,de      ; IF speed is critical, and you don't mind spending the extra bytes,\n                   ; you could unroll this loop 7 times instead of DJNZ.\n\n    ; deprecated because of issues - jr nc,$+3 (note that if you unroll this loop, you'll need 7 labels for the jumps the other way!)\n    jr    nc,sqrtLFsqrthop1\n    add   hl,de\n\n\nsqrtLFsqrthop1:\n    ccf\n    rl    d\n    rla\n    adc   hl,hl\n    rla\n    adc   hl,hl\n\n    DJNZ sqrtLFsqrt16loop\n\n    sbc   hl,de      ; optimised last iteration\n    ccf\n    rl   d\n    ld h,0\n    ld l,d\n    ld de,0\nsqrtLFexitFunction:\n    end asm\nEND FUNCTION\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "KEYS.BAS": {
    "content": "# KEYS.BAS\n\nLibrary to check for keys being pressed. It provide functions which are\nmuch faster than [INKEY$](../inkey.md), take less memory and does not require\nthe Sinclair ROM to be present.\n\n## Functions\nFunctions provided in this library:\n\n* [GetKey](keys/getkey.md)\n* [GetKeyScanCode](keys/getkeyscancode.md)\n* [MultiKeys](keys/multikeys.md)\n\n\n### Scan codes\n\nThis library define some global constants named _Scan codes_ which are just\nUInteger constant.\n\nEach key has assigned a unique Scan code. The ZX Spectrum Keyboard is divided\nin 8 Rows half. Each Row half comprises 5 keys (from the left or right side of the speccy\nQWERTY keyboard).\n\nFor example letters H, J, K L and ENTER belong to row half #2 (see below).\n\nIt is possible, for some routines, to use more than one scan code simultaneously, with `bOR`\noperator.\nFor example `KEYH bOR KEYL` means Key H and/or Key L.\nThe only restriction is that both keys must be in the same Row Half.\n\nThese are all the scan codes available and their values.\n```\nScan Codes\n\n1st Keyboard ROW half\nconst KEYB        AS UInteger = 07F10h\nconst KEYN        AS UInteger = 07F08h\nconst KEYM        AS UInteger = 07F04h\nconst KEYSYMBOL   AS UInteger = 07F02h\nconst KEYSPACE    AS UInteger = 07F01h\n\n2nd Keyboard ROW half\nconst KEYH        AS UInteger = 0BF10h\nconst KEYJ        AS UInteger = 0BF08h\nconst KEYK        AS UInteger = 0BF04h\nconst KEYL        AS UInteger = 0BF02h\nconst KEYENTER    AS UInteger = 0BF01h\n\nREM 3rd Keyboard ROW half\nconst KEYY        AS UInteger = 0DF10h\nconst KEYU        AS UInteger = 0DF08h\nconst KEYI        AS UInteger = 0DF04h\nconst KEYO        AS UInteger = 0DF02h\nconst KEYP        AS UInteger = 0DF01h\n\nREM 4th Keyboard ROW half\nconst KEY6        AS UInteger = 0EF10h\nconst KEY7        AS UInteger = 0EF08h\nconst KEY8        AS UInteger = 0EF04h\nconst KEY9        AS UInteger = 0EF02h\nconst KEY0        AS UInteger = 0EF01h\n\nREM 5th Keyboard ROW half\nconst KEY5        AS UInteger = 0F710h\nconst KEY4        AS UInteger = 0F708h\nconst KEY3        AS UInteger = 0F704h\nconst KEY2        AS UInteger = 0F702h\nconst KEY1        AS UInteger = 0F701h\n\nREM 6th Keyboard ROW half\nconst KEYT        AS UInteger = 0FB10h\nconst KEYR        AS UInteger = 0FB08h\nconst KEYE        AS UInteger = 0FB04h\nconst KEYW        AS UInteger = 0FB02h\nconst KEYQ        AS UInteger = 0FB01h\n\nREM 7th Keyboard ROW half\nconst KEYG        AS UInteger = 0FD10h\nconst KEYF        AS UInteger = 0FD08h\nconst KEYD        AS UInteger = 0FD04h\nconst KEYS        AS UInteger = 0FD02h\nconst KEYA        AS UInteger = 0FD01h\n\nREM 8th Keyboard ROW half\nconst KEYV        AS UInteger = 0FE10h\nconst KEYC        AS UInteger = 0FE08h\nconst KEYX        AS UInteger = 0FE04h\nconst KEYZ        AS UInteger = 0FE02h\nconst KEYCAPS     AS UInteger = 0FE01h\n```\n\n## See Also\n\n * [INKEY$](../inkey.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MEGALZ.BAS": {
    "content": "# MegaLZ.bas\n\n# megaLZDepack.bas\n\nThis routine takes a block of data compressed with the [MegaLZ](http://lvd.nm.ru/MegaLZ/) compression\nalgorithm at SOURCE location and decompresses it to DESTINATIOn location.\nYou should probably save compressed files as direct binaries, and use asm mode incbin commands\nto include the binary into your project.\n\nTHIS METHOD IS NOW INCLUDED IN THE ZX BASIC EXTERNAL LIBRARY (the library folder),\nso can and should be included with `#include <megalz.bas>` for the latest code.\n\n```\nSUB megaLZDepack (source as uInteger, dest as uInteger)\n    ASM\n    LD E,(IX+6)\n    LD D,(IX+7)\n\n    ;Z80 depacker for megalz V4 packed files   (C) fyrex^mhm\n\n    ; DESCRIPTION:\n    ;\n    ; Depacker is fully relocatable, not self-modifying,\n    ;it's length is 110 bytes starting from DEC40.\n    ;Register usage: AF,AF',BC,DE,HL. Must be CALL'ed, return is done by RET.\n    ;Provide extra stack location for store 2 bytes (1 word). Depacker does not\n    ;disable or enable interrupts, as well as could be interrupted at any time\n    ;(no f*cking wicked stack usage :).\n\n    ; USAGE:\n    ;\n    ; - put depacker anywhere you want,\n    ; - put starting address of packed block in HL,\n    ; - put location where you want data to be depacked in DE,\n    ;   (much like LDIR command, but without BC)\n    ; - make CALL to depacker (DEC40).\n    ; - enjoy! ;)\n\n    ; PRECAUTIONS:\n    ;\n    ; Be very careful if packed and depacked blocks coincide somewhere in memory.\n    ;Here are some advices:\n    ;\n    ; 1. put packed block to the highest addresses possible.\n    ;     Best if last byte of packed block has address #FFFF.\n    ;\n    ; 2. Leave some gap between ends of packed and depacked block.\n    ;     For example, last byte of depacked block at #FF00,\n    ;     last byte of packed block at #FFFF.\n    ;\n    ; 3. Place nonpackable data to the end of block.\n    ;\n    ; 4. Always check whether depacking occurs OK and neither corrupts depacked data\n    ;     nor hangs computer.\n    ;\n\n    ;DEC40\n\n            LD      A,80h\n            EX      AF,AF'\n    MS:     LDI\n    M0:      LD      BC,2FFh\n    M1:      EX      AF,AF'\n    M1X:     ADD     A,A\n            JR      NZ,M2\n            LD      A,(HL)\n            INC     HL\n            RLA\n    M2:      RL      C\n            JR      NC,M1X\n            EX      AF,AF'\n            DJNZ    X2\n            LD      A,2\n            SRA     C\n            JR      C,N1\n            INC     A\n            INC     C\n            JR      Z,N2\n            LD      BC,33Fh\n            JR      M1\n\n    X2:      DJNZ    X3\n            SRL     C\n            JR      C,MS\n            INC     B\n            JR      M1\n    X6:\n            ADD     A,C\n    N2:\n            LD      BC,4FFh\n            JR      M1\n    N1:\n            INC     C\n            JR      NZ,M4\n            EX      AF,AF'\n            INC     B\n    N5:      RR      C\n            JP     C, END_DEC40\n            RL      B\n            ADD     A,A\n            JR      NZ,N6\n            LD      A,(HL)\n            INC     HL\n            RLA\n    N6:      JR      NC,N5\n            EX      AF,AF'\n            ADD     A,B\n            LD      B,6\n            JR      M1\n    X3:\n            DJNZ    X4\n            LD      A,1\n            JR      M3\n    X4:      DJNZ    X5\n            INC     C\n            JR      NZ,M4\n            LD      BC,51Fh\n            JR      M1\n    X5:\n            DJNZ    X6\n            LD      B,C\n    M4:      LD      C,(HL)\n            INC     HL\n    M3:      DEC     B\n            PUSH    HL\n            LD      L,C\n            LD      H,B\n            ADD     HL,DE\n            LD      C,A\n            LD      B,0\n            LDIR\n            POP     HL\n            JR      M0\n\nEND_DEC40:\nEND ASM\nEND SUB\n```\n\n\n## Usage\nExample:\n```\nmegaLZDepack (32768,16384)\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PIXELSCROLL": {
    "content": "# PixelScroll\n\n# pixelScroll.bas\n\nDoes what it says on the tin! Scrolls the screen by the set number of pixels,\nleaving blank pixel rows beyond it. Attributes are untouched.\n\nIt's fast - it uses the screen tables method. You'll need the relevant screen tables\n files - https://dl.dropbox.com/u/4903664/ScreenTables.7z\n\n```\nSUB PixelScrollUp(numOfLines as uByte)\nASM\n; BLPixelTable is where the table starts\n\nAND A ; Flags off A\nJP Z, BLPixelScrollUpEnd ; We were asked to scroll zero. Quit!\nCP 192\nJP NC, BLPixelScrollUpEnd ; We can't scroll more than 191 lines up. Quit!\n\nLD C,A ; Current Line\nLD B,A ; Jump\nPUSH BC ; Save Line count.\n\nBLPixelScrollUpMainLoop:\n\n; screen address routine\nLD H,BLPixelTable/256\nLD L,C\nLD D,(HL)\nINC H\nLD E,(HL)   ; DE is source address\n\n;LD H,BLPixelTable/256\nDEC H ; get H back to pixeltable.\n\nLD A,C\nSUB B  ; A is now destination line number\nLD L,A\nLD A,(HL)\nINC H\nLD L,(HL) ; HL: is destination line address\nLD H,A    ;\nEX DE,HL  ; Swap! ; HL=Source Address. DE=Dest address.\n\n\n```; A small version has these two lines instead of the pile of LDI:\n;   ld bc,32 ; 32 bytes to transfer\n;   ldir\n\n;(A very small version would calculate screen addresses, instead of use the table!)\n\n; A fast version has these 32 LDIs instead: (About 27% faster) - but uses up 28 bytes more.\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\nLDI\n\nPOP BC\nINC C\nLD A,C\nCP 192\nPUSH BC ; Save count again.\n\nJP C, BLPixelScrollUpMainLoop ; Not carry? then We hit the bottom of the screen. Need zeroes.\n\n; blank remaining rows\nPOP BC ; Balance Stack\nLD C,B ; Push diff into C\nLD A,192\nSUB C  ; A now shows row num of the top row to clear.\nCP 192 ; are we done\nJP Z,BLPixelScrollUpEnd\nLD D,0\n\nBLPixelScrollUpClearBigLoop:\n\nLD H,BLPixelTable/256\nLD L,A\nLD C,(HL)\nINC H\nLD L,(HL)\nLD H,C      ; HL is current row\nLD B,32 ; 32 bytes\nBLPixelScrollUpClearLoop:\nLD (HL),D\nINC L\nDJNZ BLPixelScrollUpClearLoop\n\nINC A\nCP 192\n\nJP C, BLPixelScrollUpClearBigLoop\nJP BLPixelScrollUpEnd\n\nEND ASM\n#include once \"ScreenTables.bas\"\nASM\n\nBLPixelScrollUpEnd:\nEND ASM\nEND SUB\n```\n\n\n## Usage\n\nExample:\n\n```\nPixelScrollUp(2)\n```\n\nWill scroll the screen up by 2 pixels.\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "POINT": {
    "content": "# POINT\n\n## Syntax\n\n\n```\nPOINT(x, y)\n```\n\n## Description\n\nReturns 1 if the pixel at coordinates (x, y) is set. 0 if it is not.\n\n## Requirements\n\nPOINT is a library function to be included with the following command:\n\n\n```\n#include <point.bas>\n```\n\n## Sample usage\n\n```bbcbasic\n#include <point.bas>\n\nPLOT 10, 10\nPRINT \"Point at (10, 10) is \"; POINT(10, 10): REM 1\nPRINT \"Point at (15, 15) is \"; POINT(15, 15): REM 0\n```\n\n## Remarks\n\n* This function extends the one in Sinclair BASIC (and it's compatible with it) since it also allows rows 22 and 23.\n* When using `--sinclair` cmd line parameter this function is already available (i.e. no `#include <point.bas>` sentence is needed)\n\n## See also\n\n* [ AT ](../at.md)\n* [ CSRLIN ](csrlin.md)\n* [ SCREEN ](screen.md)\n* [ POS](pos.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "POS": {
    "content": "# POS\n\nReturns the horizontal (left-right) position of the text cursor (0 means the very left).\n\n## Requirements\n\nPOS is a library function to be included with the following directive:\n\n```\n# include <pos.bas>\n```\n\n\n## Remarks\n* This function is not available in Sinclair BASIC.\n\n## See also\n\n* [ AT ](../at.md)\n* [ CSRLIN](csrlin.md)\n* [ POINT ](point.md)\n* [ SCREEN ](screen.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PRINT42.BAS": {
    "content": "# Print42.bas\n\nThe 42 column printing routine allows text to be 6 pixels wide instead of 8.\nIt is NOT proportional printing, but this is still useful for lining things up in columns.\n\nThis routine has been adopted as an included library - so you may include it with\n\n```\n# include <print42.bas>\n```\n\n## Usage\n\n```\nprintat42(y,x)\n```\n\nMoves the print42 system's print cursor to row Y, column X. Note that `0 <= x <= 41` - that is the range of values\nfor X can be up to 41. The range of values for Y is the normal 0-23.\n\n```\nprintat42(STRING)\n```\n\nPrints the string to the screen at the current Print42 co-ordinates. It does so in the current permanent colours.\n\nNOTE: The ZX Spectrum's attribute system is encoded into the hardware as a 32 character grid. Print42 does its best,\nbut changing the `paper`/`bright`/`flash` colour from the background is likely to look imperfect as the attribute blocks\ncannot line up well with the pixel blocks.\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PRINT64.BAS": {
    "content": "# Print64.bas\n\nThe 64 column printing routine allows text to be 4 pixels wide instead of 8.\nIt is NOT proportional printing, but this is still useful for lining things up in columns.\n\nThis routine has been adopted as an included library - so you may include it with\n\n```\n#include <print64.bas>\n```\n\n##Usage\n\n```\nprintat64(y,x)\n```\n\nMoves the print64 system's print cursor to row Y, column X. Note that `0 <= x <= 63` - that is the range of values\nfor X can be up to 63. The range of values for Y is the normal 0-23.\n\n* Note that the print64 system's cursor position is independent from that of the ZX Basic Print routine,\nor any other, such as the print42 system.\n\n```\nprintat64(STRING)\n```\n\n\nPrints the string to the screen at the current Print64 co-ordinates. It does so in the current permanent colours.\n\nNOTE: The ZX Spectrum's attribute system is encoded into the hardware as a 32 character grid. Print64 does its best,\nbut changing the paper/bright/flash colour from the background is likely to look imperfect as the attribute\nblocks cannot line up well with the pixel blocks.\n\n##CODE\n* There is a version of this code included with the compiler\n(though the version listed here may or may not be more recent). Code converted to ZXBasic by Britlion,\nbased on Andrew Owen's 64 Character code http://www.worldofspectrum.org/forums/showpost.php?p=167447&postcount=1\n\n\n```\nSUB printat64 (y as uByte, x as uByte)\n   IF y<24 AND x<64 then\n     POKE @p64coords,x\n     POKE @p64coords+1,y\n   ELSE\n     asm\n       rst     8               ; error \"5 \tOut of screen\"\n       defb    4\n     end asm\n   END IF\nEND SUB\n\n\nSUB print64 (characters$ as String)\nASM\n\n; This frankencode created by Paul Fisher, Andrew Owen, Chris Born and Einar Saukas\n; TODO:\n; * Inverse\n; * Bold (which will use a Second font)\n\nLD L,(IX+4)\nLD H,(IX+5) ; Get String address of characters$ into HL.\n\n; Load BC with length of string, and move HL to point to first character.\n        ld c, (hl)               ; 60020 78\n        inc hl                   ; 60021 35\n        ld b, (hl)               ; 60022 70\n        inc hl                   ; 60023 35\n\n; Test string length. If Zero, exit.\n        ld a, c                  ; 60024 121\n        or b                     ; 60025 176\n        jp z, p64_END         ; 60026 200\n\nexamineChar:\n        ld a, (hl)               ; Grab the character\n        cp 128                   ; too high to print?\n        jr nc, nextChar            ; then we go to next.\n\nnewLine:\n        cp 13                    ; Is this a newline character? 60056 254 13\n        jr nz, p64_isPrintable   ; If not, hop to testing to see if we can print this 60058 32  13\n        push hl\n        push bc\n        ld b,0\n        ld hl, p64_coords      ; Get coords 60060 237 91  68  235\n        call BLp64_NEXT_ROW         ; Go to next line.     ; 60064 205 58  235\n        pop bc\n        pop hl\n\n        ld (p64_coords), de    ; 60067 237 83  68  235\n        jr nextChar              ; 60071 24  11\n\np64_isPrintable:\n        cp 31                    ; Bigger than 31? 60073 254 31\n        jr c, nextChar           ; If not, get the next one. 60075 56  7\n\n        push hl                  ; Save position 60077 229\n        push bc                  ; Save Count   60078 197\n        call p64_PrintChar       ; Call Print SubRoutine\n\n\n\n        pop bc                   ; Recover length count  60082 193\n        pop hl                   ; Recover Position 60083 225\n\nnextChar:\n        inc hl                   ; Point to next character 60084 35\n        dec bc                   ; Count off this character 60085 11\n        ld a, b                  ; Did we run out? 60086 120\n        or c                     ; 60087 177\n        jr nz, examineChar       ; If not, examine the next one 60088 32  193\n        jp p64_END               ; Otherwise hop to END. 60090 201\n\np64_PrintChar:\n; Arrives with A as a byte to print.\n    ld hl,p64_coords\n    push    hl              ; save COL address for later\n    ld      e, a            ; store character value in E\n    ld      b,0\n    ld      c, (hl)         ; store current column in BC\n\n    ; Check if character font must be rotated, self-modifying the code accordingly\n\n        xor     c               ; compare BIT 0 from character value and column\n        rra\n        ld      a, 256-(BLp64_END_LOOP-BLp64_SKIP_RLC) ; instruction DJNZ skipping rotation\n        jr      nc, BLp64_NOT_RLC             ; decide based on BIT 0 comparison\n        ld      a, 256-(BLp64_END_LOOP-BLp64_INIT_RLC) ; instruction DJNZ using rotation\n\nBLp64_NOT_RLC:\n        ld      (BLp64_END_LOOP - 1), a       ; modify DJNZ instruction directly\n\n; Check the half screen byte to be changed, self-modifying the code accordingly\n        srl     c               ; check BIT 0 from current column\n        ld      a, %00001111    ; mask to change left half of the screen byte\n        jr      nc, BLp64_SCR_LEFT    ; decide based on odd or even column\n        cpl                     ; mask to change right half of the screen byte\n\nBLp64_SCR_LEFT:\n        ld      (BLp64_SCR_MASK + 1), a   ; modify screen mask value directly\n        cpl\n        ld      (BLp64_FONT_MASK + 1), a  ; modify font mask value directly\n\n; Calculate location of the first byte to be changed on screen\n; The row value is a 5 bits value (0-23), here represented as %000RRrrr\n; The column value is a 6 bits value (0-63), here represented as %00CCCCCc\n; Formula: 0x4000 + ((row & 0x18) << 8) + ((row & 0x07) << 5) + (col >> 1)\n\n        inc     hl              ; now HL references ROW address\n        ld      a, (hl)         ; now A = %000RRrrr\n        call    0e9eh           ; now HL = %010RR000rrr00000\n        add     hl, bc          ; now HL = %010RR000rrrCCCCC\n        ex      de, hl          ; now DE = %010RR000rrrCCCCC\n                                ; and e=char -> l=char\n\n; Calculate location of the character font data in p64_charset\n; Formula: p64_charset + 7 * INT ((char-32)/2) - 1\n\n        ld      h, b            ; now HL = char (because b=0)\n        srl     l               ; now HL = INT (char/2)\n        ld      c, l            ; now BC = INT (char/2)\n        add     hl, hl          ; now HL = 2 * INT (char/2)\n        add     hl, hl          ; now HL = 4 * INT (char/2)\n        add     hl, hl          ; now HL = 8 * INT (char/2)\n        sbc     hl, bc          ; now HL = 7 * INT (char/2)\n        ld      bc, p64_charset - 71h\n        add     hl, bc          ; now HL = p64_charset + 7 * INT (char/2) - 0x71\n\n\n; Main loop to copy 8 font bytes into screen (1 blank + 7 from font data)\n        xor     a               ; first font byte is always blank\n        ld      b, 8            ; execute loop 8 times\n\nBLp64_INIT_RLC:\n        rlca                    ; switch position between bits 0-3 and bits 4-7\n        rlca\n        rlca\n        rlca\n\nBLp64_SKIP_RLC:\n\n; -----------------------------------------------------------------------------\n; STANDARD OR INVERSE\n;\nBLp64_INV_C:  nop                     ; either 'NOP' or 'CPL' (modified)\n; -----------------------------------------------------------------------------\n\nBLp64_FONT_MASK:\n        and     %11110000       ; mask half of the font byte\n        ld      c, a            ; store half of the font byte in C\n        ld      a, (de)         ; get screen byte\n\nBLp64_SCR_MASK:\n        and     %00001111       ; mask half of the screen byte\n        or      c               ; combine half screen and half font\n        ld      (de), a         ; write result back to screen\n        inc     d               ; next screen location\n        inc     hl              ; next font data location\n        ld      a, (hl)         ; store next font byte in A\n        djnz    BLp64_INIT_RLC        ; repeat loop 8 times (this instruction gets modified)\n\nBLp64_END_LOOP:\n        ; attributes\n        ld de,(p64_coords)       ; grab coords\n        and a                    ; clear carry\n        rr e                     ; divide x by 2 to get bytes instead of nybbles\n        ld a, d                  ; Get Y coord\n        sra a                    ;\n        sra a                    ;\n        sra a                    ; Multiply by 8 60155 203 47\n        add a, 88                ; Add to attribute base address\n        ld h, a                  ; Put high byte value for attribute into H.\n        ld a, d                  ; get y value again\n        and 7                    ; set within third\n        rrca                     ;\n        rrca                     ;\n        rrca                     ;\n        add a, e                 ; add in x value\n        ld l, a                  ; Put low byte for attribute into l\n        ld a, (23693)            ; Get permanent Colours from System Variable\n        ld (hl), a               ; Write new attribute\n\n        pop     hl              ; restore AT_COL address\n        inc     (hl)            ; next column\n        bit     6, (hl)         ; column lower than 64?\n        ret     z               ; return if so\n\nBLp64_NEXT_ROW:\n        ld      (hl), b         ; reset AT_COL\n        inc     hl              ; store AT_ROW address in HL\n        inc     (hl)            ; next row\n        ld      a, (hl)\n        cp      24              ; row lower than 23?\n        ret     c               ; return if so\n        ld      (hl), b         ; reset AT_ROW\n        ret                     ; done!\n\n\nend asm\np64coords:\nasm\np64_coords:\n       defb 0;  X Coordinate store\n       defb 0;  Y Coordinate Store\n\np64_charset:         ; 60230\n        DEFB 2,2,2,2,0,2,0                   ; Space !\n        DEFB 80,82,7,2,7,2,0                 ; \" #\n        DEFB 37,113,66,114,20,117,32         ; $ %\n        DEFB 34,84,32,96,80,96,0             ; & '\n        DEFB 36,66,66,66,66,36,0             ; ( )\n        DEFB 0,82,34,119,34,82,0             ; * +\n        DEFB 0,0,0,7,32,32,64                ; , -\n        DEFB 1,1,2,2,100,100,0               ; . /\n        DEFB 34,86,82,82,82,39,0             ; 0 1\n        DEFB 34,85,18,33,69,114,0            ; 2 3\n        DEFB 87,84,118,17,21,18,0            ; 4 5\n        DEFB 55,65,97,82,84,36,0             ; 6 7\n        DEFB 34,85,37,83,85,34,0             ; 8 9\n        DEFB 0,2,32,0,34,2,4                 ; : ;\n        DEFB 0,16,39,64,39,16,0              ; < =\n        DEFB 2,69,33,18,32,66,0              ; > ?\n        DEFB 98,149,183,181,133,101,0        ; @ A\n        DEFB 98,85,100,84,85,98,0            ; B C\n        DEFB 103,84,86,84,84,103,0           ; D E\n        DEFB 114,69,116,71,69,66,0           ; F G\n        DEFB 87,82,114,82,82,87,0            ; H I\n        DEFB 53,21,22,21,85,37,0             ; J K\n        DEFB 69,71,71,69,69,117,0            ; L M\n        DEFB 82,85,117,117,85,82,0           ; N O\n        DEFB 98,85,85,103,71,67,0            ; P Q\n        DEFB 98,85,82,97,85,82,0             ; R S\n        DEFB 117,37,37,37,37,34,0            ; T U\n        DEFB 85,85,85,87,39,37,0             ; V W\n        DEFB 85,85,37,82,82,82,0             ; X Y\n        DEFB 119,20,36,36,68,119,0           ; Z [\n        DEFB 71,65,33,33,17,23,0             ; \\ ]\n        DEFB 32,112,32,32,32,47,0            ; ^ _\n        DEFB 32,86,65,99,69,115,0            ; £ a\n        DEFB 64,66,101,84,85,98,0            ; b c\n        DEFB 16,18,53,86,84,35,0             ; d e\n        DEFB 32,82,69,101,67,69,2            ; f g\n        DEFB 66,64,102,82,82,87,0            ; h i\n        DEFB 20,4,53,22,21,85,32             ; j k\n        DEFB 64,69,71,71,85,37,0             ; l m\n        DEFB 0,98,85,85,85,82,0              ; n o\n        DEFB 0,99,85,85,99,65,65             ; p q\n        DEFB 0,99,84,66,65,70,0              ; r s\n        DEFB 64,117,69,69,85,34,0            ; t u\n        DEFB 0,85,85,87,39,37,0              ; v w\n        DEFB 0,85,85,35,81,85,2              ; x y\n        DEFB 0,113,18,38,66,113,0            ; z {\n        DEFB 32,36,34,35,34,36,0             ; | {\n        DEFB 6,169,86,12,6,9,6               ; ~ (c)\n\np64_END:\nEnd Asm\nEnd Sub\n```\n\nThere's an example of usage here:\n\n```\nREM Example\n\nDIM n,x,y as uInteger\nCLS\n\nFOR n=1 to 1000\n   y=rnd*23\n   x=rnd*62\n\n   ink rnd*8\n\n   printat64(y, x)\n   print64 (\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"(n MOD 26 TO n MOD 26))\nNEXT n\nEND\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PRINT64X32.BAS": {
    "content": "# Print64x32.bas\n\nThis 64 column printing routine allows text to be 4 pixels wide instead of 8.\nIt is NOT proportional printing, but this is still useful for lining things up in columns.\nThis further enhances the screen by allowing 32 rows of 6 pixels instead of 24 rows of 8 pixels.\nThis allows 2048 character positions on the screen.\n\nNote that the screen tables file, needed for inclusion, can be downloaded from the forum\nthread http://www.boriel.com/forum/wishlist/64-char-print-32-lines-version-t680.html\n\n## Usage\n\n```\nPrint64x32At(y,x)\n```\n\nMoves the print64 system's print cursor to row Y, column X. Note that 0<= x <= 63 -\n that is the range of values for X can be up to 63. The range of values for Y is 0-31.\n* Note that the `print64x32` system's cursor position is independent from that of the\nZX Basic Print routine, or any other, such as the print42 system.\n\n\n```\nPrint64x32(STRING)\n```\n\n\nPrints the string to the screen at the current Print64 co-ordinates.\nIt does so in the current permanent colours.\n\n```\nPrint64x32StringAt(y,x,text$)\n```\n\n\nAn All in one function - sets the AT position, and prints the string.\n\n> NOTE: The ZX Spectrum's attribute system is encoded into the hardware as a 32x24 character grid.\n> This current version of print64x32 does not touch the attributes, as they would not line up well\n> with the text.\n\n## CODE\n\n```\nSUB Print64x32At(Y as uByte,X as UByte)\n Poke(@Print64x32XCoord),X\n Poke (@Print64x32XCoord+1),Y\nEND SUB\n\nSUB Print64x32StringAt(y as ubyte,x as ubyte,text$ as string)\n   Print64x32At(y,x)\n   Print64x32(text$)\nEND SUB\n\nSUB Print64x32 (info as String)\nASM\n; HL Points to string. Length, followed by bytes.\n    LD C,(HL)\n    INC HL\n    LD B,(HL)\n    INC HL\n; BC Now contains our string length.\n; HL Now points to first character.\n\nPrint64x32StringLoop:\n    LD A,(HL)\n\n    PUSH BC\n    PUSH HL\n    CALL Print64x32Char\n    POP HL\n    POP BC\n    Call Print64x32UpdateCoordinates\n\n    DEC BC\n    LD A,B\n    OR C\n    JP Z,Print64x32End\n\n    INC HL\n    JP Print64x32StringLoop\n    JP Print64x32End\n\nPrint64x32Char:\n; Arrives with Character in A\n    LD L,A                      ; HL=A*3\n    LD H,0                      ; |\n    ADD HL,HL                   ; |\n    ADD A,L                     ; |\n    LD  L,A                     ; |\n    JR NC, Print64x32CharHop1   ; |\n    INC H                       ; |\n\nPrint64x32CharHop1:             ; v\n    LD DE,Print64x32CharSet-96  ;Offset is because space=32, and it's a 3 byte table - so we go 96 bytes too far forward when mult by 3.\n    ADD HL,DE\n; HL now points to Correct Character.\n\n    LD BC,(Print64x32_X_Coord) ; Loads Y,X into BC\n    LD A,B    ; B=B*6\n    ADD A,A   ; |\n    LD B,A    ; |\n    ADD A,A   ; |\n    ADD A,B   ; |\n    LD B,A    ; v\n; B now has 0-191 value for Y. C has X value in 0-63 format.\n\n    CALL Print64x32ScreenAddress\n; DE now points at the screen address we need.\n    LD A,C\n    AND 1\n    LD A,%00001111\n    JP NZ,Print64x32RightSide\n\nPrint64x32LeftSide:\n    EXX\n    LD D,3\n\nPrint64x32LeftSideLoop:\n    EXX\n    LD A,(HL)\n    AND %11110000\n    EXX\n    LD E,A\n    EXX\n    LD A,(DE)\n    AND %00001111\n    EXX\n    OR E\n    EXX\n    LD (DE),A\n    INC B\n    CALL Print64x32ScreenAddress\n    ; HL Now has 2nd Line\n\n    LD A,(HL)\n    AND %00001111 ; Grab second four bits.\n    RLCA          ; Push to left side of byte.\n    RLCA\n    RLCA\n    RLCA\n\n    EXX\n    LD C,A\n    EXX\n    LD A,(DE)\n    AND %00001111\n    EXX\n    OR C\n    EXX\n    LD (DE),A\n\n    INC HL\n    INC B\n    CALL Print64x32ScreenAddress\n\n    EXX\n    DEC D\n    JR NZ, Print64x32LeftSideLoop\n    EXX\n\n    RET\n\nPrint64x32RightSide:\n    EXX\n    LD D,3\n\nPrint64x32RightSideLoop:\n    EXX\n\n    LD A,(HL)\n    AND %11110000\n    RRCA        ;Push to right side.\n    RRCA\n    RRCA\n    RRCA\n\n    EXX\n    LD E,A\n    EXX\n    LD A,(DE)\n    AND %1111000\n    EXX\n    OR E\n    EXX\n    LD (DE),A\n\n    INC B\n    CALL Print64x32ScreenAddress\n    ; HL Now has 2nd Line\n\n    LD A,(HL)\n    AND %00001111 ; Grab second four bits.\n\n    EXX\n    LD C,A\n    EXX\n    LD A,(DE)\n    AND %11110000\n    EXX\n    OR C\n    EXX\n    LD (DE),A\n\n    INC HL\n    INC B\n    CALL Print64x32ScreenAddress\n\n    EXX\n    DEC D\n    JR NZ, Print64x32RightSideLoop\n    EXX\nRET\n\n\n; Screen address.\nPrint64x32ScreenAddress:\n\n    EX DE,HL\n    LD H,ScreenTables/256\n    LD L,B\n    LD A,(HL)\n    INC H\n    LD L,(HL)\n    LD H,A\n\n    LD A,C\n    SRL A ; Divide A(xcoord) by 2.\n    ADD A,L\n    LD L,A\n    EX DE,HL\n    RET\n\n; Update Coordinates\nPrint64x32UpdateCoordinates:\n    LD A,(Print64x32_X_Coord)\n    INC A\n    CP 64\n    JR Z,Print64x32OffLine\n    LD (Print64x32_X_Coord),A\n    RET\n\nPrint64x32OffLine:\n    XOR A\n\n    LD (Print64x32_X_Coord),A\n    LD A,(Print64x32_Y_Coord)\n    INC A\n    CP 33\n    JR Z, Print64x32OffScreen\n    LD (Print64x32_Y_Coord),A\n    RET\n\n; Could scroll instead? Right now go back to top.\nPrint64x32OffScreen:\n    XOR A\n    LD (Print64x32_Y_Coord),A\n    RET\n\nPrint64x32End:\nEND ASM\n\nRETURN\n\nPrint64x32XCoord:\nASM\n; Variables\nPrint64x32_X_Coord:\nDEFB 1\nPrint64x32_Y_Coord:\nDEFB 10\n\n# INCLUDE ONCE \"ScreenTables.asm\"\n\nPrint64x32CharSet:\nDEFB 0,0,0\t    ; SPACE\nDEFB 34,32,32\t; !\nDEFB 85,0,0\t    ; \"\nDEFB 87,87,80\t; #\nDEFB 54,35,96\t; $\nDEFB 65,36,16\t; %\nDEFB 53,37,96\t; &\nDEFB 18,0,0\t    ; '\nDEFB 36,68,32\t; (\nDEFB 33,17,32\t; )\nDEFB 82,114,80\t; *\nDEFB 2,114,0\t; +\nDEFB 0,2,64\t    ; ,\nDEFB 0,112,0\t; -\nDEFB 0,0,32\t    ; .\nDEFB 17,36,64\t; /\nDEFB 37,85,32\t; 0\nDEFB 38,34,112\t; 1\nDEFB 37,18,112\t; 2\nDEFB 97,97,96\t; 3\nDEFB 19,87,16\t; 4\nDEFB 116,97,96\t; 5\nDEFB 52,101,32\t; 6\nDEFB 113,18,64\t; 7\nDEFB 37,37,32\t; 8\nDEFB 37,49,96\t; 9\nDEFB 2,2,0\t    ; :\nDEFB 2,2,64\t    ; ;\nDEFB 18,66,16\t; <\nDEFB 7,7,0\t    ; =\nDEFB 66,18,64\t; >\nDEFB 97,32,32\t; ?\nDEFB 97,53,112\t; @\nDEFB 37,117,80\t; A\nDEFB 101,101,96\t; B\nDEFB 37,69,32\t; C\nDEFB 101,85,96\t; D\nDEFB 116,116,112; E\nDEFB 116,116,64\t; F\nDEFB 37,69,112\t; G\nDEFB 85,117,80\t; H\nDEFB 114,34,112\t; I\nDEFB 17,21,32\t; J\nDEFB 85,102,80\t; K\nDEFB 68,68,112\t; L\nDEFB 87,85,80\t; M\nDEFB 101,85,80\t; N\nDEFB 117,85,112\t; O\nDEFB 101,100,64\t; P\nDEFB 37,85,48\t; Q\nDEFB 101,102,80\t; R\nDEFB 52,33,96\t; S\nDEFB 114,34,32\t; T\nDEFB 85,85,96\t; U\nDEFB 85,85,32\t; V\nDEFB 85,87,80\t; W\nDEFB 85,37,80\t; X\nDEFB 85,34,32\t; Y\nDEFB 113,36,112\t; Z\nDEFB 100,68,96\t; [\nDEFB 68,33,16\t; \\\nDEFB 49,17,48\t; ]\nDEFB 39,34,32\t; ^\nDEFB 0,0,15\t; _\nDEFB 37,100,112\t; £\nDEFB 6,53,112\t; a\nDEFB 70,85,96\t; b\nDEFB 3,68,48\t; c\nDEFB 19,85,48\t; d\nDEFB 3,86,48\t; e\nDEFB 37,70,64\t; f\nDEFB 3,83,96\t; g\nDEFB 68,117,80\t; h\nDEFB 64,68,96\t; i\nDEFB 16,17,48\t; j\nDEFB 69,102,80\t; k\nDEFB 68,68,48\t; l\nDEFB 5,117,80\t; m\nDEFB 6,85,80\t; n\nDEFB 7,85,112\t; o\nDEFB 7,87,64\t; p\nDEFB 7,87,16\t; q\nDEFB 7,68,64\t; r\nDEFB 6,66,96\t; s\nDEFB 71,68,48\t; t\nDEFB 5,85,96\t; u\nDEFB 5,85,32\t; v\nDEFB 5,87,80\t; w\nDEFB 5,34,80\t; x\nDEFB 5,113,96\t; y\nDEFB 7,36,112\t; z\nDEFB 50,66,48\t; {\nDEFB 34,34,32\t; |\nDEFB 98,18,96\t; }\nDEFB 2,80,0\t    ; ~\nDEFB 3,67,0\t    ; ©\nDEFB 0,0,0\t    ; <space>\t<8>\t(Block Graphics)\nDEFB 51,48,0\t; TR\t<1>\t(Block Graphics)\nDEFB 204,192,0\t; TL\t<2>\t(Block Graphics)\nDEFB 255,240,0\t; Top\t<3>\t(Block Graphics)\nDEFB 0,3,51\t    ; BR\t<4>\t(Block Graphics)\nDEFB 51,51,51\t; Right\t<5>\t(Block Graphics)\nDEFB 204,195,51\t; TL&BR\t<6>\t(Block Graphics)\nDEFB 255,243,51\t; TL + Right\t<7>\t(Block Graphics)\nDEFB 0,12,204\t; BL\t<SH 7>\t(Block Graphics)\nDEFB 51,60,204\t; BL&TR\t<SH 6>\t(Block Graphics)\nDEFB 204,204,204; Left\t<SH 5>\t(Block Graphics)\nDEFB 255,252,204; Left + TR\t<SH 4>\t(Block Graphics)\nDEFB 0,15,255\t; Bottom\t<SH 3>\t(Block Graphics)\nDEFB 51,63,255\t; BL + Right\t<SH 2>\t(Block Graphics)\nDEFB 204,207,255; Left + BR\t<SH 1>\t(Block Graphics)\nDEFB 255,255,255; All 4\t<SH 8>\t(Block Graphics)\nEND ASM\nPrint64x32Udg:\nASM\nPrint64x32Udg:\nDEFB 218,138,175\t; UDG A\nDEFB 154,154,159\t; UDG B\nDEFB 218,186,223\t; UDG C\nDEFB 154,170,159\t; UDG D\nDEFB 139,139,143\t; UDG E\nDEFB 139,139,191\t; UDG F\nDEFB 218,186,143\t; UDG G\nDEFB 170,138,175\t; UDG H\nDEFB 141,221,143\t; UDG I\nDEFB 238,234,223\t; UDG J\nDEFB 170,153,175\t; UDG K\nDEFB 187,187,143\t; UDG L\nDEFB 168,170,175\t; UDG M\nDEFB 154,170,175\t; UDG N\nDEFB 138,170,143\t; UDG O\nDEFB 154,155,191\t; UDG P\nDEFB 218,170,207\t; UDG Q\nDEFB 154,153,175\t; UDG R\nDEFB 203,222,159\t; UDG S\nDEFB 141,221,223\t; UDG T\nDEFB 170,170,159\t; UDG U\nEND ASM\n\nEND SUB\n```\n\n## Example\n\n```\nCLS\nBORDER 2\n\nPrint64x32StringAt(5,05,\"T\")\nPrint64x32StringAt(6,10,\"U\")\nPrint64x32StringAt(7,15,\"V\")\nPrint64x32StringAt(8,20,\"W\")\nPrint64x32StringAt(9,25,\"X\")\nPrint64x32StringAt(10,30,\"Y\")\nPrint64x32StringAt(11,35,\"Z\")\n\nPrint64x32StringAt(31,15,\"Hello World! :) \")\nPrint64x32StringAt(15,5,\"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\")\nPrint64x32At(0,0)\n\nFor n=32 to 164\nPrint64x32(CHR$(n)+\" \")\nnext n\n\nPAUSE 1\nPAUSE 0\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PROPPRINT.BAS": {
    "content": "# PropPrint.bas\n\nThis proportional printing routine is ideal for making text more readable.\nDo NOT use it for tables - letter positions move around within the lines depending what the text is. For tables,\nuse a fixed width routine - either the system 32 chars per line,\nor the [42 chars per line](print42.bas.md) version listed in the library.\n\n## usage\n\n`propPrint(xPosition, yPosition, SizeOfSpaceCharacter, GapBetweenLetters, \"Text\")`\n\n> Note: X and Y are pixel positions. Note that unlike Print and Print42, this routine in in the form (x,y), not (y,x). That can easily be changed in the declaration below. [Just swap x and y].\n\n`SizeOfSpaceCharacter` is the width of a space.\n`GapBetweenLetters` can be as small as zero - though the letters crash into each other,\nso it doesn't look wonderful. 1 pixel is probably the most common setting for this.\nText is anything that's valid as a string - either a `String` literal, or a variable.\n\n\n```\n' Proportional printing anywhere on screen.\n' Original routine by Christoph Odenthal (Odin)\n' ZXBC modification by Leszek Chmielewski (LCD)\n' Thanks to Boriel and Britlion for help and hints\n\nsub propPrint(x as ubyte,y as ubyte,spacesize as ubyte, xgap as ubyte,txt$ as string)\ndim b$ as string '\nb$=txt$+chr(0)\npoke Uinteger @PropPrintTxtadr,PEEK(Uinteger, @b$)+2 'textadr\npoke @PropPrintTxtadr+2,x\npoke @PropPrintTxtadr+3,y\npoke @PropPrintTxtadr+4,spacesize\npoke @PropPrintTxtadr+5,xgap\nPropPrint:\nAsm\n;' --------------------------------\n;'  Free Size N Place Text Print\n;' --------------------------------\n;' (c) 14.09.2002 C.Odenthal\n;'\n;' Last Modifications: 15.10.2002\n;' Modification for Boriels ZXBC\n;' By Leszek Chmielewski 02.06.2010\n;' --------------------------------\n;' ORG 32000\n;' DUMP 45000\n;' --------------------------------\n;' Entry point\n;' --------------------------------\nStart:\n   JR Start2\n;' --------------------------------\n;' Parameter\n;' --------------------------------\nend asm\nPropPrintTxtadr:\nasm\ntext_addr:\n   DEFW 0 ;' Addr of text\nx_pos:\n   DEFB 4 ;' Pos of text\ny_pos:\n   DEFB 4\nspc_size:\n   DEFB 3 ;' Width of space char\nx_gap:\n   DEFB 1 ;' Gap between chars\ny_gap:\n   DEFB 1 ;' Gap between lines\nend_symb:\n   DEFB 0 ;' End of line char code\nx_start:\n   DEFB 0 ;' Start of window\ny_start:\n   DEFB 0\nx_end:\n   DEFB 255 ;' End of window\ny_end:\n   DEFB 191\nx_zoom:\n   DEFB 1 ;' Zooming factor\ny_zoom:\n   DEFB 1\n\n;' --------------------------------\n;' Main routine\n;' --------------------------------\n\nStart2:\n   LD A,(x_pos) ;' Calc. scr addr.\n   LD B,A\n   LD A,(y_pos)\n   LD C,A\n   CALL PosToScr\n   LD (scr_ad),DE ;' Store scr addr.\n   LD A,L\n   LD (pix_pos),A\n   LD A,(end_symb) ;' Get line ending char\n   LD (poke_here+1),A ;' Poke it into memory below\n   LD HL,(text_addr)\nMain_Loop:\n   LD A,(HL);' Get char\npoke_here:\n   CP 0 ;' End of text? (poked!)\n   JP Z,Exit1\n   INC HL\n   PUSH HL\n   CP 32 ;' Replace ctrl chars\n   JP NC,No_Ctrl\n   LD A,32\nNo_Ctrl:\n   CALL Copy_Chr ;' Copy char-gfx to work-buffer\n   CALL Measure ;' Measure left rim + width\n   PUSH BC ;' (Save results)\n   LD A,C ;' No pixel set in char?\n   AND A\n   JP Z,Space_Chr\n   LD A,(pix_pos);' size+bitpos (=1..15)\n   ADD A,C\n   CP 9 ;' > 8 ?\n   JP NC,Overlap ;' Char overlaps\n;' Calculate 8 bit rotation\n   LD A,(pix_pos) ;' bitpos-l_rim (=-7..7)\n   SUB B\n   AND A ;' = 0 ?\n   JP Z,PrintIt8\n   JP C,Neg_8 ;' < 0 ?\n;' --------------------------------\n   CP 5 ;' Not in 1..4 ?\n   JP NC,Left_8\n;' --------------------------------\n   LD B,A\n   CALL Chr_Rgt8 ;' Rotate right 8 bit\n   JP PrintIt8\n;' --------------------------------\nLeft_8:\n   NEG ;' = 8 - A\n   ADD A,8\n   LD B,A\n   CALL Chr_Left8 ;' Rotate left 8 bit\n   JP PrintIt8\n;' --------------------------------\nNeg_8:\n   NEG\n   CP 5 ;' Not in 1..4 ?\n   JP NC,Right_8\n;' --------------------------------\n   LD B,A\n   CALL Chr_Left8 ;' Rotate left 8 bit\n   JP PrintIt8\n;' --------------------------------\nRight_8:\n   NEG ;' = 8 - A\n   ADD A,8\n   LD B,A\n   CALL Chr_Rgt8 ;' Rotate right 8 bit\n   JP PrintIt8\n;' --------------------------------\n;' Calculate 16 bit rotation\n;' --------------------------------\nOverlap:\n   LD A,(pix_pos);' bitpos-l_rim (=-7..7)\n   SUB B\n   AND A ;' = 0 ?\n   JP Z,PrintIt8\n;' --------------------------------\n   LD B,A\n   CALL Chr_Rgt16 ;' Rotate right 16 bit\nPrintIt16:\n   LD DE,(scr_ad);' Check for screen end\n   LD A,E\n   AND 31\n   CP 31 ;' (2nd byte outside ?)\n   JP Z,Outside\n   CALL Print16 ;' Display char (16 bit)\n   JP Next_Loc\n;' --------------------------------\nPrintIt8:\n   LD DE,(scr_ad);' Display char (8 bit)\n   CALL Print8\n   JP Next_Loc\n;' --------------------------------\nSpace_Chr:\n   LD A,(spc_size);' Skip pixels\n   LD DE,(scr_ad);' Get screen addr.\n   POP BC ;' Throw away values\n   LD B,0\n   LD C,A\n   JP Next_Loc2\n;' --------------------------------\nNext_Loc:\n   POP BC ;' Move to next char location\nNext_Loc2:\n   LD A,(pix_pos);' =bitpos+x_gap+size\n   LD L,A\n   LD A,(x_gap)\n   ADD A,L\n   ADD A ,C\n   LD L ,A\n   AND 7 ;' New pix_pos\n   LD (pix_pos),A\n   LD H,0 ;' =result/8\n   SRL L\n   SRL L\n   SRL L\n   ADD HL,DE ;' New byte pos\n   LD A ,E ;' Check for screen end\n   AND 31\n   LD E,A\n   LD A,L\n   AND 31\n   CP E ;' New pos smaller than old ?\n   JP C ,Exit2 ;' -> End of printing\n   LD (scr_ad),HL ;' Store new scr ad.\n   POP HL ;' Restore text pointer\n   JP Main_Loop\n;' --------------------------------\nOutside:\n   POP BC ;' Stop printing\n   POP HL ;' Char not printed!\n   DEC HL\n   JP Exit1\n;' --------------------------------\nExit2:\n   POP HL ;' Return nr of printed chars\nExit1:\n   LD DE,(text_addr)\n   XOR A\n   SBC HL,DE\n   LD B,H ;' Return value in BC to Basic\n   LD C,L\n    jp PropPrintTxtadr2\n;' --------------------------------\n;' Calc. scr adr from x,y\n;' --------------------------------\n;' In : B  = x / C = y (preserved)\n;' Out: DE = scr adr / L = pixpos\n;' Usd: A, BC, DE, L\n;' --------------------------------\nPosToScr:\n   LD A,C ;' Range check\n   CP 185\n   JP C,ValOk\n   LD C,184\nValOk:\n   LD A,B ;' Pix pos\n   AND 7\n   LD L,A\n   LD E,B\n   SRL E\n   SRL E\n   SRL E\n   LD A,C ;' Scr pos\n   AND 7\n   LD D,A\n   LD A,C\n   AND 56\n   RLA\n   RLA\n   OR E\n   LD E,A\n   LD A,C\n   AND 192\n   RRA\n   RRA\n   RRA\n   OR D\n   OR 64\n   LD D,A\n   RET\n;' --------------------------------\n;' Copy char into buffer\n;' --------------------------------\n;' In : A = Char\n;' Out: -\n;' Usd: A, HL, DE, BC\n;' --------------------------------\nCopy_Chr:\n   LD DE,(23606);' SysVar CHARS\n   LD H,0\n   LD L,A\n   ADD HL,HL ;' * 8\n   ADD HL,HL\n   ADD HL,HL\n   ADD HL,DE ;' + Chartable\n   EX DE,HL\n   LD HL,Chr_Buf\n   LD B,8\nCopy_Loop:\n   LD A,(DE);' Double to 16 pixel/row\n   INC DE\n   LD (HL),A ;' Low-byte in memory!\n   INC HL\n   LD (HL),0 ;' High-byte in memory!\n   INC HL\n   DJNZ Copy_Loop\n   RET\n;' --------------------------------\n;' Measure left border and width\n;' --------------------------------\n;' In : -\n;' Out: B = left rim / C = width\n;' Usd: A, HL, BC\n;' --------------------------------\nMeasure:\n   LD HL,Chr_Buf ;' \"OR\" together all 8 bytes\n   LD B,8\n   XOR A\nMsr_Loop:\n   OR (HL)\n   INC HL\n   INC HL\n   DJNZ Msr_Loop\n   LD BC,0\n   AND A ;' Check if zero\n   RET Z\nMsr_Loop2:\n   INC B ;' Measure left border\n   RLCA\n   JP NC,Msr_Loop2\n   RRCA\n   DEC B\n   LD C,9 ;' Measure width\nMsr_Loop3:\n   DEC C\n   RRCA\n   JP NC,Msr_Loop3\n   RET\n;' --------------------------------\n;' Move char to left, 8 bit\n;' --------------------------------\n;' In : B = Nr of bits to shift\n;' Out: -\n;' Usd: A, B, HL\n;' --------------------------------\nChr_Left8:\n   PUSH BC\n   LD HL,Chr_Buf ;' Rotate char left 8 bit\n   LD C,B ;' 1st row\n   LD A,(HL )\nChr_LLp1:\n   RLCA\n   DJNZ Chr_LLp1\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 2nd row\n   LD A,(HL)\nChr_LLp2:\n   RLCA\n   DJNZ Chr_LLp2\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 3rd row\n   LD A ,(HL)\nChr_LLp3:\n   RLCA\n   DJNZ Chr_LLp3\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 4th row\n   LD A,(HL)\nChr_LLp4:\n   RLCA\n   DJNZ Chr_LLp4\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 5th row\n   LD A,(HL)\nChr_LLp5:\n   RLCA\n   DJNZ Chr_LLp5\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 6th row\n   LD A,(HL)\nChr_LLp6:\n   RLCA\n   DJNZ Chr_LLp6\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 7th row\n   LD A,(HL)\nChr_LLp7:\n   RLCA\n   DJNZ Chr_LLp7\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 8th row\n   LD A,(HL)\nChr_LLp8:\n   RLCA\n   DJNZ Chr_LLp8\n   LD (HL),A\n   LD B,C\n   POP BC\n   RET\n;' --------------------------------\n;' Move char to right, 8 bit\n;' --------------------------------\n;' In : B = Nr of bits to shift\n;' Out: -\n;' Usd: A, B, HL\n;' --------------------------------\nChr_Rgt8:\n   PUSH BC\n   LD HL,Chr_Buf ;' Rotate char right 8 bit\n   LD C,B ;' 1st row\n   LD A,(HL)\nChr_RLp1:\n   RRCA\n   DJNZ Chr_RLp1\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 2nd row\n   LD A,(HL)\nChr_RLp2:\n   RRCA\n   DJNZ Chr_RLp2\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 3rd row\n   LD A,(HL)\nChr_RLp3:\n   RRCA\n   DJNZ Chr_RLp3\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 4th row\n   LD A,(HL)\nChr_RLp4:\n   RRCA\n   DJNZ Chr_RLp4\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 5th row\n   LD A,(HL)\nChr_RLp5:\n   RRCA\n   DJNZ Chr_RLp5\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 6th row\n   LD A ,(HL )\nChr_RLp6:\n   RRCA\n   DJNZ Chr_RLp6\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 7th row\n   LD A,(HL)\nChr_RLp7:\n   RRCA\n   DJNZ Chr_RLp7\n   LD (HL),A\n   LD B,C\n   INC HL\n   INC HL\n   LD C,B ;' 8th row\n   LD A,(HL)\nChr_RLp8:\n   RRCA\n   DJNZ Chr_RLp8\n   LD (HL),A\n   LD B,C\n   POP BC\n   RET\n;' --------------------------------\n;' Move char to right 16 bit\n;' --------------------------------\n;' In : B = Nr of bits to shift\n;' Out:\n;' Usd: A, B, HL\n;' --------------------------------\nChr_Rgt16:\n   LD HL,(Chr_Buf);' Rotate char right 16 bit\n   LD A,B ;' 1st row\nChr_R2Lp1:\n   SRL L\n   RR H ;' Insert carry\n   DJNZ Chr_R2Lp1\n   LD B,A\n   LD (Chr_Buf),HL\n   LD HL,(Chr_Buf+2);' 2nd row\n   LD A,B\nChr_R2Lp2:\n   SRL L\n   RR H ;' Insert carry\n   DJNZ Chr_R2Lp2\n   LD B,A\n   LD (Chr_Buf+2),HL\n   LD HL,(Chr_Buf+4);' 3rd row\n   LD A,B\nChr_R2Lp3:\n   SRL L\n   RR H ;' Insert carry\n   DJNZ Chr_R2Lp3\n   LD B,A\n   LD (Chr_Buf+4),HL\n   LD HL,(Chr_Buf+6);' 4th row\n   LD A,B\nChr_R2Lp4:\n   SRL L\n   RR H ;' Insert carry\n   DJNZ Chr_R2Lp4\n   LD B,A\n   LD (Chr_Buf+6),HL\n   LD HL,(Chr_Buf+8);' 5th row\n   LD A,B\nChr_R2Lp5:\n   SRL L\n   RR H ;' Insert carry\n   DJNZ Chr_R2Lp5\n   LD B,A\n   LD (Chr_Buf+8),HL\n   LD HL,(Chr_Buf+10);' 6th row\n   LD A,B\nChr_R2Lp6:\n   SRL L\n   RR H ;' Insert carry\n   DJNZ Chr_R2Lp6\n   LD B,A\n   LD (Chr_Buf+10),HL\n   LD HL,(Chr_Buf+12);' 7th row\n   LD A,B\nChr_R2Lp7:\n   SRL L\n   RR H ;' Insert carry\n   DJNZ Chr_R2Lp7\n   LD B,A\n   LD (Chr_Buf+12),HL\n   LD HL,(Chr_Buf+14);' 8th row\n   LD A,B\nChr_R2Lp8:\n   SRL L\n   RR H ;'Insert carry\n   DJNZ Chr_R2Lp8\n   LD B,A\n   LD (Chr_Buf+14),HL\n   RET\n;' --------------------------------\n;' Print 8 bit wide char on screen\n;' --------------------------------\n;' In : DE = screen adr.\n;' Out: -\n;' Usd: A, HL, DE, B\n;' --------------------------------\nPrint8:\n   LD HL,Chr_Buf\n   PUSH DE ;' save scr ad.\n   EX DE,HL\n   LD B,8 ;' 8 lines\nPrt8_L:\n   LD A,(DE);' set 1 byte\n   XOR (HL)\n   LD (HL),A\n   INC DE ;' skip 1 byte\n   INC DE ;' next byte\n   INC H ;' calc. next line\n   LD A,H\n   AND 7\n   JP NZ,Prt8_C\n   LD A,L\n   ADD A,32\n   LD L,A\n   JR C,Prt8_C\n   LD A,H\n   SUB 8\n   LD H,A\nPrt8_C:\n   DJNZ Prt8_L ;' next round\n   POP DE ;' restore scr ad.\n   RET\n;'--------------------------------\n;' Print 16 bit wide char on screen\n;' --------------------------------\n;' In : DE = screen adr.\n;' Out: -\n;' Usd: A, HL, DE, B\n;' --------------------------------\nPrint16:\n   LD HL,Chr_Buf\n   PUSH DE ;' save scr ad.\n   EX DE,HL\n   LD B,8 ;' 8 lines\nPrt16_L:\n   LD A,(DE);' set 1 byte\n   XOR (HL)\n   LD (HL),A\n   INC HL ;' next scr pos\n   INC DE ;' next byte\n   LD A,(DE);' set 1 byte\n   XOR (HL)\n   LD (HL),A\n   DEC HL ;' prev scr pos\n   INC DE ;' next byte\n   INC H ;' calc. next line\n   LD A,H\n   AND 7\n   JP NZ,Prt16_C\n   LD A,L\n   ADD A,32\n   LD L,A\n   JR C,Prt16_C\n   LD A,H\n   SUB 8\n   LD H,A\nPrt16_C:\n   DJNZ Prt16_L ;' next round\n   POP DE ;' restore scr ad.\n   RET\n;' --------------------------------\n;'  Variables\n;' --------------------------------\nChr_Buf:\n   DEFS 16\nscr_ad:\n   DEFW 0\npix_pos:\n   DEFB 0\n;' -----------------\nPropPrintTxtadr2:\nend asm\nend sub\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PUTCHARS.BAS": {
    "content": "# Putchars.bas\n\n## Putchars\n\n> **WARNING: This subroutine does not check to see if it's writing over the edge of the screen.\nThis is done for speed, but it is the user's job to make sure that all data will fit on the screen!**\n\n### Usage\nThere is a an example program that uses this at the end of the page.\n\n```\nputChars(x as uByte,y as uByte, width as uByte, height as uByte, dataAddress as uInteger)\n```\n\nWhere\n\n* x is the x value in character co-ordinates\n* y is the y value in character co-ordinates\n* width is the width in characters\n* height is the height in characters\n* dataaddress is the memory address of the UDG style bytes for the character being printed. 8 Bytes to a character. The order is top left to bottom right, first column, then second column, and so forth.\n\n\nPrints the graphics data to the screen at the given character co-ordinates.\n\n```\nSUB putChars(x as uByte,y as uByte, width as uByte, height as uByte, dataAddress as uInteger)\n' Copyleft Britlion. Feel free to use as you will. Please attribute me if you use this, however!\n\nAsm\n    BLPutChar:\n             LD      a,(IX+5)\n             ;AND     31\n             ld      l,a\n             ld      a,(IX+7) ; Y value\n             ld      d,a\n             AND     24\n             add     a,64 ; 256 byte \"page\" for screen - 256*64=16384. Change this if you are working with a screen address elsewhere, such as a buffer.\n             ld      h,a\n             ld      a,d\n             AND     7\n             rrca\n             rrca\n             rrca\n             OR      l\n             ld      l,a\n\n    PUSH HL ; save our address\n\n    LD E,(IX+12) ; data address\n    LD D,(IX+13)\n    LD B,(IX+9) ; width\n    PUSH BC ; save our column count\n\n    BLPutCharColumnLoop:\n\n    LD B,(IX+11) ; height\n\n    BLPutCharInColumnLoop:\n\n    ; gets screen address in HL, and bytes address in DE. Copies the 8 bytes to the screen\n    ld a,(DE) ; First Row\n    LD (HL),a\n\n    INC DE\n    INC H\n    ld a,(DE)\n    LD (HL),a ; second Row\n\n    INC DE\n    INC H\n    ld a,(DE)\n    LD (HL),a ; Third Row\n\n    INC DE\n    INC H\n    ld a,(DE)\n    LD (HL),a ; Fourth Row\n\n    INC DE\n    INC H\n    ld a,(DE)\n    LD (HL),a ; Fifth Row\n\n    INC DE\n    INC H\n    ld a,(DE)\n    LD (HL),a ; Sixth Row\n\n    INC DE\n    INC H\n    ld a,(DE)\n    LD (HL),a ; Seventh Row\n\n    INC DE\n    INC H\n    ld a,(DE)\n    LD (HL),a ; Eighth Row\n\n    INC DE ; Move to next data item.\n\n    DEC B\n    JR Z,BLPutCharNextColumn\n    ;The following code calculates the address of the next line down below current HL address.\n    PUSH DE ; save DE\n             ld   a,l\n             and  224\n             cp   224\n             jp   z,BLPutCharNextThird\n\n    BLPutCharSameThird:\n             ld   de,-1760\n             ;and  a\n             add  hl,de\n             POP DE ; get our data point back.\n             jp BLPutCharInColumnLoop\n\n    BLPutCharNextThird:\n             ld   de,32\n             ;and  a\n             add  hl,de\n             POP DE ; get our data point back.\n    JP BLPutCharInColumnLoop\n\n    BLPutCharNextColumn:\n    POP BC\n    POP HL\n    DEC B\n    JP Z, BLPutCharsEnd\n\n    INC L   ; Note this would normally be Increase HL - but block painting should never need to increase H, since that would wrap around.\n    PUSH HL\n    PUSH BC\n    JP BLPutCharColumnLoop\n\n\nBLPutCharsEnd:\n\nEnd Asm\nEND SUB\n```\n\n\n## Paint\n\nPrints the colour data to the screen at the given character co-ordinates.\n\n## Syntax\n```\npaint (x as uByte,y as uByte, width as uByte, height as uByte, attribute as ubyte)\n```\n\nWhere\n* x is the x value in character co-ordinates\n* y is the y value in character co-ordinates\n* width is the width in characters\n* height is the height in characters\n* attribute is the byte value of the attribute to paint to the given co-ordinates. (As one would get from the ATTR function)\n\n### Usage\nThere is a an example program after the source code.\n\n\n```\nSUB paint (x as uByte,y as uByte, width as uByte, height as uByte, attribute as ubyte)\nREM Copyleft Britlion. Feel free to use as you will. Please attribute me if you use this, however!\n\nAsm\n    ld      a,(IX+7)   ;ypos\n    rrca\n    rrca\n    rrca               ; Multiply by 32\n    ld      l,a        ; Pass to L\n    and     3          ; Mask with 00000011\n    add     a,88       ; 88 * 256 = 22528 - start of attributes. Change this if you are working with a buffer or somesuch.\n    ld      h,a        ; Put it in the High Byte\n    ld      a,l        ; We get y value *32\n    and     224        ; Mask with 11100000\n    ld      l,a        ; Put it in L\n    ld      a,(IX+5)   ; xpos\n    add     a,l        ; Add it to the Low byte\n    ld      l,a        ; Put it back in L, and we're done. HL=Address.\n\n    push HL            ; save address\n    LD A, (IX+13)      ; attribute\n    LD DE,32\n    LD c,(IX+11)       ; height\n\n    BLPaintHeightLoop:\n    LD b,(IX+9)        ; width\n\n    BLPaintWidthLoop:\n    LD (HL),a          ; paint a character\n    INC L              ; Move to the right (Note that we only would have to inc H if we are crossing from the right edge to the left, and we shouldn't be needing to do that)\n    DJNZ BLPaintWidthLoop\n\n    BLPaintWidthExitLoop:\n    POP HL             ; recover our left edge\n    DEC C\n    JR Z, BLPaintHeightExitLoop\n\n    ADD HL,DE          ; move 32 down\n    PUSH HL            ; save it again\n    JP BLPaintHeightLoop\n\n    BLPaintHeightExitLoop:\nend asm\nEND SUB\n```\n\n## PaintData\nCopies the colour data to the screen at the given character co-ordinates.\nThe order here is Rows and then Columns; so first row, then second row and so on.\nWhile this may be awkward, being the other way around to the pixel data, these orders\nare the most efficient speedwise.\n\nWhere\n* x is the x value in character co-ordinates\n* y is the y value in character co-ordinates\n* width is the width in characters\n* height is the height in characters\n* address is the address of the data to copy to the screen's attribute area.\n\n### Usage\nThere is a an example program that uses this at the end of the page.\n\n```\npaintData (x as uByte,y as uByte, width as uByte, height as uByte, address as uInteger)\n```\n\n```\nSUB paintData (x as uByte,y as uByte, width as uByte, height as uByte, address as uInteger)\nREM Copyleft Britlion. Feel free to use as you will. Please attribute me if you use this, however!\n\nAsm\n    ld      a,(IX+7)   ;ypos\n    rrca\n    rrca\n    rrca               ; Multiply by 32\n    ld      l,a        ; Pass to L\n    and     3          ; Mask with 00000011\n    add     a,88       ; 88 * 256 = 22528 - start of attributes. Change this if you are working with a buffer or somesuch.\n    ld      h,a        ; Put it in the High Byte\n    ld      a,l        ; We get y value *32\n    and     224        ; Mask with 11100000\n    ld      l,a        ; Put it in L\n    ld      a,(IX+5)   ; xpos\n    add     a,l        ; Add it to the Low byte\n    ld      l,a        ; Put it back in L, and we're done. HL=Address.\n\n    push HL            ; save address\n    LD D, (IX+13)\n    LD E, (IX+12)\n    LD c,(IX+11)       ; height\n\n    BLPaintDataHeightLoop:\n    LD b,(IX+9)        ; width\n\n    BLPaintDataWidthLoop:\n    LD a,(DE)\n    LD (HL),a          ; paint a character\n    INC L              ; Move to the right (Note that we only would have to inc H if we are crossing from the right edge to the left, and we shouldn't be needing to do that)\n    INC DE\n    DJNZ BLPaintDataWidthLoop\n\n    BLPaintDataWidthExitLoop:\n    POP HL             ; recover our left edge\n    DEC C\n    JR Z, BLPaintDataHeightExitLoop\n    PUSH DE\n    LD DE,32\n    ADD HL,DE          ; move 32 down\n    POP DE\n    PUSH HL            ; save it again\n    JP BLPaintDataHeightLoop\n\n    BLPaintDataHeightExitLoop:\nEnd Asm\nEND SUB\n```\n\n## Example Program\n\n```\ngoto start\n\ndatapoint:\nAsm\n    defb 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32\n    defb 33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64\n    defb 65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96\n    defb 97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128\nEnd Asm\n\nstart:\ncls\nputChars(10,10,3,3,@datapoint)\npaint(10,10,3,3,79)\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "PUTTILE": {
    "content": "# PutTile\n\n# putTile.bas\n\nThis subroutine takes a 2X2 tile of data from the given address and copies\nit to the screen co-ordinates at (x, y) - x and y in character addresses, where 0 <= x <= 31 and 0 <= y < =23.\n\nNote that this uses pushes and pops to move the data, using the fastest known data moving algorithm for the Z80.\nAs a consequence, while active it uses ALL the registers, including alternates and IY and IX as well as the\nStack Pointer SP. It is kind enough to put these back for the purposes of exiting the subroutine\nthough - ZX BASIC uses that register quite extensively.\n\nAlso, interrupts are disabled while the copying is happening. Considering that the stack pointer\nis likely pointing either at the screen or the tile data, an interrupt would be disastrous.\nIf interrupts were enabled when the SUB is called, it should re-enable them again on exit.\n\nNote the data format is across the tile - 2 bytes for the top row, then 2 bytes for the second row...and\nso on until there are 2 bytes for the 16th row. Then two bytes for the top two attributes, and 2 for the bottom.\nIt uses 36 bytes of data, starting at the address given.\n\n\n```\n' Routine to place a 16 pixel by 16 pixel \"Tile\" onto the screen at character position x,y from address given.\n' Data must be in the format of 16 bit rows, followed by attribute data.\n' (c) 2010 Britlion, donated to the ZX BASIC project.\n' Thanks to Boriel, LCD and Na_than for inspiration behind this.\n\n' This routine could be used as the basis for a fast sprite system, provided all sprites can be in 4 character blocks.\n' It can also be used to clean up dirty background (erase sprites), or put backgrounds from tiled blocks onto a screen.\n\n' Note the comments about Self Modifying code should be ignored. This has been updated with IX+n methods, which overall are faster than accessing and changing the code.\n' (They would have to be accessed to change the memory anyway - may as well just access them directly.)\n\nSUB putTile(x as uByte, y as uByte, graphicsAddr as uInteger)\n\nASM\nJP pt_start\n\nptstackSave:\ndefb 0,0\n\npt_start:\nld a,i\npush af ; Save interrupt status.\n\n; Routine to save the background to the buffer\n\n         DI ; we really, really, REALLY can NOT be having interrupts while the stack and IX and IY are pointed elsewhere.\n\n         PUSH IX\n         PUSH IY\n         ;ld      HL, 65535 ; Self modifying code should load this with the graphics address.\n         LD D,(IX+9)\n         LD E,(IX+8)\n         EX DE,HL\n\n;; Print sprites routine\n         LD (ptstackSave), SP ; Save Stack Pointer\n\n         LD SP,HL   ; now SP points at the start of the graphics.\n\n       ; This function returns the address into HL of the screen address\n         ld      a,(IX+5) ; Load in x - note the Self Modifying value\n         ld      IYH, a ; save it\n         ld      l,a\n         ld      a,(IX+7) ; Load in y - note the Self Modifying value\n         ld      IYL, a ; save it\n         ld      d,a\n         and     24\n         add     a,64\n         ld      h,a\n         ld      a,d\n         and     7\n         rrca\n         rrca\n         rrca\n         or      l\n         add     a,2   ; Need to be to the right so backwards writing pushes land properly.\n         ld      l,a\n\n         ; SO now, HL -> Screen address, and SP -> Graphics. Time to start loading.\n\n         POP BC    ; Row 0\n         POP DE    ; row 1\n         EX AF,AF'\n         POP AF    ; row 2\n         EX AF,AF'\n         EXX\n         POP BC    ; row 3\n         POP DE    ; row 4\n         POP HL    ; row 5\n         EXX\n\n         ; All right. We're loaded. Time to dump!\n\n         LD IX,0\n         ADD IX,SP  ; Save our stack pointer into IX\n\n         LD SP,HL  ; point at the screen.\n         PUSH BC   ; row 0\n\n         INC H\n         LD SP,HL\n         PUSH DE   ; row 1\n\n         INC H\n         LD SP,HL\n         EX AF,AF'\n         PUSH AF   ; row 2\n\n         INC H\n         LD SP,HL\n         EXX\n         PUSH BC   ; row 3\n         EXX\n\n         INC H\n         LD SP,HL\n         EXX\n         PUSH DE   ; row 4\n         EXX\n\n         INC H\n         LD SP,HL\n         EXX\n         PUSH HL   ; ROW 5\n         EXX\n\n         ; We're empty. Time to load up again.\n\n         LD SP,IX\n         POP BC    ; ROW 6\n         POP DE    ; ROW 7\n         EX AF,AF'\n         POP AF    ; ROW 8\n         EX AF,AF'\n         EXX\n         POP BC    ; ROW 9\n         POP DE    ; ROW 10\n         POP HL    ; ROW 11\n         EXX\n\n         ; and we're loaded up again! Time to dump this graphic on the screen.\n\n         LD IX,0\n         ADD IX,SP ; save SP in IX\n\n         INC H\n         LD SP,HL\n         PUSH BC   ; ROW 6\n\n         INC H\n         LD SP,HL\n         PUSH DE   ; ROW 7\n\n         DEC HL\n         DEC HL\n\n         ; Aha. Snag. We're at the bottom of a character. What's the next address down?\n         ld   a,l\n         and  224\n         cp   224\n         jp   z,ptSameThird3\n\nptNextThird3:\n         ld   de,1760\n         and  a\n         sbc  hl,de\n         jp ptAddrDone3\n\nptSameThird3:\n\n         ld   de,32\n         and  a\n         adc  hl,de\n\nptAddrDone3:\n\n          INC HL\n          INC HL\n\n          LD SP,HL\n          EX AF,AF'\n          PUSH AF  ; ROW 8\n\n          INC H\n          LD SP,HL\n          EXX\n          PUSH BC  ; ROW 9\n          EXX\n\n          INC H\n          LD SP,HL\n          EXX\n          PUSH DE  ; ROW 10\n          EXX\n\n          INC H\n          LD SP,HL\n          EXX\n          PUSH HL  ; ROW 11\n          EXX\n\n         ; Okay. Registers empty. Reload time!\n         LD SP,IX\n         POP BC    ; ROW 12\n         POP DE    ; ROW 13\n\n         EXX\n         POP BC    ; ROW 14\n         POP DE    ; ROW 15\n         POP HL    ; Top Attrs\n         EXX\n\n         EX AF,AF'\n         POP AF    ; Bottom Attrs\n         EX AF,AF'\n\n         ; and the last dump to screen\n\n         INC H\n         LD SP,HL\n         PUSH BC\n\n         INC H\n         LD SP,HL\n         PUSH DE\n\n         INC H\n         LD SP,HL\n         EXX\n         PUSH BC\n         EXX\n\n         INC H\n         LD SP,HL\n         EXX\n         PUSH DE\n         EXX\n\n         ; Pixels done. Just need to do the attributes.\n         ; So set HL to the attr address:\n\n         ld      a,IYL        ;ypos\n\n         rrca\n         rrca\n         rrca               ; Multiply by 32\n         ld      l,a        ; Pass to L\n         and     3          ; Mask with 00000011\n         add     a,88       ; 88 * 256 = 22528 - start of attributes.\n         ld      h,a        ; Put it in the High Byte\n         ld      a,l        ; We get y value *32\n         and     224        ; Mask with 11100000\n         ld      l,a        ; Put it in L\n         ld      a,IYH      ; xpos\n         adc     a,l        ; Add it to the Low byte\n         ld      l,a        ; Put it back in L, and we're done. HL=Address.\n         INC HL             ; we need to be to the right of the ATTR point as pushes write backwards.\n         INC HL\n\n         ; attr\n         LD SP,HL\n         EXX\n         PUSH HL            ; top row\n         EXX\n\n         LD HL,34           ; we need to move down to the next row. We already backed up 2, so we add 34.\n         ADD HL,SP\n         LD SP,HL\n         EX AF,AF'          ; bottom row\n         PUSH AF\n\nptNextSprite2:\n         ; done. Cleanup.\n         LD SP,(ptstackSave) ;  put our stack back together.\n\n         ; done all 4 final clean up\n\n         POP IY\n         POP IX\n\n         POP AF  ; recover interrupt status\n         JP PO, pt_nointerrupts\n         EI      ; Okay. We put everything back. If you need interrupts, you can go with em.\n\npt_nointerrupts:\nEND ASM\nEND SUB\n```\n\n## Usage\n\nExample:\n\n```\nputTile (10,10,@sprite)\n```\n\nWill copy a tile of data to print position 10,10 from address at label sprite.\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "RANDOMSTREAM.BAS": {
    "content": "# RandomStream.bas\n\nBritlion's Crazy Random Number generators! (Based completely on the stream generator from Patrik Rak,\nand much thanks for his work on this)\n\nBoriel has included a better random function in the code; but this passes through\nfloating point numbers, which is potentially fairly slow - and for games we usually\nrequire integer numbers anyway!\n\nI've written a few functions that are a possible alternative.\n\nThis is the base function that does the hard work of generating a random number\nfrom 0-255 in the A register (or as a return value, conveniently enough).\nThis is the same random number generator that Boriel is using, incidentally\n(based pretty much wholly on Patrik Rak's stream random generator, as posted on the World of Spectrum Forums).\n\nUpdate: Tweaked for Einar Saukas' optimization, September 2012.\n\nThe following function, randomBase, returns a pseudorandom value between 0 and 255 - that is a one byte return.\nThis is the base of Patrik Rak's random stream generator, and is the fastest function here.\nOther functions will call this one. **They will also call it FROM MACHINE CODE - so expect the ASM context\nlabel \"random\" to be there. If you change this label, you will have to also change the calling functions**\n\n\n```\nFUNCTION FASTCALL randomBase () AS UBYTE\nASM\nrandom:\n  ld  de,$A280   ; xz -> yw\n  ld  hl,$C0DE   ; yw -> zt\n  ld  (random+1),hl  ; x = y, z = w\n  ld  a,l         ; w = w ^ ( w << 3 )\n  add a,a\n  add a,a\n  add a,a\n  xor l\n  ld  l,a\n  ld  a,d         ; t = x ^ (x << 1)\n  add a,a\n  xor d\n  ld  h,a\n  rra             ; t = t ^ (t >> 1) ^ w\n  xor h\n  xor l\n  ld  h,e         ; y = z\n  ld  l,a         ; w = t\n  ld  (random+4),hl\nEND ASM\nEND FUNCTION\n```\n\nThis function will update the seed value based on the current frames counter.\nTo improve randomness, get the user to have a human interaction that can take a variable\namount of time and then run this.\n\n```\nSUB FASTCALL updateSeed()\nREM Updates the random generator seed from the FRAMES system variable.\ntime()\nASM\n   LD A,E\n   EX DE,HL\n   LD HL,random+2\n   XOR (HL)\n   AND A\n   JR NZ,updateSeedNotZero\n   INC A\nupdateSeedNotZero:\n   LD (HL),A\n   LD HL,random+4\n   LD A,E\n   XOR (HL)\n   LD (HL),A\n   INC HL\n   LD A,D\n   XOR (HL)\n   LD (HL),A\nEND ASM\nEND SUB\n```\n\nThe above function requires the timer function, which simply grabs the time from the\nframes variable and returns is as a unsigned-long variable, in registers DEHL:\n\n\n```\nFUNCTION FASTCALL time() as uLong\nasm\n    DI\n    LD DE,(23674)\n    LD D,0\n    LD HL,(23672)\n    EI\nend asm\nend function\n```\n\nThis function returns a value from zero to the specified limit number (limit <= 255).\nYou can therefore, for example, roll a dice by calling `randomLimit(5) + 1` to get 1-6.\n\n\n```\nFUNCTION fastcall randomLimit(limit as uByte) as uByte\nASM\n    AND A\n    RET Z ; Input zero, output zero.\n    LD B,A ; Save A\n\n    LD C,255\n    randomBinLoop:\n    RLA\n    JR C, randomBinLoopExit\n    RR C\n    JR randomBinLoop ; loop back until we find a bit.\n    randomBinLoopExit:\n\n    randomBinRedoCall:\n    call random\n    AND C\n    CP B\n    RET Z\n    JR NC, randomBinRedoCall\nEND ASM\nEND FUNCTION\n```\n\nIt's worth noting that the issue with the above is that it basically rolls a random, and if it's bigger than limit,\nit rolls another one. This could potentially take a while, and isn't guaranteed to be fast.\nThough the probability of failing to hit the zone is kept to 50% at worst, so on average it will roll 1.5\nrandom numbers, I think, per call. This should usually be faster than a floating point multiply, I believe.\n\nIf you want, in a similar way to sinclair basic and ZX BASIC RND function, a number between 0 and 1,\nthis function provides that, using a FIXED type return. This is usually good enough for most purposes,\nbut is quite a lot faster to process than a full floating point number.\n\n```\nFUNCTION FASTCALL randomFixed() as FIXED\nASM\n    call random\n    push AF\n    call random\n    ld l,A\n    POP AF\n    ld h,a\n    ld d,0\n    ld e,d\nEND ASM\nEND FUNCTION\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SCRADDRESS": {
    "content": "# ScrAddress\n\nThis function returns the address in screen memory of the TOP line of the character in print position X-Y.\nRemember that the next line will be 256 bytes further on, and the 3rd line 256 further again and so forth,\nfor 7 more lines.\n\n```\nFUNCTION scrAddress(x as uByte, y as uByte) as Uinteger\nasm\n; This function returns the address into HL of the screen address\n; x,y in character grid notation.\n; Original code was extracted by BloodBaz\n     ; x Arrives in A, y is in stack.\n     and     31\n     ld      l,a\n     ld      a,(IX+7) ; Y value\n     ld      d,a\n     and     24\n     add     a,64\n     ld      h,a\n     ld      a,d\n     and     7\n     rrca\n     rrca\n     rrca\n     or      l\n     ld      l,a\nend asm\nEND FUNCTION\n\n\nFUNCTION attrAddress (x as uByte, y as uByte) as uInteger\n';; This function returns the memory address of the Character Position\n';; x,y in the attribute screen memory.\n';; Adapted from code by Jonathan Cauldwell.\n\nasm\n     ld      a,(IX+7)        ;ypos\n     rrca\n     rrca\n     rrca               ; Multiply by 32\n     ld      l,a        ; Pass to L\n     and     3          ; Mask with 00000011\n     add     a,88       ; 88 * 256 = 22528 - start of attributes.\n     ld      h,a        ; Put it in the High Byte\n     ld      a,l        ; We get y value *32\n     and     224        ; Mask with 11100000\n     ld      l,a        ; Put it in L\n     ld      a,(IX+5)   ; xpos\n     add     a,l        ; Add it to the Low byte\n     ld      l,a        ; Put it back in L, and we're done. HL=Address.\nend asm\nEND FUNCTION\n```\n\nExamples of use (though more likely to be used as parameters to other screen handling functions):\n\n\n```\nPrint scrAddress(8,15)\nPrint attrAddress(8,15)\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SCREEN": {
    "content": "# SCREEN\n\n## Syntax\n\n\n```\nSCREEN$(row, col)\n```\n\n## Description\n\nReturns a string with the character (if possible) located at the given screen coordinate (row, column).\nThe character in the screen must exactly match the one in the current font character set being used.\n\n## Requirements\n\nSCREEN is a library function to be included with the following command:\n\n\n```\n# include <screen.bas>\n```\n\n## Sample usage\n\n```basic\n# include <screen.bas>\n\nPRINT AT 9, 10; \"A\"\nLET c$ = SCREEN$(9, 10)\nPRINT AT 0, 0; \"The character at 9, 10 is \"; c$\n```\n\n## Remarks\n\n* This function extends the one in Sinclair BASIC (and it's compatible with it) since it also allows rows 22 and 23.\n* When using _--sinclair_ cmd line parameter this function is already available (i.e. no _#include <screen.bas>_ sentence is needed)\n\n## See also\n\n* [ AT ](../at.md)\n* [ CSRLIN ](csrlin_.md)\n* [ POINT ](point.md)\n* [ POS](pos.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "STDLIB": {
    "content": "## Standard libraries\n\nThese are libraries that came bundled with ZX Basic Compiler.\nSome libraries might be available only for some architectures. If so,\nthey will be signaled as such. If no notice is shown, they are available for\nall.\n\n* [keys.bas](d)<br />\n  Faster and efficient way to detect keys pressed.\n\n* [string.bas](.md)<br />\n  Library for string manipulation.\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "STRING.BAS": {
    "content": "# STRING.BAS\n\nLibrary for generic string manipulation in Boriel ZX BASIC.\n\nBy default, the first character in a ZX BASIC string starts at position 0.\nThis is not very common in many BASIC dialects (i.e. Sinclair BASIC) were strings\nstart at position 1. This is done by efficiency. If you want your strings\nto start at position 1, compile with `--string-base=1`.\n\n\n### String slicing\nFunctions to retrieve a substring from a string:\n\n* [left](../string/left)\n* [mid](../string/mid)\n* [right](../string/right)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "WINDOWATTRSCROLLUP": {
    "content": "# WindowAttrScrollUp\n\n# BLAttrWindowScrollUp.bas\n\nThis subroutine specified rectangle of screen and scrolls up just the colour attributes up by a character.\nYou might be able to use it for games (though there are probably faster scrolly routines for that);\nbut the aim here is to be able to scroll up part of the screen, so that you can split between text on a rectangle\narea and other information elsewhere - e.g. graphic adventures.\nThis then is an addendum for [windowScrollUP.bas](windowscrollup.md), and can be called with it -\nprobably less useful in its own right. Note that it leaves the last line attributes untouched -\nit can't know inherently what colour to paint this section.\n\n```\nSUB BLAttrWindowScrollUp (X AS UBYTE, Y AS UBYTE, Width AS UBYTE, Height AS UBYTE)\nREM Routine, acting as a pair to BLWindowScrollUp.bas that moves the attributes up - and leaves the last ATTR line untouched (no way)\nASM\n    LD H,58h  ; $5800 = 22528 = Attr start\n    LD L,(IX+5) ; HL now contains correct column, but top row.\n\n    LD A,(IX+7) ; Y\n    CP 8\n    JR C, BLAttrWindowScrollUpGotRightThird\n    INC H\n    CP 16\n    JR C, BLAttrWindowScrollUpGotRightThird\n    INC H\n    BLAttrWindowScrollUpGotRightThird:\n    AND 7\n    RRCA\n    RRCA\n    RRCA  ; Three right rotates - same as 5 left rotates = A=A*32\n    ADD A,L\n    LD L,A ; HL now points to correct row, top left corner.\n\n    LD D,H\n    LD E,L ; Copy HL to DE\n\n    LD BC,32\n    ADD HL,BC ; Point HL at one row down.\n    LD C,(IX+9) ; width\n    LD B,(IX+11) ; Height\n    DEC B ; (We don't scroll past the end)\n\n    BLAttrWindowScrollUpHeightLoop:\n    PUSH BC ; Save our width and height\n    PUSH HL\n    LD B,0\n\n    BLAttrWindowScrollUpWidthLoop:\n    LDIR ; A one instruction width loop :P\n\n    POP DE ; Last run's source is now our destination\n    LD H,D\n    LD L,E ; Copy into HL\n    LD BC,32\n    ADD HL,BC ; Move HL down one row\n\n\n    POP BC ; get our counters back\n    DJNZ BLAttrWindowScrollUpHeightLoop ; Dec height, and if we haven't run out of rows, go do another one.\nEND ASM\nEND SUB\n```\n\n\n## Usage\n```\nBLAttrWindowScrollUp(TopLeftXCoordinate, TopLeftYCoordinate, WidthInCharacters, HeightInCharacters)\n```\n\nThe parameters are the X,Y print coordinates of the Top Left corner, width in characters, and height in characters.\n\nExample of use:\n\n```\nREM Put something on screen:\n\nFOR n=1 to 12\nPRINT INK RND *7; PAPER RND * 7; \"01234567890123456789012345678901\";\nPRINT INK RND *7; PAPER RND * 7; \"0ABCDEFGHI0KLMNOPQRS0UVWXYZABC0D\";\nNEXT n\n\nREM Scroll it slowly:\nFOR n=1 TO 10\nBLAttrWindowScrollUp (3,3,8,15)\nBLAttrWindowScrollUp (28,10,3,8)\nPAUSE 100\nNEXT n\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "WINDOWPAINT": {
    "content": "# WindowPaint\n\n##paintWindow\n\n>**WARNING: THIS subroutine does not check to see if it's writing over the edge of the\n> screen. This is done for speed, but it is the user's job to make sure that all\n> data will fit on the screen!**\n\nThis subroutine changes the attribute map without actually changing the bitmap that's in it. You can combine this with other routines, such as clearbox, to clear a screen area and reset the attributes, as well as fast plot and draw routines that don't deal with attributes themselves.\nAlso ideal (and originally designed for) use with `putChars`, which is a fast graphics print routine, that also doesn't do attributes directly.\nSprites can be worked up from this basis.\n\n###Usage\n\n```\nwindowPaint(x as uByte,y as uByte, width as uByte, height as uByte, inkCol as ubyte, paperCol as uByte, isBright as uByte, isFlash as uByte)\npaint (x as uByte,y as uByte, width as uByte, height as uByte, attribute as ubyte)\n```\n\n`windowPaint` calls paint with the required single attribute byte - it's perfectly reasonable to call it directly,\nif you have the full attribute value ready. windowPaint is really there to make it simpler to construct this byte.\n\n\nWhere\n* x is the x value in character co-ordinates\n* y is the y value in character co-ordinates\n* width is the width in characters\n* height is the height in characters\n\n\n```\nSUB windowPaint(x as uByte,y as uByte, width as uByte, height as uByte, inkCol as ubyte, paperCol as uByte, isBright as uByte, isFlash as uByte)\n    paint(x,y,width,height,(isFlash<<7) bOR (isBright<<6) bOR (paperCol<<3) bOR inkCol)\nEND SUB\n\n\nSUB paint (x as uByte,y as uByte, width as uByte, height as uByte, attribute as ubyte)\n    REM Copyleft Britlion. Feel free to use as you will. Please attribute me if you use this, however!\n\n    asm\n    ld      a,(IX+7)   ;ypos\n    rrca\n    rrca\n    rrca               ; Multiply by 32\n    ld      l,a        ; Pass to L\n    and     3          ; Mask with 00000011\n    add     a,88       ; 88 * 256 = 22528 - start of attributes. Change this if you are working with a buffer or somesuch.\n    ld      h,a        ; Put it in the High Byte\n    ld      a,l        ; We get y value *32\n    and     224        ; Mask with 11100000\n    ld      l,a        ; Put it in L\n    ld      a,(IX+5)   ; xpos\n    add     a,l        ; Add it to the Low byte\n    ld      l,a        ; Put it back in L, and we're done. HL=Address.\n\n    push HL            ; save address\n    LD A, (IX+13)      ; attribute\n    LD DE,32\n    LD c,(IX+11)       ; height\n\n    BLPaintHeightLoop:\n    LD b,(IX+9)        ; width\n\n    BLPaintWidthLoop:\n    LD (HL),a          ; paint a character\n    INC L              ; Move to the right (Note that we only would have to inc H if we are crossing from the right edge to the left, and we shouldn't be needing to do that)\n    DJNZ BLPaintWidthLoop\n\n    BLPaintWidthExitLoop:\n    POP HL             ; recover our left edge\n    DEC C\n    JR Z, BLPaintHeightExitLoop\n\n    ADD HL,DE          ; move 32 down\n    PUSH HL            ; save it again\n    JP BLPaintHeightLoop\n\n    BLPaintHeightExitLoop:\n    end asm\nEND SUB\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "WINDOWSCROLLUP": {
    "content": "# WindowScrollUp\n\n# BLWindowScrollUp.bas\n\nThis subroutine specified rectangle of screen and scrolls it up by a character.\nYou might be able to use it for games (though there are probably faster scrolly routines for that);\nbut the aim here is to be able to scroll up part of the screen, so that you can split between text on a rectangle area\nand other information elsewhere - e.g. graphic adventures.\n\n```\nSUB BLWindowScrollUp(X as uByte, Y as uByte, Width as uByte, Height as uByte)\nASM\n;Routine for printing and scrolling text in any\n;window, anywhere on the screen.\n\n;Main scrolling routine\nBLWindowScrollUp:\nEX AF, AF'\nLD   A,(IX+11)  ;(ROWS) Store # of Lines in A'\nEX AF,AF'\n\nLD   HL,BLWindowScrollUpScreenTable    ;Start of address table\nLD   C,(IX+7)   ;(Y) Move the \"pointer\" to the\nLD   B,0         ;appropriate position in the table\nADD  HL,BC       ;and store it in (BLWindowScrollPOINT)\nADD  HL,BC\nLD   (BLWindowScrollUpPOINT),HL  ;Pointer position stored\nBLWindowScrollUpLOOP:\n\n    LD   HL,(BLWindowScrollUpPOINT)\n    LD   E,(HL)\n    INC  HL\n    LD   D,(HL)\n\n    ;Address of start of screen line now in DE\n    LD A,(IX+5) ;(X)\n    ADD A,E\n    LD E,A\n\n    ;Address of left-hand side of window now in DE\n    EX AF,AF'\n    DEC  A\n    JP   Z,BLWindowScrollUpBLANK     ;Quit this loop if we have\n    EX AF,AF'\n    INC  HL          ;Move the pointer to the next item\n    LD   (BLWindowScrollUpPOINT),HL  ;in the table. Save position\n    LD   C,(HL)\n    INC  HL\n    LD   B,(HL)      ;Start of next line down in BC\n    LD   L,(IX+5)    ; (X)\n    LD   H,0\n    ADD  HL,BC\n    ;HL now points to the screen address 8 pixels below\n    ;the one held in DE\n    LD   B,8         ;8 pixel lines to be transferred\n    ;Now move 8 pixel lines up the screen by 8 pixels\n\n    BLWindowScrollUpTRANS:\n        LD A,B ; Save B\n        LD   C,(IX+9) ;(Cols)\n        LD   B,0\n        PUSH HL\n        PUSH DE          ;Save all registers\n        LDIR             ;Transfer the line of pixels\n        POP  DE\n        POP  HL\n\n        ;Move HL and DE down one pixel\n        INC D\n        INC H\n\n        LD B,A ; Recover B\n\n    DJNZ BLWindowScrollUpTRANS\n    ;One line of characters has now been transferred\n\nJP   BLWindowScrollUpLOOP        ;Back for next line of characters\n\n;Scrolling finished. Now erase last character line\nBLWindowScrollUpBLANK:\nLD   C,8\nLD   L,(IX+9) ; (COLS)\nBLWindowScrollUpLOOP2:\n\n    PUSH DE\n    LD   B,L ;(IX+11) - Cols\n    XOR  A\n    BLWindowScrollUpLOOP3:\n        LD   (DE),A\n        INC E\n    DJNZ BLWindowScrollUpLOOP3\n    POP  DE\n    INC D\n    DEC C\n    JR NZ, BLWindowScrollUpLOOP2\n\n;DJNZ BLWindowScrollUpLOOP2\nJP BLWindowScrollEnd\n\nBLWindowScrollUpPOINT:  DEFW 0\n\nBLWindowScrollUpScreenTable:\n       DEFW 16384\n       DEFW 16416\n       DEFW 16448\n       DEFW 16480\n       DEFW 16512\n       DEFW 16544\n       DEFW 16576\n       DEFW 16608\n       DEFW 18432\n       DEFW 18464\n       DEFW 18496\n       DEFW 18528\n       DEFW 18560\n       DEFW 18592\n       DEFW 18624\n       DEFW 18656\n       DEFW 20480\n       DEFW 20512\n       DEFW 20544\n       DEFW 20576\n       DEFW 20608\n       DEFW 20640\n       DEFW 20672\n       DEFW 20704\n\nBLWindowScrollEnd:\nEND ASM\nEND SUB\n```\n\n## Usage\n```\nBLWindowScrollUp(TopLeftXCoordinate, TopLeftYCoordinate, WidthInCharacters, HeightInCharacters)\n```\n\nThe parameters are the X,Y print coordinates of the Top Left corner, width in characters, and height in characters.\n\nExample in use:\n\n```\nREM Quick routine to fill the screen with crap so we can demonstrate scrolling.\nSUB fillRubbish()\nASM\n    LD DE,16384\n    LD HL,0\n    LD BC,6144\n    LDIR\nEND ASM\nEND SUB\n\nfillRubbish() ' Fill the screen with stuff.\n\n'actual use demo here:\n\nFOR n=1 to 10\nBLWindowScrollUp(3,3,8,15)\nBLWindowScrollUp(28,10,3,8)\nPAUSE 10\nNEXT n\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ZX0": {
    "content": "# ZX0\n\nThis is an interface library for using data compressor [ZX0](https://github.com/einar-saukas/ZX0)\nin ZX BASIC programs. For further details see:\n\n[https://github.com/einar-saukas/ZX0](https://github.com/einar-saukas/ZX0)\n\n\n## Syntax\n\nAvailable functions:\n\n```\ndzx0Standard(src, dst)\ndzx0StandardBack(src, dst)\ndzx0Turbo(src, dst)\ndzx0TurboBack(src, dst)\ndzx0Mega(src, dst)\ndzx0MegaBack(src, dst)\ndzx0SmartRCS(src, dst)\ndzx0SmartRCSBack(src, dst)\ndzx0AgileRCS(src, dst)\n```\n\nParameters:\n\n* `src` - source address of the compressed data\n* `dst` - destination address for the uncompressed data\n\n\n## Usage\n\nInclude this library in your program:\n\n```\n# include <zx0.bas>\n```\n\nAfterwards you can use any of the available [ZX0](https://github.com/einar-saukas/ZX0) functions in\nyour program. For instance:\n\n```\ndzx0Turbo(51200, 16384)\n```\n\nThe [ZX0](https://github.com/einar-saukas/ZX0) decompressors can be freely used without restrictions,\neven in commercial programs. Just please remember to mention [ZX0](https://github.com/einar-saukas/ZX0)\nin your documentation, as requested at the [ZX0](https://github.com/einar-saukas/ZX0) page.\n\n\n## Examples\n\nThe following program will decompress a compressed RCS+ZX0 image directly to the screen:\n\n```\n# include <zx0.bas>\n\n10 dzx0AgileRCS(@introscr, 16384)\n20 GOTO 20\n\nintroscr:\n    asm\n        incbin \"intro.scr.rcs.zx0\"\n    end asm\n```\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "GETMMU": {
    "content": "# GetMMU\r\n\r\n## Syntax\r\n\r\n```\r\nGetMMU(byval slot as ubyte) as ubyte\r\n```\r\n\r\n## Description\r\n\r\nA function that returns the current memory bank in numerical slot\r\n\r\n**Examples**\r\n\r\ndim a as ubyte \r\na = GetMMU($4)\t\t\t\t; read bank paged into slot 4\r\nPrint a \t\t\t\t; print the value\r\n\r\n## Links\r\n\r\n* [NextRegister](NextRegister)\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "GETREG": {
    "content": "# GetReg(register)\r\n\r\n## Syntax\r\n\r\n```\r\nn = GetReg(register)\r\n```\r\n\r\n## Description\r\n\r\nA function that returns the current value of a register. \r\n\r\n**Examples**\r\n```\r\ndim n as ubyte \r\nn = GetReg(MMU1_2000_NR_51)\t\t\t\t' read bank paged into slot 1, $2000-$3fff, register $51\r\nPrint n \t\t\t\t                ' print the value\r\n```\r\n\r\n## Links\r\n\r\n* [NextRegister](_registers.md)\r\n* [NextReg()](NextReg.md)\r\n* [NextRegA()](NextRegA.md)\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "NEXTBUILD_KEYWORDS": {
    "content": "# NextBuild Keywords\r\n\r\n## Keywords\r\n\r\n```BinToString```\r\n[BinToString(num as ubyte)](BinToString.md)\r\n\r\n```checkints```\r\n[checkints() as ubyte](checkints.md)\r\n\r\n```CIRCLEL2```\r\n[CIRCLEL2(x as ubyte, y as ubyte, radius as ubyte, col as ubyte)](CIRCLEL2.md)\r\n\r\n```ClipLayer2```\r\n[ClipLayer2(x1 as ubyte, x2 as ubyte, y1 as ubyte, y2 as ubyte)](ClipLayer2.md)\r\n\r\n```ClipSprite```\r\n[ClipSprite(x1 as ubyte, x2 as ubyte, y1 as ubyte, y2 as ubyte)](ClipSprite.md)\r\n\r\n```ClipTile```\r\n[ClipTile(x1 as ubyte, x2 as ubyte, y1 as ubyte, y2 as ubyte)](ClipTile.md)\r\n\r\n```ClipULA```\r\n[ClipULA(x1 as ubyte, x2 as ubyte, y1 as ubyte, y2 as ubyte)](ClipULA.md)\r\n\r\n```Console```\r\n[Console(db_string as string)](Console.md)\r\n\r\n```dbMemory```\r\n[dbMemory(db_address as uinteger, db_len as uinteger)](dbMemory.md)\r\n\r\n```Debug```\r\n[Debug(x as ubyte, y as ubyte, s as string)](Debug.md)\r\n\r\n```DisableShadow```\r\n[DisableShadow()](DisableShadow.md)\r\n\r\n```DoTile8```\r\n[DoTile8(X as ubyte, Y as ubyte, T as ubyte)](DoTile8.md)\r\n\r\n```DoTileBank16```\r\n[DoTileBank16(X as ubyte, Y as ubyte, T as ubyte, B as ubyte)](DoTileBank16.md)\r\n\r\n```DoTileBank8```\r\n[DoTileBank8(X as ubyte, Y as ubyte, T as ubyte, b as ubyte)](DoTileBank8.md)\r\n\r\n```DoTileBank8Test```\r\n[DoTileBank8Test(X as ubyte, Y as ubyte, T as ubyte, b as ubyte, c as ubyte)](DoTileBank8Test.md)\r\n\r\n```DrawImage```\r\n[DrawImage(xpos as uinteger, ypos as ubyte, img_data as uinteger, frame as ubyte)](DrawImage.md)\r\n\r\n```EnableShadow```\r\n[EnableShadow()](EnableShadow.md)\r\n\r\n```FDoTile16```\r\n[FDoTile16(tile as ubyte, x as ubyte, y as ubyte, bank as ubyte)](FDoTile16.md)\r\n\r\n```FDoTile8```\r\n[FDoTile8(tile as ubyte, x as ubyte, y as ubyte, bank as ubyte)](FDoTile8.md)\r\n\r\n```FL2Text```\r\n[FL2Text(x as ubyte, y as ubyte, m$ as string, fntbnk as ubyte)](FL2Text.md)\r\n\r\n```FlipBuffer```\r\n[FlipBuffer()](FlipBuffer.md)\r\n\r\n```FPlotL2```\r\n[FPlotL2(y as ubyte, x as uinteger, c as ubyte)](FPlotL2.md)\r\n\r\n```FPlotLineV```\r\n[FPlotLineV(y as ubyte, x as uinteger, h as ubyte, c as ubyte)](FPlotLineV.md)\r\n\r\n```FPlotLineW```\r\n[FPlotLineW(y as ubyte, x as uinteger, w as uinteger, c as ubyte)](FPlotLineW.md)\r\n\r\n```FreeBank```\r\n[FreeBank(bank as ubyte)](FreeBank.md)\r\n\r\n```GetMMU```\r\n[GetMMU(slot as ubyte) as ubyte](GetMMU.md)\r\n\r\n```GetReg```\r\n[GetReg(slot as ubyte) as ubyte](GetReg.md)\r\n\r\n```InitPalette```\r\n[InitPalette(pallete_sel as ubyte, bank as ubyte, start as uinteger, colcount as ubyte, offset as ubyte)](InitPalette.md)\r\n\r\n```InitSprites```\r\n[InitSprites(Total as ubyte, spraddress as uinteger, bank as uinteger)](InitSprites.md)\r\n\r\n```InitSprites2```\r\n[InitSprites2(Total as ubyte, spraddress as uinteger, bank as ubyte, sprite as ubyte)](InitSprites2.md)\r\n\r\n```L2Text```\r\n[L2Text(x as ubyte, y as ubyte, m$ as string, fntbnk as ubyte, colormask as ubyte)](L2Text.md)\r\n\r\n```LoadBMP```\r\n[LoadBMP(fname as string)](LoadBMP.md)\r\n\r\n```LoadBMPOld```\r\n[LoadBMPOld(fname as string)](LoadBMPOld.md)\r\n\r\n```LoadSD```\r\n[LoadSD(filen as string, address as uinteger, length as uinteger, offset as ulong)](LoadSD.md)\r\n\r\n```LoadSDBank```\r\n[LoadSDBank(filen as string, address as uinteger, length as uinteger, offset as ulong, bank as ubyte)](LoadSDBank.md)\r\n\r\n```MMU16```\r\n[MMU16(memorybank as ubyte)](MMU16.md)\r\n\r\n```MMU8```\r\n[MMU8(nn as ubyte, na as ubyte)](MMU8.md)\r\n\r\n```MMU8new```\r\n[MMU8new(slot as ubyte, memorybank as ubyte)](MMU8new.md)\r\n\r\n```NextRegA```\r\n[NextRegA(reg as ubyte, value as ubyte)](NextRegA.md)\r\n\r\n```NStr```\r\n[NStr(ins as ubyte) as string](NStr.md)\r\n\r\n```PalUpload```\r\n[PalUpload(address as uinteger, colours as ubyte, offset as ubyte, bank as ubyte)](PalUpload.md)\r\n\r\n```PlotL2```\r\n[PlotL2(X as ubyte, Y as ubyte, T as ubyte)](PlotL2.md)\r\n\r\n```PlotL2Shadow```\r\n[PlotL2Shadow(X as ubyte, Y as ubyte, T as ubyte)](PlotL2Shadow.md)\r\n\r\n```RemoveSprite```\r\n[RemoveSprite(spriteid as ubyte, visible as ubyte)](RemoveSprite.md)\r\n\r\n```ReserveBank```\r\n[ReserveBank() as ubyte](ReserveBank.md)\r\n\r\n```SaveSD```\r\n[SaveSD(filen as string, address as uinteger, length as uinteger)](SaveSD.md)\r\n\r\n```ScrollLayer```\r\n[ScrollLayer(x as ubyte, y as ubyte)](ScrollLayer.md)\r\n\r\n```swapbank```\r\n[swapbank(bank as ubyte)](swapbank.md)\r\n\r\n```TileMap```\r\n[TileMap(address as uinteger, blkoff as ubyte, numberoftiles as uinteger, x as ubyte, y as ubyte, width as ubyte, mapwidth as uinteger)](TileMap.md)\r\n\r\n```UpdateSprite```\r\n[UpdateSprite(x as uinteger, y as ubyte, spriteid as ubyte, pattern as ubyte, mflip as ubyte, anchor as ubyte)](UpdateSprite.md)\r\n\r\n```WaitKey```\r\n[WaitKey()](WaitKey.md)\r\n\r\n```WaitRetrace```\r\n[WaitRetrace(repeats as uinteger)](WaitRetrace.md)\r\n\r\n```WaitRetrace2```\r\n[WaitRetrace2(repeats as ubyte)](WaitRetrace2.md)\r\n\r\n```zx7Unpack```\r\n[zx7Unpack(source as uinteger, dest as uinteger)](zx7Unpack.md)\r\n\r\n@nextbuild_keywords.md ",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "AY_DATA_P_BFFD": {
    "content": "# AY_DATA_P_BFFD\r\n\r\n## Syntax\r\n\r\n```\r\nAY_DATA_P_BFFD = $BFFD\r\n```\r\n\r\n## Description\r\n\r\nAY_DATA_P_BFFD = $BFFD\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "AY_REG_P_FFFD": {
    "content": "# AY_REG_P_FFFD\r\n\r\n## Syntax\r\n\r\n```\r\nAY_REG_P_FFFD = $FFFD\r\n```\r\n\r\n## Description\r\n\r\nAY_REG_P_FFFD = $FFFD\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "DIVMMC_CONTROL_P_E3": {
    "content": "# DIVMMC_CONTROL_P_E3\r\n\r\n## Syntax\r\n\r\nisManualOnly: true\r\n\r\n```\r\nDIVMMC_CONTROL_P_E3 = $E3\r\n```\r\n\r\n## Description\r\n\r\nDIVMMC_CONTROL_P_E3 = $E3\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "I2C_SCL_P_103B": {
    "content": "# I2C_SCL_P_103B\r\n\r\n## Syntax\r\n\r\n```\r\nI2C_SCL_P_103B = $103B\r\n```\r\n\r\n## Description\r\n\r\nI2C_SCL_P_103B = $103B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "I2C_SDA_P_113B": {
    "content": "# I2C_SDA_P_113B\r\n\r\n## Syntax\r\n\r\n```\r\nI2C_SDA_P_113B = $113B\r\n```\r\n\r\n## Description\r\n\r\nI2C_SDA_P_113B = $113B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "KEMPSTON_JOY1_P_1F": {
    "content": "# KEMPSTON_JOY1_P_1F\r\n\r\n## Syntax\r\n\r\n```\r\nKEMPSTON_JOY1_P_1F = $1F\r\n```\r\n\r\n## Description\r\n\r\nKEMPSTON_JOY1_P_1F = $1F\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "KEMPSTON_JOY2_P_37": {
    "content": "# KEMPSTON_JOY2_P_37\r\n\r\n## Syntax\r\n\r\n```\r\nKEMPSTON_JOY2_P_37 = $37\r\n```\r\n\r\n## Description\r\n\r\nKEMPSTON_JOY2_P_37 = $37\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "KEMPSTON_MOUSE_B_P_FADF": {
    "content": "# KEMPSTON_MOUSE_B_P_FADF\r\n\r\n## Syntax\r\n\r\n```\r\nKEMPSTON_MOUSE_B_P_FADF = $FADF\r\n```\r\n\r\n## Description\r\n\r\nKEMPSTON_MOUSE_B_P_FADF = $FADF\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "KEMPSTON_MOUSE_X_P_FBDF": {
    "content": "# KEMPSTON_MOUSE_X_P_FBDF\r\n\r\n## Syntax\r\n\r\n```\r\nKEMPSTON_MOUSE_X_P_FBDF = $FBDF\r\n```\r\n\r\n## Description\r\n\r\nKEMPSTON_MOUSE_X_P_FBDF = $FBDF\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "KEMPSTON_MOUSE_Y_P_FFDF": {
    "content": "# KEMPSTON_MOUSE_Y_P_FFDF\r\n\r\n## Syntax\r\n\r\n```\r\nKEMPSTON_MOUSE_Y_P_FFDF = $FFDF\r\n```\r\n\r\n## Description\r\n\r\nKEMPSTON_MOUSE_Y_P_FFDF = $FFDF\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LAYER2_ACCESS_BANK_OFFSET": {
    "content": "# LAYER2_ACCESS_BANK_OFFSET\r\n\r\n## Syntax\r\n\r\n```\r\nLAYER2_ACCESS_BANK_OFFSET = $10\r\n```\r\n\r\n## Description\r\n\r\nLAYER2_ACCESS_BANK_OFFSET = $10\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LAYER2_ACCESS_L2_ENABLED": {
    "content": "# LAYER2_ACCESS_L2_ENABLED\r\n\r\n## Syntax\r\n\r\n```\r\nLAYER2_ACCESS_L2_ENABLED = $02\r\n```\r\n\r\n## Description\r\n\r\nLAYER2_ACCESS_L2_ENABLED = $02\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LAYER2_ACCESS_P_123B": {
    "content": "# LAYER2_ACCESS_P_123B\r\n\r\n## Syntax\r\n\r\n```\r\nLAYER2_ACCESS_P_123B = $123B\r\n```\r\n\r\n## Description\r\n\r\nLAYER2_ACCESS_P_123B = $123B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPI_CS_P_E7": {
    "content": "# SPI_CS_P_E7\r\n\r\n## Syntax\r\n\r\n```\r\nSPI_CS_P_E7 = $E7\r\n```\r\n\r\n## Description\r\n\r\nSPI_CS_P_E7 = $E7\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPI_DATA_P_EB": {
    "content": "# SPI_DATA_P_EB\r\n\r\n## Syntax\r\n\r\n```\r\nSPI_DATA_P_EB = $EB\r\n```\r\n\r\n## Description\r\n\r\nSPI_DATA_P_EB = $EB\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_ATTRIBUTE_P_57": {
    "content": "# SPRITE_ATTRIBUTE_P_57\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_ATTRIBUTE_P_57 = $57\r\n```\r\n\r\n## Description\r\n\r\nSPRITE_ATTRIBUTE_P_57 = $57\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_PATTERN_P_5B": {
    "content": "# SPRITE_PATTERN_P_5B\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_PATTERN_P_5B = $5B\r\n```\r\n\r\n## Description\r\n\r\nSPRITE_PATTERN_P_5B = $5B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "SPRITE_STATUS_SLOT_SELECT_P_303B": {
    "content": "# SPRITE_STATUS_SLOT_SELECT_P_303B\r\n\r\n## Syntax\r\n\r\n```\r\nSPRITE_STATUS_SLOT_SELECT_P_303B = $303B\r\n```\r\n\r\n## Description\r\n\r\nSPRITE_STATUS_SLOT_SELECT_P_303B = $303B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TBBLUE_REGISTER_ACCESS_P_253B": {
    "content": "# TBBLUE_REGISTER_ACCESS_P_253B\r\n\r\n## Syntax\r\n\r\n```\r\nTBBLUE_REGISTER_ACCESS_P_253B = $253B\r\n```\r\n\r\n## Description\r\n\r\nTBBLUE_REGISTER_ACCESS_P_253B = $253B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TBBLUE_REGISTER_SELECT_P_243B": {
    "content": "# TBBLUE_REGISTER_SELECT_P_243B\r\n\r\n## Syntax\r\n\r\n```\r\nTBBLUE_REGISTER_SELECT_P_243B = $243B\r\n```\r\n\r\n## Description\r\n\r\nTBBLUE_REGISTER_SELECT_P_243B = $243B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TIMEX_P_FF": {
    "content": "# TIMEX_P_FF\r\n\r\n## Syntax\r\n\r\n```\r\nTIMEX_P_FF = $FF\r\n```\r\n\r\n## Description\r\n\r\nTIMEX_P_FF = $FF\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "TURBO_SOUND_CONTROL_P_FFFD": {
    "content": "# TURBO_SOUND_CONTROL_P_FFFD\r\n\r\n## Syntax\r\n\r\n```\r\nTURBO_SOUND_CONTROL_P_FFFD = $FFFD\r\n```\r\n\r\n## Description\r\n\r\nTURBO_SOUND_CONTROL_P_FFFD = $FFFD\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "UART_CTRL_P_153B": {
    "content": "# UART_CTRL_P_153B\r\n\r\n## Syntax\r\n\r\n```\r\nUART_CTRL_P_153B = $153B\r\n```\r\n\r\n## Description\r\n\r\nUART_CTRL_P_153B = $153B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "UART_RX": {
    "content": "# UART RX ($143B)\n\n## Port Information\n\n| Property | Value |\n|----------|-------|\n| **Port Number** | $143B |\n| **Decimal** | 5179 |\n| **Bit Mask** | %0001 0100 0011 1011 |\n| **Readable** | Yes |\n| **Writable** | Yes |\n| **Subsystem** | UART |\n\n## Description\n\nReads data from serial port, write sets the baudrate.\n\n## Port Operations\n\n### Read Operation - Receive Data\n\nRead a byte from the receive buffer. **If the buffer is empty, 0 is returned.**\n\n**Important**: Always check [UART TX](uart_tx.md) ($133B) status bit 0 to verify data is available before reading to distinguish between actual zero bytes and empty buffer.\n\n### Write Operation - Baud Rate Configuration\n\nWrites the lower 14-bits of the UART's prescalar value that determines baud rate.\n\n#### Prescalar Format\n\n| Bit 7 | Function | Bits 6:0 |\n|-------|----------|----------|\n| **1** | Upper part | Upper 7-bits of the 14-bit prescalar value |\n| **0** | Lower part | Lower 7-bits of the 14-bit prescalar value |\n\n## Baud Rate Calculation\n\nThe UART's baud rate is determined by the prescalar according to this formula:\n\n```\nprescalar = Fsys / baudrate\n```\n\nWhere:\n- **Fsys** = system clock from [Video Timing Register](video_timing_register.md) ($11)\n- **baudrate** = desired communication speed\n\n### Example Calculation\n\nIf the system is HDMI, nextreg 0x11 indicates that Fsys = 27,000,000 Hz.\nThe prescalar for a baud rate of 115,200 is:\n\n```\nprescalar = 27,000,000 / 115,200 = 234 (decimal) = $EA (hex)\n```\n\n## Common Baud Rates\n\n### Standard Baud Rates (Fsys = 27 MHz)\n\n| Baud Rate | Prescalar (Dec) | Prescalar (Hex) | Upper 7-bits | Lower 7-bits |\n|-----------|-----------------|-----------------|--------------|--------------|\n| 9,600 | 2,812 | $AFC | $15 | $7C |\n| 19,200 | 1,406 | $57E | $0A | $7E |\n| 38,400 | 703 | $2BF | $05 | $3F |\n| 57,600 | 468 | $1D4 | $03 | $54 |\n| 115,200 | 234 | $0EA | $01 | $6A |\n| 230,400 | 117 | $075 | $00 | $75 |\n\n### Standard Baud Rates (Fsys = 28 MHz)\n\n| Baud Rate | Prescalar (Dec) | Prescalar (Hex) | Upper 7-bits | Lower 7-bits |\n|-----------|-----------------|-----------------|--------------|--------------|\n| 9,600 | 2,916 | $B64 | $16 | $64 |\n| 19,200 | 1,458 | $5B2 | $0B | $32 |\n| 38,400 | 729 | $2D9 | $05 | $59 |\n| 57,600 | 486 | $1E6 | $03 | $66 |\n| 115,200 | 243 | $0F3 | $01 | $73 |\n| 230,400 | 121 | $079 | $00 | $79 |\n\n## Usage Examples\n\n### Set Baud Rate to 115,200\n```assembly\n; For Fsys = 27 MHz, prescalar = 234 ($EA)\n; Upper 7 bits = $01, Lower 7 bits = $6A\n\n; Set lower 7 bits (bit 7 = 0)\nLD A, %01101010      ; $6A with bit 7 = 0\nOUT ($143B), A\n\n; Set upper 7 bits (bit 7 = 1)  \nLD A, %10000001      ; $01 with bit 7 = 1\nOUT ($143B), A\n```\n\n### Set Baud Rate to 9,600\n```assembly\n; For Fsys = 27 MHz, prescalar = 2812 ($AFC)\n; Upper 7 bits = $15, Lower 7 bits = $7C\n\n; Set lower 7 bits\nLD A, %01111100      ; $7C with bit 7 = 0\nOUT ($143B), A\n\n; Set upper 7 bits\nLD A, %10010101      ; $15 with bit 7 = 1\nOUT ($143B), A\n```\n\n### Read Received Data Safely\n```assembly\nreceive_byte:\n    ; Check if data is available\n    IN A, ($133B)       ; Read UART TX status\n    BIT 0, A            ; Test Rx data available bit\n    RET Z               ; Return if no data (Z flag set)\n    \n    ; Data is available, read it\n    IN A, ($143B)       ; Read received byte\n    ; A now contains the received byte\n    ; Z flag is clear indicating data was read\n    RET\n\n; Alternative with error checking\nreceive_byte_safe:\n    ; Check status and errors\n    IN A, ($133B)       ; Read status\n    BIT 6, A            ; Framing error?\n    JR NZ, rx_error     ; Handle error\n    BIT 2, A            ; Buffer overflow?\n    JR NZ, rx_error     ; Handle error\n    BIT 0, A            ; Data available?\n    RET Z               ; Return if no data\n    \n    ; Read the byte\n    IN A, ($143B)\n    RET                 ; Success\n\nrx_error:\n    ; Handle receive error\n    SCF                 ; Set carry flag to indicate error\n    RET\n```\n\n### Receive String with Timeout\n```assembly\n; Receive string into buffer at HL, max length in B\n; Returns with carry set on timeout/error\nreceive_string:\n    LD C, 0             ; Character count\n    LD D, 255           ; Timeout counter\n\nreceive_loop:\n    ; Check for timeout\n    DEC D\n    JR Z, receive_timeout\n\n    ; Check for data\n    IN A, ($133B)       ; Read status\n    BIT 0, A            ; Data available?\n    JR Z, receive_wait  ; Wait if no data\n    \n    ; Read character\n    IN A, ($143B)\n    \n    ; Check for end of string (CR or LF)\n    CP 13               ; Carriage return?\n    JR Z, receive_done\n    CP 10               ; Line feed?\n    JR Z, receive_done\n    \n    ; Store character\n    LD (HL), A\n    INC HL\n    INC C\n    \n    ; Check buffer full\n    LD A, C\n    CP B                ; Compare with max length\n    JR Z, receive_done  ; Buffer full\n    \n    JR receive_loop\n\nreceive_wait:\n    ; Small delay before retry\n    PUSH BC\n    LD BC, 1000         ; Delay loop\ndelay_loop:\n    DEC BC\n    LD A, B\n    OR C\n    JR NZ, delay_loop\n    POP BC\n    JR receive_loop\n\nreceive_timeout:\n    SCF                 ; Set carry for timeout\n    RET\n\nreceive_done:\n    XOR A\n    LD (HL), A          ; Null terminate string\n    OR A                ; Clear carry for success\n    RET\n```\n\n### Configure UART for ESP8266\n```assembly\n; Set up UART for ESP8266 communication at 115,200 baud\nsetup_esp_uart:\n    ; Calculate prescalar for current video timing\n    ; For most cases, this will be 27 MHz\n    \n    ; Set 115,200 baud (prescalar = 234 for 27 MHz)\n    LD A, %01101010      ; Lower 7 bits: $6A\n    OUT ($143B), A\n    LD A, %10000001      ; Upper 7 bits: $01  \n    OUT ($143B), A\n    \n    ; Optionally configure frame format\n    ; (see UART Control and UART Frame ports)\n    \n    RET\n```\n\n### Dynamic Baud Rate Setting\n```assembly\n; Set baud rate from 16-bit prescalar value in BC\nset_baud_rate:\n    ; Set lower 7 bits\n    LD A, C\n    AND %01111111       ; Mask bit 7\n    OUT ($143B), A\n    \n    ; Set upper 7 bits  \n    LD A, B\n    AND %01111111       ; Mask bit 7\n    OR %10000000        ; Set bit 7\n    OUT ($143B), A\n    \n    RET\n\n; Calculate prescalar for given baud rate\n; Input: DE = desired baud rate\n; Output: BC = prescalar value\ncalculate_prescalar:\n    ; This is a simplified version - real implementation\n    ; would need 32-bit division\n    ; Assumes Fsys = 27,000,000\n    \n    ; For demonstration, handle common rates\n    LD BC, 27000000 / 115200    ; Default to 115,200\n    \n    ; Compare with common rates and set accordingly\n    LD HL, 115200\n    OR A\n    SBC HL, DE\n    JR Z, calc_done\n    \n    ; Add more rate calculations as needed\n    \ncalc_done:\n    RET\n```\n\n## Important Notes\n\n### Data Availability\n- **Always check** [UART TX](uart_tx.md) status bit 0 before reading\n- **Empty buffer** returns 0, same as a received null byte\n- **Use status checking** to distinguish between cases\n\n### Baud Rate Setting\n- **14-bit prescalar** provides fine-grained control\n- **Two writes required** (lower then upper, or vice versa)\n- **System clock dependent** - check [Video Timing Register](video_timing_register.md) ($11)\n\n### System Clock Variations\n- **HDMI mode**: Typically 27 MHz\n- **VGA mode**: May use different clock\n- **Check nextreg $11** for actual system frequency\n\n## Related Ports\n\n- [UART TX](uart_tx.md) ($133B) - Transmit data and status\n- [UART Control](uart_control.md) ($153B) - UART configuration  \n- [UART Frame](uart_frame.md) ($163B) - Frame format settings\n- [Video Timing Register](video_timing_register.md) ($11) - System clock reference\n\n## Programming Tips\n\n1. **Always verify data availability** before reading\n2. **Set baud rate before** beginning communication\n3. **Handle receive errors** gracefully\n4. **Use appropriate timeouts** for reliable communication\n5. **Consider system clock changes** when setting baud rates\n6. **Test with known good devices** during development",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "UART_RX_P_143B": {
    "content": "# UART_RX_P_143B\r\n\r\n## Syntax\r\n\r\n```\r\nUART_RX_P_143B = $143B\r\n```\r\n\r\n## Description\r\n\r\nUART_RX_P_143B = $143B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "UART_TX": {
    "content": "# UART TX ($133B)\n\n## Port Information\n\n| Property | Value |\n|----------|-------|\n| **Port Number** | $133B |\n| **Decimal** | 4923 |\n| **Bit Mask** | %0001 0011 0011 1011 |\n| **Readable** | Yes |\n| **Writable** | Yes |\n| **Subsystem** | UART |\n\n## Description\n\nSends byte to serial port. If read, tells if data in RX buffer.\n\n## Port Data Format\n\n### Read Operation - Status Register\n\n| Bit | Function | Description |\n|-----|----------|-------------|\n| **7** | Break condition | 1 if the Rx is in a break condition<br/>External device has held Tx=0 for at least 20 bit periods |\n| **6** | Framing error | 1 if the Rx experienced a framing error<br/>Clears on read, includes parity and stop bit errors |\n| **5** | Error recovery | 1 if the next Rx byte was received after an error condition was detected (framing, overflow) |\n| **4** | Tx buffer empty | 1 if the Tx buffer is empty |\n| **3** | Rx buffer near full | 1 if the Rx buffer is near full (3/4 capacity) |\n| **2** | Rx buffer overflow | 1 if the Rx buffer overflowed<br/>Clears on read |\n| **1** | Tx buffer full | 1 if the Tx buffer is full |\n| **0** | Rx data available | 1 if the Rx buffer contains bytes |\n\n### Write Operation\n\nWriting to this port sends a byte to the connected device via the UART transmitter.\n\n## UART Status Monitoring\n\n### Transmission Status\n- **Bit 4**: Tx buffer empty - safe to send more data\n- **Bit 1**: Tx buffer full - must wait before sending\n\n### Reception Status  \n- **Bit 0**: Data available in Rx buffer\n- **Bit 3**: Rx buffer nearly full (3/4 capacity)\n- **Bit 2**: Rx buffer overflow occurred\n\n### Error Conditions\n- **Bit 7**: Break condition detected\n- **Bit 6**: Framing/parity/stop bit error\n- **Bit 5**: Data received after error condition\n\n## Usage Examples\n\n### Send a Byte\n```assembly\n; Wait for Tx buffer to be ready\nwait_tx_ready:\n    IN A, ($133B)       ; Read UART status\n    BIT 1, A            ; Test Tx buffer full flag\n    JR NZ, wait_tx_ready ; Wait if buffer full\n\n    ; Send the byte\n    LD A, 'H'           ; Character to send\n    OUT ($133B), A      ; Transmit byte\n```\n\n### Check for Received Data\n```assembly\n; Check if data is available\n    IN A, ($133B)       ; Read UART status\n    BIT 0, A            ; Test Rx data available\n    JR Z, no_data       ; Jump if no data\n\n    ; Data is available, read it\n    IN A, ($143B)       ; Read from UART RX port\n    ; Process received byte in A\n    CALL process_data\nno_data:\n```\n\n### Monitor Buffer Status\n```assembly\nuart_status_check:\n    IN A, ($133B)       ; Read status register\n    \n    ; Check for errors first\n    BIT 6, A            ; Framing error?\n    JR NZ, handle_framing_error\n    BIT 2, A            ; Overflow error?\n    JR NZ, handle_overflow_error\n    BIT 7, A            ; Break condition?\n    JR NZ, handle_break_condition\n    \n    ; Check buffer levels\n    BIT 3, A            ; Rx buffer near full?\n    JR NZ, drain_rx_buffer\n    BIT 0, A            ; Data available?\n    JR NZ, read_available_data\n    \n    RET\n\nhandle_framing_error:\n    ; Reading the status clears the error flag\n    ; Take appropriate action for framing error\n    CALL log_framing_error\n    RET\n\nhandle_overflow_error:\n    ; Reading the status clears the overflow flag\n    ; Data has been lost, reset communication\n    CALL reset_uart_comm\n    RET\n```\n\n### Robust Data Transmission\n```assembly\nsend_string:\n    ; HL points to null-terminated string\nsend_loop:\n    LD A, (HL)          ; Get next character\n    OR A                ; Check for null terminator\n    RET Z               ; Return if end of string\n    \n    ; Wait for transmitter ready\nwait_tx:\n    PUSH AF             ; Save character\n    IN A, ($133B)       ; Read status\n    BIT 1, A            ; Tx buffer full?\n    JR NZ, wait_tx      ; Wait if full\n    \n    ; Check for transmission errors\n    BIT 6, A            ; Framing error?\n    JR NZ, tx_error     ; Handle error\n    \n    POP AF              ; Restore character\n    OUT ($133B), A      ; Send character\n    INC HL              ; Next character\n    JR send_loop        ; Continue\n\ntx_error:\n    POP AF              ; Clean stack\n    ; Handle transmission error\n    RET\n```\n\n### High-Speed Data Transfer\n```assembly\nfast_transmit:\n    ; BC = byte count, HL = data buffer\nfast_tx_loop:\n    ; Quick status check\n    IN A, ($133B)\n    BIT 1, A            ; Tx buffer full?\n    JR NZ, fast_tx_loop ; Busy wait\n    \n    ; Send byte immediately\n    LD A, (HL)\n    OUT ($133B), A\n    INC HL\n    DEC BC\n    LD A, B\n    OR C\n    JR NZ, fast_tx_loop\n    RET\n```\n\n### Error Recovery Routine\n```assembly\nuart_error_recovery:\n    IN A, ($133B)       ; Read status (clears some errors)\n    \n    ; Log error conditions\n    BIT 7, A\n    CALL NZ, log_break_condition\n    BIT 6, A  \n    CALL NZ, log_framing_error\n    BIT 2, A\n    CALL NZ, log_overflow_error\n    \n    ; Flush buffers if needed\n    BIT 3, A            ; Rx near full?\n    JR Z, recovery_done\n    \nflush_rx:\n    IN A, ($143B)       ; Read and discard Rx data\n    IN A, ($133B)       ; Check status again\n    BIT 0, A            ; More data?\n    JR NZ, flush_rx     ; Continue flushing\n    \nrecovery_done:\n    RET\n```\n\n## UART Configuration\n\n### Related Ports\n- [UART RX](uart_rx.md) ($143B) - Receive data and baud rate setting\n- [UART Control](uart_control.md) ($153B) - UART configuration\n- [UART Frame](uart_frame.md) ($163B) - Frame format settings\n\n### Baud Rate Configuration\nBaud rate is set via [UART RX](uart_rx.md) port ($143B) write operation.\n\n### Buffer Management\n- **Tx Buffer**: Internal transmit buffer (size varies)\n- **Rx Buffer**: Internal receive buffer with overflow protection\n- **Flow Control**: Monitor buffer status for optimal performance\n\n## Programming Guidelines\n\n### Best Practices\n1. **Always check Tx buffer status** before sending\n2. **Monitor error flags** and implement recovery\n3. **Handle buffer overflow** gracefully\n4. **Use interrupts** for high-speed communication (if available)\n5. **Implement timeouts** for robust communication\n\n### Performance Tips\n- **Batch operations** when possible\n- **Pre-check buffer status** before loops\n- **Use error recovery** to maintain communication\n- **Consider hardware flow control** for reliable transfers\n\n### Error Handling\n- **Read status register** to clear error flags\n- **Implement retry logic** for failed transmissions\n- **Log errors** for debugging purposes\n- **Flush buffers** after error conditions\n\n## Hardware Notes\n\n### Electrical Interface\n- **RS-232 compatible** voltage levels\n- **ESP8266 WiFi module** connection supported\n- **Serial debugging** capability\n\n### Physical Connection\n- **J9 connector** on Next board\n- **Shared with ESP8266** WiFi module\n- **External serial devices** via appropriate adapters\n\n## Related Components\n\n- [ESP8266-01](esp8266_01.md) - WiFi module using UART\n- [Pi UART](pi_uart.md) - Raspberry Pi communication\n- Serial debugging and development tools",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "UART_TX_P_133B": {
    "content": "# UART_TX_P_133B\r\n\r\n## Syntax\r\n\r\n```\r\nUART_TX_P_133B = $133B\r\n```\r\n\r\n## Description\r\n\r\nUART_TX_P_133B = $133B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ULA_P_FE": {
    "content": "# ULA_P_FE\r\n\r\n## Syntax\r\n\r\n```\r\nULA_P_FE = $FE\r\n```\r\n\r\n## Description\r\n\r\nULA_P_FE = $FE\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "Z80_DMA_PORT_DATAGEAR": {
    "content": "# Z80_DMA_PORT_DATAGEAR\r\n\r\n## Syntax\r\n\r\n```\r\nZ80_DMA_PORT_DATAGEAR = $6B\r\n```\r\n\r\n## Description\r\n\r\nZ80_DMA_PORT_DATAGEAR = $6B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "Z80_DMA_PORT_MB02": {
    "content": "# Z80_DMA_PORT_MB02\r\n\r\n## Syntax\r\n\r\n```\r\nZ80_DMA_PORT_MB02 = $0B\r\n```\r\n\r\n## Description\r\n\r\nZ80_DMA_PORT_MB02 = $0B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ZILOG_DMA_P_0B": {
    "content": "# ZILOG_DMA_P_0B\r\n\r\n## Syntax\r\n\r\n```\r\nZILOG_DMA_P_0B = $0B\r\n```\r\n\r\n## Description\r\n\r\nZILOG_DMA_P_0B = $0B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ZX128P3_MEMORY_P_1FFD": {
    "content": "# ZX128P3_MEMORY_P_1FFD\r\n\r\n## Syntax\r\n\r\n```\r\nZX128P3_MEMORY_P_1FFD = $1FFD\r\n```\r\n\r\n## Description\r\n\r\nZX128P3_MEMORY_P_1FFD = $1FFD\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ZX128_MEMORY_P_7FFD": {
    "content": "# ZX128_MEMORY_P_7FFD\r\n\r\n## Syntax\r\n\r\n```\r\nZX128_MEMORY_P_7FFD = $7FFD\r\n```\r\n\r\n## Description\r\n\r\nZX128_MEMORY_P_7FFD = $7FFD\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ZX128_MEMORY_P_DFFD": {
    "content": "# ZX128_MEMORY_P_DFFD\r\n\r\n## Syntax\r\n\r\n```\r\nZX128_MEMORY_P_DFFD = $DFFD\r\n```\r\n\r\n## Description\r\n\r\nZX128_MEMORY_P_DFFD = $DFFD\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "ZXN_DMA_P_6B": {
    "content": "# ZXN_DMA_P_6B\r\n\r\n## Syntax\r\n\r\n```\r\nZXN_DMA_P_6B = $6B\r\n```\r\n\r\n## Description\r\n\r\nZXN_DMA_P_6B = $6B\r\n\r\nMore info : https://wiki.specnext.dev/Board_feature_control\r\n\r\nRequires: \r\n\r\n\t#INCLUDE <nextlib.bas>\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "'!HEAP": {
    "content": "# '!heap\n\n## Syntax\n\n```\n'!heap=uinterger\n```\n\n## Description\n\nSets the amount of RAM used for the HEAP, must be at the start of the program.\n\n**Examples**\n\n'!heap=$2048\n\n## Links\n\n* [PreCompiler](_PreCompiler.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "BINTOSTRING": {
    "content": "# BINTOSTRING(uByte)\r\n\r\n## Syntax\r\n\r\n```\r\n n$ = BinToString(uByte)        \r\n```\r\n\r\n```\r\nDim a as uByte = $F0\r\nPrint BinToString(uByte)       \r\n```\r\nWill print: \r\n```\r\n11110000\r\n```\r\n## Description\r\n\r\nReturns a string binary representation of a uByte.\r\n\r\n## Requires:\r\n```\r\n\r\n#INCLUDE <nextlib.bas>\r\n```\r\n## Links \r\n\r\n[Index](Index.md) \r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "LEFT": {
    "content": "# LEFT\n\nLibrary: `#include <string.bas>`\n\nReturns the first n chars of a string\n\n\n### Syntax\n`left(s$, N)`\n\nReturns a substring of s$ of at most `N` characters starting from the left side.\n\n * If the string length is shorter than `N`, the entire string will be returned.\n\n`left(s$, N)` is equivalent to `s$(TO N - 1)`\n\n## Examples\n\n```basic\n# include <string.bas>\n\nPRINT left(\"HELLO WORLD\", 5)\n```\nWill print `HELLO`.\n\n---\n\n```basic\n# include <string.bas>\n\nPRINT left(\"HELLO WORLD\", 20)\n```\nThis will print `HELLO WORLD`. Despite asking for 20 chars, the string contains\njust 11 chars, so we get the entire string (they won't be filled with spaces).\n\n\n### See also\n\n * [mid](mid.md)\n * [right](right.md)\n\n\nBack to parent page: [String library](../string.bas.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "MID": {
    "content": "# MID\n\nLibrary: `#include <string.bas>`\n\nReturn a portion of a string.\n\n\n### Syntax\n`mid(s$, start, N)`\n\nReturns a substring of s$ of at most `N` characters starting at the given\n`start` position.\n\n * If the string length is shorter than `start + N` position (the `end` position is\nbeyond the end of the string), the substring starting from `start` position will\nbe returned.\n\n * If the start position is beyond the end of the string, an empty string\nwill be returned.\n\n`mid(s$, start, N)` is equivalent to `s$(start TO start + N - 1)`\n\n## Examples\n\n```basic\n# include <string.bas>\n\nPRINT mid(\"HELLO WORLD\", 0, 5)\n```\nWill print `HELLO`.\n\n---\n\n```basic\n# include <string.bas>\n\nPRINT mid(\"HELLO WORLD\", 6, 8)\n```\nThis will print just `WORLD`.\nIt'll start at position 6-th (for a 0-based string this is 7-th char), and print\nup to 8 chars, but since there are only 5, it will get just `WORLD`.\n\n---\n\n```basic\n# include <string.bas>\n\nPRINT mid(\"HELLO WORLD\", 12, 5)\n```\nThis will print just an empty string: start position is beyond the end\nof the string.\n\n\n### See also\n\n * [left](left.md)\n * [right](right.md)\n\n\nBack to parent page: [String library](../string.bas.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "RIGHT": {
    "content": "# RIGHT\n\nLibrary: `#include <string.bas>`\n\nReturns the last n chars of a string\n\n\n### Syntax\n`right(s$, N)`\n\nReturns a substring of s$ of at most `N` characters starting from the right side.\n\n * If the string length is shorter than `N`, the entire string will be returned.\n\n`right(s$, N)` is equivalent to `s$(len(s$) - N - 1 TO)`\n\n## Examples\n\n```basic\n# include <string.bas>\n\nPRINT right(\"HELLO WORLD\", 5)\n```\nWill print `WORLD`.\n\n---\n\n```basic\n# include <string.bas>\n\nPRINT left(\"HELLO WORLD\", 20)\n```\nThis will print `HELLO WORLD`. Despite asking for 20 chars, the string contains\njust 11 chars, so we get the entire string (they won't be filled with spaces).\n\n\n### See also\n\n * [left](left.md)\n * [mid](mid.md)\n\n\nBack to parent page: [String library](../string.bas.md)\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "_NEXTBUILD": {
    "content": "# NextBuild Keywords\r\n\r\n## Keywords\r\n\r\n```BinToString```\r\n[BinToString(num as ubyte)](BinToString.md)\r\n\r\n```checkints```\r\n[checkints() as ubyte](checkints.md)\r\n\r\n```CIRCLEL2```\r\n[CIRCLEL2(x as ubyte, y as ubyte, radius as ubyte, col as ubyte)](CIRCLEL2.md)\r\n\r\n```ClipLayer2```\r\n[ClipLayer2(x1 as ubyte, x2 as ubyte, y1 as ubyte, y2 as ubyte)](ClipLayer2.md)\r\n\r\n```ClipSprite```\r\n[ClipSprite(x1 as ubyte, x2 as ubyte, y1 as ubyte, y2 as ubyte)](ClipSprite.md)\r\n\r\n```ClipTile```\r\n[ClipTile(x1 as ubyte, x2 as ubyte, y1 as ubyte, y2 as ubyte)](ClipTile.md)\r\n\r\n```ClipULA```\r\n[ClipULA(x1 as ubyte, x2 as ubyte, y1 as ubyte, y2 as ubyte)](ClipULA.md)\r\n\r\n```Console```\r\n[Console(db_string as string)](Console.md)\r\n\r\n```dbMemory```\r\n[dbMemory(db_address as uinteger, db_len as uinteger)](dbMemory.md)\r\n\r\n```Debug```\r\n[Debug(x as ubyte, y as ubyte, s as string)](Debug.md)\r\n\r\n```DisableShadow```\r\n[DisableShadow()](DisableShadow.md)\r\n\r\n```DoTile8```\r\n[DoTile8(X as ubyte, Y as ubyte, T as ubyte)](DoTile8.md)\r\n\r\n```DoTileBank16```\r\n[DoTileBank16(X as ubyte, Y as ubyte, T as ubyte, B as ubyte)](DoTileBank16.md)\r\n\r\n```DoTileBank8```\r\n[DoTileBank8(X as ubyte, Y as ubyte, T as ubyte, b as ubyte)](DoTileBank8.md)\r\n\r\n```DoTileBank8Test```\r\n[DoTileBank8Test(X as ubyte, Y as ubyte, T as ubyte, b as ubyte, c as ubyte)](DoTileBank8Test.md)\r\n\r\n```DrawImage```\r\n[DrawImage(xpos as uinteger, ypos as ubyte, img_data as uinteger, frame as ubyte)](DrawImage.md)\r\n\r\n```EnableShadow```\r\n[EnableShadow()](EnableShadow.md)\r\n\r\n```FDoTile16```\r\n[FDoTile16(tile as ubyte, x as ubyte, y as ubyte, bank as ubyte)](FDoTile16.md)\r\n\r\n```FDoTile8```\r\n[FDoTile8(tile as ubyte, x as ubyte, y as ubyte, bank as ubyte)](FDoTile8.md)\r\n\r\n```FL2Text```\r\n[FL2Text(x as ubyte, y as ubyte, m$ as string, fntbnk as ubyte)](FL2Text.md)\r\n\r\n```FlipBuffer```\r\n[FlipBuffer()](FlipBuffer.md)\r\n\r\n```FPlotL2```\r\n[FPlotL2(y as ubyte, x as uinteger, c as ubyte)](FPlotL2.md)\r\n\r\n```FPlotLineV```\r\n[FPlotLineV(y as ubyte, x as uinteger, h as ubyte, c as ubyte)](FPlotLineV.md)\r\n\r\n```FPlotLineW```\r\n[FPlotLineW(y as ubyte, x as uinteger, w as uinteger, c as ubyte)](FPlotLineW.md)\r\n\r\n```FreeBank```\r\n[FreeBank(bank as ubyte)](FreeBank.md)\r\n\r\n```GetMMU```\r\n[GetMMU(slot as ubyte) as ubyte](GetMMU.md)\r\n\r\n```GetReg```\r\n[GetReg(slot as ubyte) as ubyte](GetReg.md)\r\n\r\n```InitPalette```\r\n[InitPalette(pallete_sel as ubyte, bank as ubyte, start as uinteger, colcount as ubyte, offset as ubyte)](InitPalette.md)\r\n\r\n```InitSprites```\r\n[InitSprites(Total as ubyte, spraddress as uinteger, bank as uinteger)](InitSprites.md)\r\n\r\n```InitSprites2```\r\n[InitSprites2(Total as ubyte, spraddress as uinteger, bank as ubyte, sprite as ubyte)](InitSprites2.md)\r\n\r\n```L2Text```\r\n[L2Text(x as ubyte, y as ubyte, m$ as string, fntbnk as ubyte, colormask as ubyte)](L2Text.md)\r\n\r\n```LoadBMP```\r\n[LoadBMP(fname as string)](LoadBMP.md)\r\n\r\n```LoadBMPOld```\r\n[LoadBMPOld(fname as string)](LoadBMPOld.md)\r\n\r\n```LoadSD```\r\n[LoadSD(filen as string, address as uinteger, length as uinteger, offset as ulong)](LoadSD.md)\r\n\r\n```LoadSDBank```\r\n[LoadSDBank(filen as string, address as uinteger, length as uinteger, offset as ulong, bank as ubyte)](LoadSDBank.md)\r\n\r\n```MMU16```\r\n[MMU16(memorybank as ubyte)](MMU16.md)\r\n\r\n```MMU8```\r\n[MMU8(nn as ubyte, na as ubyte)](MMU8.md)\r\n\r\n```MMU8new```\r\n[MMU8new(slot as ubyte, memorybank as ubyte)](MMU8new.md)\r\n\r\n```NextRegA```\r\n[NextRegA(reg as ubyte, value as ubyte)](NextRegA.md)\r\n\r\n```NStr```\r\n[NStr(ins as ubyte) as string](NStr.md)\r\n\r\n```PalUpload```\r\n[PalUpload(address as uinteger, colours as ubyte, offset as ubyte, bank as ubyte)](PalUpload.md)\r\n\r\n```PlotL2```\r\n[PlotL2(X as ubyte, Y as ubyte, T as ubyte)](PlotL2.md)\r\n\r\n```PlotL2Shadow```\r\n[PlotL2Shadow(X as ubyte, Y as ubyte, T as ubyte)](PlotL2Shadow.md)\r\n\r\n```RemoveSprite```\r\n[RemoveSprite(spriteid as ubyte, visible as ubyte)](RemoveSprite.md)\r\n\r\n```ReserveBank```\r\n[ReserveBank() as ubyte](ReserveBank.md)\r\n\r\n```SaveSD```\r\n[SaveSD(filen as string, address as uinteger, length as uinteger)](SaveSD.md)\r\n\r\n```ScrollLayer```\r\n[ScrollLayer(x as ubyte, y as ubyte)](ScrollLayer.md)\r\n\r\n```swapbank```\r\n[swapbank(bank as ubyte)](swapbank.md)\r\n\r\n```TileMap```\r\n[TileMap(address as uinteger, blkoff as ubyte, numberoftiles as uinteger, x as ubyte, y as ubyte, width as ubyte, mapwidth as uinteger)](TileMap.md)\r\n\r\n```UpdateSprite```\r\n[UpdateSprite(x as uinteger, y as ubyte, spriteid as ubyte, pattern as ubyte, mflip as ubyte, anchor as ubyte)](UpdateSprite.md)\r\n\r\n```WaitKey```\r\n[WaitKey()](WaitKey.md)\r\n\r\n```WaitRetrace```\r\n[WaitRetrace(repeats as uinteger)](WaitRetrace.md)\r\n\r\n```WaitRetrace2```\r\n[WaitRetrace2(repeats as ubyte)](WaitRetrace2.md)\r\n\r\n```zx7Unpack```\r\n[zx7Unpack(source as uinteger, dest as uinteger)](zx7Unpack.md)\r\n\r\n",
    "category": "nextlib",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "README": {
    "content": "<style>\r\n  .highlight {\r\n    background-color: #222;\r\n    color: #ffd700;\r\n    padding: 4px 8px;\r\n    border-radius: 4px;\r\n  }\r\n  .section {\r\n    background-color: #1a1a1a;\r\n    border-left: 4px solid #007acc;\r\n    padding: 10px;\r\n    margin-bottom: 12px;\r\n  }\r\n  .note {\r\n    background: #2c2c2c;\r\n    padding: 10px;\r\n    border-left: 4px solid #66bb6a;\r\n    margin-top: 10px;\r\n  }\r\n</style>\r\n\r\n# 🎉 <span style=\"color:#4ec9b0;\">Welcome To</span>\r\n<img src=\"./Docs/NB-1024x169.png\" alt=\"NextBuildStudio\" width=\"40%\"> \r\n\r\n### <span class=\"highlight\">v2025.11.06 </span> &nbsp;&nbsp;🔗 [zxnext.uk/nextbuild](https://zxnext.uk/nextbuild)\r\n\r\n---\r\n\r\nWelcome to **NextBuild Studio (NBS)** — your one-stop shop for building and creating exciting new **ZX Spectrum Next** games and applications.\r\n\r\nBuilt on the powerful [**Boriel ZX Basic Compiler**](https://github.com/boriel-basic/zxbasic) by [boriel](https://zxbasic.readthedocs.io/en/docs/), NBS adds robust hardware support with custom libraries to unleash the full potential of the Next:\r\n\r\n- 🕹️ Edit Sprites with `.spr`, `.til`, `.fnt` support  \r\n- 🎵 Sampled sound, PT3 music, SFX playback  \r\n- 🎨 Full 256-colour support, DMA & Copper effects  \r\n- 💻 Integrated development with hover-help and inline docs  \r\n- ⚡ One-click compile & run with CSpect  \r\n- 🧠 Real-time syntax checks and auto-snippets\r\n\r\nThis document is a small taste, with the more complete help system available by pressing `F1`\r\n\r\n---\r\n\r\n## 🚀 Getting Started\r\n\r\nIn NBS, you'll edit `.bas` files and build with the **Compile** button (bottom bar) or by pressing `F6`.\r\n\r\nTry now:\r\n- Click on [**holymoley.bas**](./NextBuild_Examples/HoleyMoley/holeymoley.bas)  \r\n- Then click **Compile** or press `F6 → Build Source`  \r\n- The app will build and auto-launch in CSpect!\r\n\r\nYou’ll see the **Explorer** open the folder on the left. Use the inline docs and hover-help to explore each keyword — press **F1** for more info!\r\n\r\n---\r\n\r\n## 🛠️ Built-in Tools\r\n\r\n- 🧱 **Sprite Editor** (`.spr`, `.til`, `.fnt`, `.nxm`)\r\n- 🗺️ **Map Editor** (`.nxm`)\r\n- 🖼️ **Image Importer** (sprites, panels, convert images)\r\n- 🧩 **Block Editor** (composite sprite editing)\r\n- 🔍 **Image Viewer** (`.nxi`, `.sl2`)\r\n- 📘 **Inline Help** and ZX Basic Docs (F1)\r\n- ✅ **Syntax Checker**, **Snippets**, and **Templates**\r\n- 🔊 **PT3 Player** (Windows only) - Right click a ```.pt3``` file in the explorer to play, ```esq``` to quit\r\n- 🎹 **AYFX editor** ``Ctrl+Shift+P``, type ``\"AYFX\"``\r\n- 🚦More commands available in the **Command Palette** ```ctrl+shift+p``` and type ```NextBuild```\r\n\r\n---\r\n\r\n## 🧪 How It Works\r\n\r\n- Every keyword supports **hover help**  \r\n- Inline help shows when you press `F1` on a word  \r\n- `F1` on nothing opens the full help system  \r\n- Snippets expand when triggered by hover-help  \r\n\r\n---\r\n\r\n## 📂 Quick Access\r\n\r\n### 💻 Example Projects\r\n- [📝 Hello World](./NextBuild_Examples/HelloWorld/HelloWorld.bas)\r\n- [🕹️ Sprite Demo](./NextBuild_Examples/Sprites/SpriteDemo.bas)\r\n- [🕹️ Comprehensive Sprites](./NextBuild_Examples/Sprites/ScaleRotataSprite.bas)\r\n- [🎯 Template](./NextBuild_Examples/Template.bas)\r\n- [📖 Start Here](./Docs/Introduction.md)\r\n\r\n### ⚙️ Tasks & Commands\r\n- [▶ Run Emulator](command:workbench.action.tasks.runTask?%5B%22Start%20Cspect%22%5D)\r\n- [🛠️ Build File](command:workbench.action.tasks.build)\r\n- [⚙ Open Settings](command:workbench.action.openSettings)\r\n\r\n### 📚 Help & Documentation\r\n- [🔤 Keyword Help](command:nextbuild-viewers.showKeywordHelp)\r\n- [🧠 Z80 Tips](./docs/Z80Tips.md)\r\n- [📦 Compiler Settings](./docs/CompilerSettings.md)\r\n\r\n---\r\n\r\n<div class=\"note\">\r\n💡 <strong>Tip:</strong> You can click on any <code>.bas</code> file above to load it directly into the editor!\r\n</div>\r\n\r\n---\r\n\r\n## 🙏 Credits\r\n\r\nNextBuild Studio has been developed over many years by **David Saphier**, and wouldn't be possible without support and contributions from:\r\n\r\n- **boriel https://ko-fi.com/boriel**  \r\n- **D Xalior Rimron-Soutter https://zx.xalior.com/**  \r\n- **Mike “Flash” Ware https://www.rustypixels.uk/**  \r\n- **Mike Dailly https://lemmings.info/**  \r\n- **Peter Helcmanovsky https://ped7g.itch.io/**\r\n- **Remy Sharp https://remysharp.com/**  \r\n- **Jari Komppa https://solhsa.com/**\r\n- **DuefectuCorp http://duefectucorp.com/**\r\n- **Leslie Greenhalgh**\r\n- **Richard Faulkner**\r\n\r\n```Sorry to anyone I have missed, there have been so many people that have helped over the years, I thank you all.```\r\n\r\n---\r\n\r\n## 📝 Notices\r\n\r\n- **NextBuild-Studio** and its components are © 2025 **David Saphier**, unless otherwise noted.  \r\n- **Boriel Basic** is © José Rodríguez  \r\n- **CSpect** is © Mike Dailly\r\n\r\n---\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": false
  },
  "AYFX_EDITOR": {
    "content": "# AYFX Audio Effects Editor\n\n- [AYFX Audio Effects Editor](#ayfx-audio-effects-editor)\n  - [Overview](#overview)\n  - [Uasage](#uasage)\n  - [The Editor](#the-editor)\n    - [Control Bar](#control-bar)\n    - [Tone Entry](#tone-entry)\n    - [Note Entry](#note-entry)\n    - [Keyboard Shortcuts](#keyboard-shortcuts)\n    - [Multi-Channel Support (WIP Not complete)](#multi-channel-support-wip-not-complete)\n    - [Audio Editing](#audio-editing)\n    - [Keyboard Shortcuts](#keyboard-shortcuts-1)\n    - [File Operations](#file-operations)\n  - [Using in NextBuild](#using-in-nextbuild)\n  - [File Format](#file-format)\n  - [Credits](#credits)\n  - [Related Functions](#related-functions)\n    - [Links](#links)\n\n\n## Overview\n\nThe AYFX Audio Effects Editor is a port of Remy Sharp's javascript conversion from the original AYFX. It uses the AYFX format developed by Shiru for creating compact, efficient sound effects that can be played using the AY-3-8910 sound chip. \n\n**At the moment, multichannel is not fully functional**\n\n## Uasage \n\nThe editor can be opened by clicking on an ```.afb``` file in the explorer or using the ```Command Palette``` which you can open by pressing ```ctrl+shift+p``` and typing ```AYFX```. You will see options to create a new bank or open an existing bank.\n\n## The Editor\n```\n┌──────────────────────────────────────┐\n│ AYFXEditor  Play Copy Paste..     1  │\n├──────────────────────────────────────┤\n│Pos T N Tone Noise Vol  ─T─── N── V── │\n│ 0  / -  02E   00   0F  ─────  ──  ── │\n│ 1  / -  04A   00   0F  ─────  ──  ── │\n│ 2  / -  05C   00   0F  ─────  ──  ── │\n│ 3  / /  06F   10   0F  ─────  ──  ── │\n│                                   2  │\n├──────────────────────────────────────┤\n│ Musical                              │\n│ Notes                             3  │\n│                                      │\n└──────────────────────────────────────┘\n```\n1. Control bar containing the action buttons \n2. Tone1 entry panel \n3. Virtual keyboard and octave selector\n   \n### Control Bar \n\nRunning from left to right you will see \n- Effect Name \n- Curret effect number being edited of ```Total effects```\n- Single channel mode (others are currently disabled)\n- The following button\n  - Play    Plays the current effect \n  - Copy    Copy the current effect\n  - Paste   Paste the effect from the buffer\n  - Clear   Clear all values in effect\n  - Delete  Deletes the current effect\n  - Insert  Inserts a blank effect at the current effect\n  - Blank   Inserts an empty ```sample``` (empty row) into the current effect\n  - Save    Save the AFB \n  - \nIncluded is the import function with 4 preset SYFX banks. These sound effects get used ```all``` the time, so using them directly wont make your title stand out. ```Importing``` will ***OVERWRITE*** your current sound effects! Be warned. \n\n### Tone Entry \n\nThe tone entry is broken in 3 distinct elements.\n- `Pos` - The tone position, the last eneabled position will dictate the effect size `0 - 255`\n- `Tone` `Tone Bar` - All control the same ```tone``` value `$000 - $2FF`\n- `Noise` `Noise Bar` - Control the amount of white noise `$00 - $1F`\n- `Vol` Controls the amount of amplitude `$00 - $1F`\n\nYou can use your mouse to explore the way in which you can interact with the note entry.\n\n### Note Entry \n\n```\nKeybaord entry : \nKeyboard Keys on the top rom\nAssociated note on the bottom row\n┌────┬─┬─────┬─┬────┬────┬─┬─────┬─┬─────┬──┬───┬───┐\n│ Q ││2││ W ││3││ R │ T ││5││ Y ││6││ U ││7││ I │\n│   ││ ││   ││ ││   │   ││ ││   ││ ││   ││ ││   │\n│ C ││#││ D ││#││ E │ F ││#││ G ││#││ A ││#││ B │\n└────┴─┴─────┴─┴────┴────┴─┴─────┴─┴─────┴─┴────┴───┘\n```\n\nYou can click on the `Musical Notes` keyboard or use keys ``QWERTYU235678`` and notes will begin to record. Pressing ``INSERT`` will enter a break or gap. Press `1` will play the effect. Selecting a row with your mouse near the ```Pos``` counter, you can then use the ``cursor keys`` to to move forward and backwards. \n\n### Keyboard Shortcuts \n- **F1**: Open this help documentation\n- **Arrow Keys**: Navigate through frames\n- **Page Up/Down**: Change octave\n- **Home/End**: Jump to start/end\n- **Space/Enter**: Play current effect or all channels\n- **Numpad + / -**: Back and forwards through effects\n- **Ctrl X C V**: Make a selection with mouse & shift, then cut copy or paste\n- **1**: Play individual channels A\n- **Tab**: Switch through elements\n- **Q-8**: Enter musical notes\n- **N**: Enter noise\n- **Delete**: Remove frames (clears selected position)\n- **Insert**: Add space at selection (rest)\n\n### Multi-Channel Support (WIP Not complete)\n- **3 Tone Channels**: Edit effects for channels A, B, and C simultaneously\n- **Channel Modes**: Single, Dual, or Triple channel editing\n- **Real-time Preview**: Play individual channels or mixed audio\n- **Synchronized Editing**: Optional cursor synchronization across channels\n\n### Audio Editing\n- **Tone Control**: Set frequency values for musical notes\n- **Noise Control**: Add noise effects (shared across channels)\n- **Volume Envelope**: Create dynamic volume changes\n- **Note Entry**: Use keyboard or mouse to enter notes\n- **Effect Chaining**: Create consecutive effects for complex compositions\n- **Realtime**: Hear the tones as you enter\n- **Play on the Keyboard**: Enter notes with Q,2,W,3,E,R,5,T,6,Y,7,U,8\n\n### Keyboard Shortcuts\n\n### File Operations\n\n\n## Using in NextBuild\n\nTo use AYFX effects in your NextBuild programs:\n\n```nextbuild\n#DEFINE IM2\n#INCLUDE <nextlib.bas>\n\n' Load the AYFX bank\nLoadSDBank(\"effects.afb\", 40)\nInitSFX(40)\n\n' Enable sound effects\nEnableSFX\n\n' Play effect number 5\nPlaySFX(5)\n```\n\n## File Format\n\nAYFX files (.afb) contain banks of up to 256 sound effects. Each effect can contain:\n- Tone enable/disable flags\n- Noise enable/disable flags  \n- Frequency values (0-4095)\n- Noise values (0-31)\n- Volume levels (0-15)\n\n## Credits\n\n- AYFX routines & PC editor [Shiru](https://shiru.untergrund.net/software.shtml)\n- This editor was ported from [Remy Sharp's port to js](https://zx.remysharp.com/audio/) \n\n## Related Functions\n\n- [InitSFX](InitSFX.md) - Initialize sound effects\n- [PlaySFX](PlaySFX.md) - Play a sound effect\n- [EnableSFX](EnableSFX.md) - Enable sound effects\n- [DisableSFX](DisableSFX.md) - Disable sound effects\n\n### Links \n\n[Editor Index](EDITORS_INDEX.md)\n[Index](index.md)",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "EDITORS_INDEX": {
    "content": "# NextBuild Editors Index\r\n\r\n### NextBuild Studio contains a number of editors for different file types. You can find the documentation for each editor below.\r\n\r\n- [Sprite Editor](SPRITE_EDITOR.md) - Sprite Editor\r\n- [AYFX Editor](AYFX_EDITOR.md) - AYFX Editor\r\n- [Palette Editor](PALETTE_EDITOR.md) - Palette Editor\r\n- [Sprite Importer](SPRITE_IMPORTER.md) - Sprite Importer\r\n- [Map Editor](MAP_EDITOR.md) - Map Editor\r\n- [Block Editor](BLOCK_EDITOR.md) - Block Editor\r\n\r\n### Links \r\n\r\n[Index](index.md)",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "PALETTE_EDITOR": {
    "content": "# Palette Editor\n\n- [Palette Editor](#palette-editor)\n  - [Overview](#overview)\n  - [Formats supported](#formats-supported)\n  - [Usage](#usage)\n  - [The Editor](#the-editor)\n    - [Control Bar](#control-bar)\n    - [Palette Merge Tool](#palette-merge-tool)\n    - [Using in NextBuild](#using-in-nextbuild)\n    - [Example 1 - Load a palette](#example-1---load-a-palette)\n  - [File Format](#file-format)\n  - [Further Reading](#further-reading)\n  - [Related Functions](#related-functions)\n    - [Links](#links)\n\n\n## Overview\n\nThe Palette Editor is a tool for editing ZX Spectrum Next palette files. For more information on palettes see [`Palettes`](PALETTES.md).\n\n## Formats supported\n\nThe import format will be detected automatically.\n\n- Import\n  - `.pal` : ZX Spectrum Next palette file\n  - `.pal` : Jasc Palette file / Gimp Palette file\n  - `.rgb` : RGB Palette file\n\n- Export\n  - `.pal` : ZX Spectrum Next palette file\n\n## Usage \n\n - `Left Click` : Select a colour \n - `Shift + Left Click` : Select start of range\n - `Right Click` : Select a secondary colour / end of range\n - `T` : Toggle index values \n - `ctrl+c` : Copy selected colour / range\n - `ctrl+v` : Paste copied colour / range\n \n## The Editor\n```\n┌──────────────────────────────────────┐\n│  1 Control Bar                       │\n├──────────────────────────────────────┤\n│   ┌────────────────┐   ┌──────────┐  │\n│   │                │   │ 3        │  │\n│   │ 2 Palette      │   └──────────┘  │\n│   │                │                 │\n│   │                │   ┌──────────┐  │\n│   │                │   │ 4        │  │\n│   │                │   │          │  │\n│   └────────────────┘   └──────────┘  │\n│            ┌───────────┐             │\n│            │ 5         │             │\n│            └───────────┘             │\n├──────────────────────────────────────┤\n│ 6  Actions                           │\n└──────────────────────────────────────┘\n\n```\n1. Control bar containing the action buttons \n2. The currently loaded palette / default palette \n3. RGB controls for the selected colour\n4. Colour information for the selected colour \n5. Additional colour converted values \n6. Actions for the palette \n   \n### Control Bar \n\nRunning from left to right you will see \n   - `Undo / Redo` : Undo / Redo the last action\n   - `Default Palette` : Load the default palette\n   - `Import...` : Imports palette from a file (multi formats)\n   - `Import from image` : Imports palette from an image\n   - `Sort Palette` : Sort the palette by colour by `hue`, `saturation`, `brightness`\n   - `Generate Gradient` : Generate a gradient palette\n   - `Generate Harmonies` : Generate a harmony palette\n   - `Reduce Palette` : Reduce the palette to 16 colours\n\nNote the `Save Changes` button is only available if you have made changes to the palette and located in number `4`\n\n### Palette Merge Tool \n\nThis tool allows you to merge spectrum Next palettes together. You can select the target palette index to `merge` into along with the number of colours to `merge` from the source palette.\n\n### Using in NextBuild\n\nOnce you have made changes and save the `.pal` file you can use within your programs.\n### Example 1 - Load a palette \n```nextbuild\n\n' Load the palette into bank 40\nLoadSDBank(\"palette.pal\", 40)\n\n' Upload the palette, all 256 colours will be uploaded\nInitPalette(40, L2_PALETTE_1)\n```\n\n```\n\n\n\n## File Format\n\nAYFX files (.afb) contain banks of up to 256 sound effects. Each effect can contain:\n- Tone enable/disable flags\n- Noise enable/disable flags  \n- Frequency values (0-4095)\n- Noise values (0-31)\n- Volume levels (0-15)\n\n## Further Reading\n\n\n\n## Related Functions\n\n- [InitPalette](InitPalette.md) - Initialize & palette\n- [PalUpload](SetPalette.md) - Upload palette\n- [Palette](Palette.md) - Palette index\n\n\n### Links \n\n[Editor Index](EDITORS_INDEX.md)\n[Index](index.md)",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "SPRITES_BASIC": {
    "content": "# NextBuild Manual\r\n\r\n## Sprites\r\n- [Introduction](#Sprites-Introduction)\r\n- [Loading Sprites](#loading-sprites)\r\n- [Display Sprites](#display-sprites)\r\n- [Example](#example-1)\r\n- [In Depth](#in-depth)\r\n- [NextBuild Sprite Editor](sprite_editor)\r\n---\r\n\r\n# Sprites Introduction\r\n\r\nThe ZX Spectrum Next supports up to 128 hardware sprites on screen at anyone time with 64 different images `patterns` in 8-bit mode or 128 `patterns` in 4-bit mode. \r\n\r\nSprites can be place anywhere on screen including over the border. They can be extruded X/Y by x2 x4 or x8. Sprites can be mirrored, rotated or flipped. Sprites are a very power resource and using them inside NextBuild could not be simpler.\r\n\r\n## Key Features\r\n- 16x16 pixels in size \r\n- 128 sprites on screen (max 12 per scanline)\r\n- 64 or 128 different `patterns`\r\n- 256 colour 8-bit mode or 16 colour 4-bit mode \r\n- \r\n- Appear on top, middle or bottom of the layer system \r\n\r\n\r\n\r\n## Loading Sprites \r\n\r\nA NextBuild program consists of statements and commands, much like traditional BASIC, but with enhancements for modern development.\r\n\r\n### Example: Hello World\r\n```nextbuild\r\n#INCLUDE <nextlib.bas>              ' Include the library\r\nPRINT \"Hello, NextBuild!\"           ' Say HELLO!\r\nWaitKey() : END                     ' Wait for keypress then reset\r\n```\r\n\r\n### Example: Drawing a Sprite\r\n```nextbuild\r\n#INCLUDE <nextlib.bas>\r\nShowSprites(0)                      ' Hide all sprites \r\nLoadSDBank(\"mysprites.spr\",34)      ' Load sprites into RAM\r\nInitSprites2(1,34)                  ' Upload to Sprite RAM \r\nUpdateSprite(100, 80, 1, 1, 0, 0)   ' Draw sprite #0 at (100,80) using pattern 1\r\nShowSprites(1)                      ' Show all sprites \r\nWaitKey() : END \r\n```\r\n\r\n\r\n### Example: Simple Loop\r\n\r\nAs NextBuild uses ZX Basic Compiler under the hoot it follows familiar ZX Spectrum BASIC syntax\r\n\r\n```nextbuild\r\nFOR I = 1 TO 10\r\n    PRINT \"Count: \", I\r\nNEXT I\r\n```\r\n\r\n## Basic Syntax\r\n- Statements are written one per line\r\n- Comments start with `'` or `REM`\r\n- Variables are automatically typed\r\n- Use `LET` for assignment (optional)\r\n\r\n## Useful Commands\r\n- `NextReg(R,N)`        - Set Next register R with value N\r\n- `PRINT`               - Output text to the screen\r\n- `InitLayer2(MODE)`    - Set up Layer2 \r\n- `UpdateSprite()`      - Draw or move a sprite\r\n- `PALETTE`             - Set color palette\r\n- `PEEK`/`POKE`         - Read/write memory\r\n\r\n## More Information\r\n- Use the F1 key or hover over keywords in the editor for instant help.\r\n- Explore the manual pages for details on graphics, sound, and advanced features.\r\n\r\n## Manual Pages\r\n- [Sprites](sprites.md)\r\n- [Layer2](layer2.md)\r\n- [Registers](registers.md)\r\n- [File IO](fileio.md)\r\n- [Audio](audio.md)\r\n- [Constants](constants.md)\r\n\r\nHappy coding with NextBuild!\r\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "SPRITE_EDITOR": {
    "content": "# NextBuild Sprite Editor\n\n- [NextBuild Sprite Editor](#nextbuild-sprite-editor)\n  - [Overview](#overview)\n  - [Uasage](#uasage)\n  - [The Editor](#the-editor)\n    - [Control Bar](#control-bar)\n    - [Sprite List](#sprite-list)\n    - [Palette](#palette)\n    - [Sprite Detail](#sprite-detail)\n    - [Keyboard Shortcuts](#keyboard-shortcuts)\n  - [Using in NextBuild](#using-in-nextbuild)\n  - [File Format](#file-format)\n    - [Remarks](#remarks)\n  - [Further Reading](#further-reading)\n  - [Other Editors](#other-editors)\n    - [Links](#links)\n\n\n## Overview\n\nCreating sprite for yoru productions can now be done directly in NextBuild Studio. While its not a complete replacement for a more traditional tool like Pro Motion or Photoshop, it will help bridge the gap for the time when you're writing code and need to make adjustments, confirm sprite patterns and so on (most of the editors in NBS did start out as simple viewers).\n\n## Uasage \n\nThe editor can be opened by clicking on an ```.spr``` file in the explorer or using the ```Command Palette``` which you can open by pressing ```ctrl+shift+p``` and typing ```Sprite```. You will see options to create a new bank or open an existing sprite file.\n\n## The Editor\n```\n┌──────────────────────────────────────┐\n│ Control Panel                     1  │\n├──────────────────────────────────────┤\n│                                 4    │\n│   ┌───────────┐     ┌───────────┐    │\n│   │         2 │     │         3 │    │\n│   │           │     │           │    │\n│   │           │     │           │    │\n│   │           │     │           │    │\n│   │           │     │           │    │\n│   └───────────┘     └───────────┘    │\n│                                      │\n│                                      │\n└──────────────────────────────────────┘\n```\n\n1. Control bar containing the action buttons \n2. Sprite Detail \n3. Palette \n4. Sprite List \n   \n### Control Bar \n\n- View mode : Selects the current sprite mode\n  - `8-bit` sprites (256 colors)\n  - `4-bit` sprites (16 colors)\n  - `8x8` font (256 colors)\n  - `8x8` tiles (16 colors)\n- Brush : Selects the size of the \"brush\", a grid of sprites\n  - `1x1`, `1x2`, `1x3`, `2x1`, `2x2` \n  - `3x1`, `3x2`, `3x3`, `2x6`, `2x4`\n- `Palette offset` : Sets the 16 colour palette offset, this is a multiplier from `0 - 15`\n- `Scale` : Scales the size of the sprite list \n- `Show grid` : Show or hide the sprite list grid\n- `Load Palette` : load a palette file\n- `Default palette` : apply the default RGB 8-bit index - I hate this and will probably replace the default with something much nicer....\n- `Save Palette` : save the current palette as a `.pal`\n- `Merge Palette` : merge the current palette with the default palette\n\n### Sprite List \n\nThe sprite list is a grid of sprites, you can select a sprite by clicking on it. The sprite list is updated as you edit the sprite. For managing sprites you can use the following keys:\n- `right click` : Copy a sprite to the clipboard\n- `alt+left click` : Paste a sprite from the clipboard\n- `insert` : insert a new sprite\n- `ctrl+shift+right click` : delete a sprite\n- `left right cursors` : move the selected sprite left and right\n  \nUse the mouse and hold left click to move the sprite around and change the order.\nOnce a sprite is selected it will appear in the sprite detail panel.\n\n### Palette \n\nThe palette shows all 256 colours in the current sprite mode. You can select a colour by clicking on it. The default palette will always be loaded on startup, and you cannot edit the default palette (as it is meant to match the default palette of the hardware). For this reas when you attempt to make a change, you will be asked if you want to create a new palette, save it then display it. \n\n- `left click drag` : move a colours order in the palette (swap)\n- `ctrl+left click & drag` : will swap two colours in the palette and remap the sprite pixels\n- `ctrl+right click & drag` : will copy and drag a colour to a new position in the palette\n\nYou can select any colour and use the RGB sliders that are clampe to 0 - 7. You can open the colour picker by clikcing `Edit Colour` in the control bar. To set the `priority` bit, you can use the `Priority` checkbox.\n\nThrough the panel you will see the colour the cursor is hovering over. \n\n### Sprite Detail \n\nThis is where you can edit the sprite. You can use the mouse to move the sprite around and change the order. You can also use the keyboard to move the sprite around.\n\n- `left click` : draw with the primary colour\n- `right click` : draw with the secondary colour\n- `alt+left or right click` : pick up the primary or secondary colour\n\nAbove the sprite detail you will see a number of tranforms buttons, these will work on the entire brush selected, so if you have a 3x3 brush selected, the entire brush will be transformed as one.\n\n- `Flip Horizontal` : flip the sprite horizontally\n- `Flip Vertical` : flip the sprite vertically\n- `Rotate 90` : rotate the sprite 90 degrees\n- `Rotate 270` : rotate the sprite 270 degrees\n- `Shift Left` : shift the sprite left\n- `Shift Right` : shift the sprite right\n- `Shift Up` : shift the sprite up\n- `Shift Down` : shift the sprite down\n- `Bin` : bin the sprite\n- `Paint Can` : fill the sprite with the primary colour\n\nCurrently `UNDO` is disabled, but will be added in the future. :-)\n\n**Save your work regularly**\n\nThe sprite editor is a work in progress and may not be stable. Please save your work regularly.\n\n### Keyboard Shortcuts \n- **F1**: Open this help documentation\n\n## Using in NextBuild\n\nTo use AYFX effects in your NextBuild programs:\n\n```nextbuild\n#DEFINE IM2\n#INCLUDE <nextlib.bas>\n\n' Load the sprites into bank 40\nLoadSDBank(\"sprites.spr\",0,0,0, 40)\n' upload 64 sprites to Sprite RAM \nInitSprites2(63,40)\n' update the sprites to the screen\nUpdateSprites(32,32, 0, 0, 0, 0)\n' enable the sprite display\nNextReg($15,1)\n' wait for a key press\nWaitKey()\n' disable the sprite display\nNextReg($15,0)\n```\n\n## File Format\n\nAll the following files contain the same type of data, it is merely the way in which it is displayed that determines what type of sprite it is.\n\n- `.spr` : 16x16 pixels\n  - 256 colours\n  - 16 colours (4-bit) with palette offset\n- `.nxt` `.til` : 8x8 tiles \n  - 16 colours (4-bit)\n- `.fnt` `.spr` : 8x8 font \n  - 256 colours\n\nThere is also `1-bit` tile mode that is identical to classic ZX Spectrum fonts. As there are considerable editors and fonts already available for this format, I have not included it in the editor.\n\n### Remarks \n\nThe *Sprite Editor* is a work in progress, the design layout is *not* optimal so expect some changes in the future.\n\n## Further Reading\n\n- AYFX routines & PC editor [Shiru](https://shiru.untergrund.net/software.shtml)\n- This editor was ported from [Remy Sharp's port to js](https://zx.remysharp.com/audio/) \n\n## Other Editors\n\n- [Editor Index](EDITOR_INDEX.md)\n\n### Links \n\n[Index](index.md)",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "SPRITE_IMPORTER": {
    "content": "# Sprite Importer\n\n- [Sprite Importer](#sprite-importer)\n  - [Overview](#overview)\n  - [Uasage](#uasage)\n  - [The Importer](#the-importer)\n    - [Control Bar](#control-bar)\n    - [Image Preview](#image-preview)\n    - [Extracted Palette](#extracted-palette)\n    - [Keyboard Shortcuts](#keyboard-shortcuts)\n  - [Using in NextBuild](#using-in-nextbuild)\n      - [Example 1 - Using an exported sprite sheet that was 64x64](#example-1---using-an-exported-sprite-sheet-that-was-64x64)\n  - [File Format](#file-format)\n  - [Related Functions](#related-functions)\n    - [Links](#links)\n\n\n## Overview\n\nYou can launch the `Sprite Importer` from the `command palette` by pressing `ctrl+shift+p` and typing `Sprite Importer`.\n\n## Uasage \n\nThe `Sprite Importer` is a tool for importing sprite files into the NextBuild project. It supports the following formats:\n- `.spr` - Sprite file\n- `.png` - PNG file\n- `.bmp` - BMP file\n- `.jpg` - JPG file\n- `.gif` - GIF file\n- `.webp` - WebP file\n\nThe `Sprite Importer` can also convert images into the following formats:\n - `nxi` : 256x192 x 256\n - `nxi` : 320x256 x 256\n - `nxi` : 640x256 x 16 **not currently supported**\n\n## The Importer\n```\n┌──────────────────────────────────────────┐\n│ 1 Control Bar                            │\n├───────────────┬──────────────────────────┤\n│ 2             │                          │\n│               │                          │\n│ Image Preview │                          │\n│               │                          │\n├─────────┬─────┘                          │\n│ 3       │                                │\n│ Select  │                                │\n│         │                                │\n├─────────┴───────┐                        │\n│ 4 Sprite List   │                        │\n├─────────────────┤                        │\n│ 5 Palette       │                        │\n├─────────────────┘                        │\n└──────────────────────────────────────────┘\n```\n1. Control bar containing the action buttons \n2. Image Preview or the currently loaded image\n3. Selected sprite \n4. Sprite List \n5. Extracted Palette \n   \n### Control Bar \n\nRunning from left to right you will see \n - `Load New Image` : Load a new image from the file system\n - `Convert to NXI` : Convert the currently loaded image to a NXI file\n - `Otput Options` \n  - `Sprite` : 16x16 \n  - `Tile` : 8x8 \n- Bit Depth\n  - `8` : 8 bit (256 colours)\n  - `4` : 4 bit (16 colours)\n- `Grid W/H` : Grid size of the total number of sprites or tiles \n- `Sprite Size` : Custom sprite size \n  - `Save to actual size ` : This will always pad the sprite to 16x16 or 8x8 boundary. \n- `Show Grid` : Show a cell grid on the import image \n- `Cell W/H` : Size of the cell grid (defaults to 16x16)\n- `Load Target Palette` : Load a `.pal` file to use as the target palette for the conversion.\n- \n\n### Image Preview \n\nThis will display the currently loaded image. You can use the mouse to select a sprite or tile.\n - `Left Click` : Capture sprite and add to the selection preview\n - `Right Drag` : Change capture size, starts from the top left corner of the image\n - `Mouse Wheel` : Zoom in and out of the image\n - `cursor keys` : Move the selection preview\n - `space` : Select the current selection\n - `Numpad cursor keys` : Change the cell size \n - `tab` : grab the sprite and move to the next grid position. This is so you can select multiple sprites and move them to the next grid position. **Note** you must have `Block Capture Mode` enabled to use this feature.\n\nFollowing the `Image Preview` you will see : \n - `Add Selection to List` : Add the current selection to the sprite list\n - `Export Sprite Sheet` : Export the current selection as a sprite shet, this good for saving panels used with [DrawImage](DRAWIMAGE.md)\n - `Export as Block` : \n\nOnce you have sleected a sprite or tile you you will see it appear in the `Selection Preview` if you are happy with the selection you can click the `Add to Sprite List` button to add it to the sprite list.\n\n### Extracted Palette \n\nBelow the `Sprite list` you will see the `Extracted Palette` this is the palette that has been extracted from the image. This is useful for 16 colour images. You can load this palette back in when importing new sprites. \n\n### Keyboard Shortcuts \n\n## Using in NextBuild\n\n#### Example 1 - Using an exported sprite sheet that was 64x64\n \n```nextbuild\n' Load the image into bank 32\nLoadSDBank(\"pirate-win.nxi\",0,0,0,32)  \n\n' draw the image to the screen 0,0 - with frame 0 (frame 0 is the first frame of the image)\nDrawImage(0,0,@image_pirate,0)\n\n' Define the image in the bank\nimage_pirate:\n    asm\n        ; bank  spare  width  height \n        db  32, 64, 64\n        ; offset in bank, if the image contains dimension as the first 2 bytes then you can omit the first 2 bytes\n        dw 2\n    end asm \n```\n\n## File Format\n\n## Related Functions\n\n\n### Links \n\n[Editor Index](EDITORS_INDEX.md)\n[Index](index.md)",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "ZXSPECTRUM": {
    "content": "# ZXSpectrum\n\n* http://www.worldofspectrum.org/documentation.html\n* https://sites.google.com/site/ulaplus\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "ARCHIVE": {
    "content": "# Archive\n\n## Source Code\nYou can checkout the latest source code from the repository.\nSee [https://github.com/boriel-basic/zxbasic](http://github.com/boriel/zxbasic) for instructions on how to clone the\nrepository (git).\n\n\n## Latest Version\nYou can contribute to ZX BASIC by reporting possible bugs or improvement suggestions at the\n[forum](http://www.boriel.com/forum) or in social media.\n\nLatest stable version is <span style=\"color: green;\">**1.18.1**</span>.\nClick on the desired icon below to download the package suitable for your platform:\n\n* [<img src=\"https://zxbasic.readthedocs.io/en/docs/img/win32.png\" alt=\"win32zip\" width=\"32px\"/>\n  https://www.boriel.com/files/zxb/zxbasic-1.18.1-win32.zip](https://www.boriel.com/files/zxb/zxbasic-1.18.1-win32.zip)\n<br />Windows .exe zip package. No install needed, just uncompress it in a directory of your choice.\n<br/>&nbsp;\n* [<img src=\"https://zxbasic.readthedocs.io/en/docs/img/macos.png\" alt=\"macostargz\" width=\"32px\"/>\n  https://www.boriel.com/files/zxb/zxbasic-1.18.1-macos.tar.gz](https://www.boriel.com/files/zxb/zxbasic-1.18.1-macos.tar.gz)\n<br />Mac OS x64 package. No install needed, just uncompress it in a directory of your choice (needs Python installed\nin your system).\n<br/>&nbsp;\n* [<img src=\"https://zxbasic.readthedocs.io/en/docs/img/linux.png\" alt=\"macostargz\" width=\"32px\"/>\n  https://www.boriel.com/files/zxb/zxbasic-1.18.1-linux64.tar.gz](https://www.boriel.com/files/zxb/zxbasic-1.18.1-linux64.tar.gz)\n<br />Linux x64 binary package. No install needed, just uncompress it in a directory of your choice.\n<br/>&nbsp;\n* [<img src=\"https://zxbasic.readthedocs.io/en/docs/img/zip-package.png\" alt=\"zip\" width=\"32px\"/>\n  https://www.boriel.com/files/zxb/zxbasic-1.18.1.zip](https://www.boriel.com/files/zxb/zxbasic-1.18.1.zip)\n<br />Windows, Linux, Mac zip package, with python scripts. Requires python installed in your system.\n<br/>&nbsp;\n* [<img src=\"https://zxbasic.readthedocs.io/en/docs/img/driver-down.png\" alt=\"tar.gz\" width=\"32px\"/>\n  https://www.boriel.com/files/zxb/zxbasic-1.18.1.tar.gz](https://www.boriel.com/files/zxb/zxbasic-1.18.1.tar.gz)\n<br />Windows, Linux, Mac tar.gz package, with python scripts. Requires python installed in your system.\n\n### What's new\nTo check out what's new on every version, have a look at the\n[Changelog](https://github.com/boriel/zxbasic/blob/master/Changelog.md) file.\n\n## Older versions\nThis is the official ZX Basic archive. If you require an older ZX BASIC version, please have a look\nat the [archive](https://www.boriel.com/files/zxb/).\n\n----\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "ALIGN": {
    "content": "# ALIGN\n\n\n## Syntax\n\n```\nASM\nALIGN <n>\nEND ASM\n```\n\n## Description\n\nThis works inside the ASM context, and is an assembler directive.\nMoves assembling position forward so the next line begins assembling aligned with a multiple of the given parameter. Useful for aligning data with address and page boundaries. Be aware that this can in theory waste n-1 bytes of memory, as the assembled code can only be moved forwards. Use with caution.\n\n## Examples\n\n```\nASM\n ALIGN 256\n DEFB 0,0,0,0,0,0\nEND ASM\n\nASM\n ALIGN 16384\n DEFS 256,0\nEND ASM\n```\n\nThe first example will move compilation forward to match the next multiple of 256 bytes. This is useful in machine code routines as it matches a new \"high byte\" position in memory. That is to say that the data can be addressed by address ??00 - the low byte will be zero. This is often a key optimization for data tables and screen addressing routines.\n\nAligning to a 16K (16384) boundary might be useful in 128K programming.\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "Z80N": {
    "content": "# Z80 N - ZX Next Extensions\r\n\r\n## Z80N Op Codes\r\n\r\nThe following is a list of the additional Op Code that the Next's cpu supports. These will be useful for advanced programmers. ZX Basic Compiler supports these new Op Codes which NextBuild triggers using the *--arch zxnext* command line argument. \r\n\r\n```\r\nNext-only (Z80N) Instructions Mnemonic \tStatus \tAddressing Mode 1 \tAddressing Mode 2 \tFlags: C N PV H Z S \tT-States \tSummary\r\nADD HL/DE/BC, A \tE \tRegister \tRegister \t? - - - - - \t8 \trr+=unsigned A\r\nADD HL/DE/BC, nn \tE \tRegister \tImmediate \t- - - - - - \t16 \trr+=nn\r\nBRLC DE,B \tE \t- \t- \t- - - - - - \t8 \tDE:=DE<<(B&15) OR DE>>(16-B&15)\r\nBSLA DE,B \tE \t- \t- \t- - - - - - \t8 \tDE:=DE<<(B&31)\r\nBSRA DE,B \tE \t- \t- \t- - - - - - \t8 \tDE:=signed(DE)>>(B&31)\r\nBSRF DE,B \tE \t- \t- \t- - - - - - \t8 \tDE:=~(unsigned(~DE)>>(B&31))\r\nBSRL DE,B \tE \t- \t- \t- - - - - - \t8 \tDE:=unsigned(DE)>>(B&31)\r\nJP (C) \tE \tRegister \t- \t? ? ? ? ? ? \t13 \tPC:=PC&$C000+IN(C)<<6\r\nLDDRX \tE \t- \t- \t- - - - - - \t21/16 \tdo LDDX while(BC>0)\r\nLDDX \tE \t- \t- \t- - - - - - \t16 \t{if HL*!=A DE*:=HL*;} DE++; HL--; BC--\r\nLDIRX \tE \t- \t- \t- - - - - - \t21/16 \tdo LDIX while(BC>0)\r\nLDIX \tE \t- \t- \t- - - - - - \t16 \t{if HL*!=A DE*:=HL*;} DE++; HL++; BC--\r\nLDPIRX \tE \t- \t- \t- - - - - - \t21/16 \tdo{t:=(HL&$FFF8+E&7)*; {if t!=A DE*:=t;} DE++; BC--}while(BC>0)\r\nLDWS \tE \t- \t- \t- 0 ! S S S \t14 \tDE*:=HL*; INC L; INC D;\r\nMIRROR A \tE \tRegister \t- \t- - - - - - \t8 \tA[76543210]:=A[01234567]\r\nMUL d,e \tE \t- \t- \t- - - - - - \t8 \tDE:=D*E\r\nNEXTREG n, A \tE \tImmediate \tAccumulator \t- - - - - - \t17 \tHwNextReg_n:=A\r\nNEXTREG n,n' \tE \tImmediate \tImmediate \t- - - - - - \t20 \tHwNextReg_n:=n'\r\nOUTINB \tE \t- \t- \t? ? ? ? ? ? \t16 \tout(BC,HL*); HL++\r\nPIXELAD \tE \t- \t- \t- - - - - - \t8 \tHL:=$4000+((D&$C0)<<5)+((D&$07)<<8)+((D&$38)<<2)+(E>>3)\r\nPIXELDN \tE \t- \t- \t- - - - - - \t8 \tif(HL&$0700!=$0700) HL+=256; else if(HL&$e0!=$e0) HL:=HL&$F8FF+$20; else HL:=HL&$F81F+$0800\r\nPUSH nn \tE \tImmediate \t- \t- - - - - - \t23 \tSP-=2; SP*:=nn\r\nSETAE \tE \t- \t- \t- - - - - - \t8 \tA:=unsigned($80)>>(E&7)\r\nSWAPNIB \tE \t- \t- \t- - - - - - \t8 \tA:=A[3210]<<4 OR A[7654]>>4\r\nTEST n \tE \tImmediate \t- \tS ? P S S S \t11 \tA&n? \r\n```\r\n\r\n## Remarks \r\n\r\n# Links \r\n\r\n(Index)[Index.md]",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "BITWISELOGIC": {
    "content": "# Bitwise Operators\n\nZX Basic allows Bit Manipulation (bitwise), on every integer type (from 8 to 32 bits).\n\n| **BITWISE OPERATORS** |\n|:---------------------:|\n|         bAND          |\n|          bOR          |\n|         bNOT          |\n|         bXOR          |\n\nExcept bNOT, all the others require two integral (Byte, Ubyte, Integer, UInteger, Long, ULong) operands.\nThe operation will be applied bit by bit.\n\n---\n## bAND\n\nPerforms the _Bitwise Conjunction_ and returns 1 for every bit if and only if both bits are 1.\n\n| a | b | result |\n|:-:|:-:|:------:|\n| 0 | 0 |   0    |\n| 0 | 1 |   0    |\n| 1 | 0 |   0    |\n| 1 | 1 |   1    |\n\n### Example\n\nBinary \"mask\" that will get only the 4 rightmost bits 0 1 2 3 of a number:\n\n```basic\nPRINT BIN 01110111 bAND BIN 00001111` will print 7, which is 0111\n```\n\n---\n\n## bOR\n\nPerforms the _Bitwise Disjunction_ and returns 1 if any of the arguments is 1.\n\n| a | b | result |\n|:-:|:-:|:------:|\n| 0 | 0 |   0    |\n| 0 | 1 |   1    |\n| 1 | 0 |   1    |\n| 1 | 1 |   1    |\n\n### Example\n\nEnsure an ASCII letter is always in lowercase:\n\n```basic\nPRINT CHR$(CODE \"A\" OR BIN 10000)\n```\nwill print `a` because lowercase letters have bit 5 set.\n\n---\n\n## bNOT\n\nPerforms the _Bitwise Negation_ and returns _1_ if the arguments is _0_ and vice versa.\nBasically it flips all the bits in an integer number.\n\n| a | result |\n|:-:|:------:|\n| 0 |   1    |\n| 1 |   0    |\n\n\n### Example\n\nInvert the first cell (upper-leftmost) in the screen:\n\n```basic\nPRINT AT 0, 0; \"A\";\nFOR i = 0 TO 3\n    POKE 16384 + 256 * i, bNOT PEEK(16384 + 256 * i)\nNEXT\n```\n---\n\n## bXOR\n\nPerforms a logical XOR and returns 1 if one and only one of the arguments is 1, 0 if both bits are the same.\nIn essence, returns 1 ONLY if one of the arguments is 1.\n\n| a | b | result |\n|:-:|:-:|:------:|\n| 0 | 0 |   0    |\n| 0 | 1 |   1    |\n| 1 | 0 |   1    |\n| 1 | 1 |   0    |\n---\n\n### Example\n\nFlips an ASCII letter from lower to uppercase and vice versa\n\n```basic\nPRINT CHR$(CODE \"A\" bXOR BIN 10000)\n```\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "COMMENTS": {
    "content": "# Comments\n\n\n## Introduction\n\nCommenting source code is important as it makes your code more maintainable. You can return back to a code you typed several month ago and recall and understand what it does quickly if your comments are up to date.\n\n## REM lines\n\nTraditional BASIC dialects (e.g. Sinclair BASIC) uses REM to comment lines. REM is an abbreviation of _REMark_. ZX BASIC allows it:\n\n\n```\n10 REM This line has a comment\n20 PRINT \"Hello World\": REM The following sentence is ignored: PRINT \"Hello Again\"\n```\n\n\nREM exists for the sake of retrocompatibility with old Sinclair BASIC listings.\n\n## Apostrophe character\n\nNewer dialects uses the apostrophe character (') as a shortened REM. ZX BASIC also allows it, so the above listing could be also rewritten this way:\n\n\n```\n10 ' This line has a comment\n20 PRINT \"Hello World\": 'The following sentence is ignored: PRINT \"Hello Again\"\n```\n\n\nEverything beyond the apostrophe char will be ignored. Since line numbers can also be omitted,\nthe above listing could be rewritten as:\n\n\n```\n' This line has a comment\nPRINT \"Hello World\" 'The following sentence is ignored: PRINT \"Hello Again\"\n```\n\n\nNotice now the missing colon at the end of the [PRINT](print.md) statement. REM, like any other BASIC sentence,\nrequires a colon when it is preceded by another one, whilst apostrophe does not.\n\nThe apostrophe character was used in Sinclair BASIC as a [PRINT](print.md) modifier. But here, in ZX BASIC,\nit is **always** a commenter char.\n\n## Multi-line comments\n\nMulti-line comments are marked with the tokens `/'` and `'/`. All text between the two markers is considered\ncomment text and is not compiled.\n\nMulti-line comments can span several lines, and can also be used in the middle of statements.\nAfter the end of the comment, the statement will continue to be parsed as normal (even if the comment crosses\nline breaks).\n\n\n```\n/' Multi-line\ncomment '/\n\nPrint \"Hello\" /' embedded comment'/ \" world\"\n```\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "4INAROW.BAS": {
    "content": "# 4 in a Row\n\n Program: 4inarow.bas\n\n This program first appeared in MicroHobby ZX Spectrum Spanish magazine. It has a\n nice AI in BASIC that plays smartly against the human in only 16Kb!\n\n```\n   0 REM From MicroHOBBY magazine, Num. 18, page 27  :')\n   1 BORDER 1: PAPER 1: INK 7: CLS : PRINT AT 10,10; FLASH 1;\"STOP THE TAPE\": PAUSE 200\n   5 DIM M(8,6): DIM p,pp,n as FLOAT\n   6 BORDER 1: PAPER 1: INK 6: CLS\n  10 LET x=0: LET y=0: LET j=0\n  20 PRINT INK 4;\" \\ : \\:    \\:'\\'' \\:'\\'.\\ :   \\:'\\': \\:'\\': \\:.\\.: \\:'\\':       \\''\\:    \\:'  \\:  \\'.   \\: \\.: \\:.\\.:  \\:  \\:.\\.:        \\:    \\:.\\.. \\:  \\ :   \\: \\'. \\: \\ :  \\:  \\: \\ :\"; INK 6;AT 21,5;\" \\*  by \\{vi}$R\\{vn}         R.Bernat.\"\n  25 PRINT AT 15,3;\"Who starts, You or Me? (y/m).\": GOSUB 2800: PRINT AT 15,3;\"                             \": GO SUB 2500\n  30 FOR i=1 TO 8: FOR m=1 TO 6\n  40 LET M(i,m)=0: NEXT m: NEXT i\n 100 PLOT 0,16: DRAW 12,16: DRAW 0,100: DRAW 8,0: DRAW 0,-92\n 110 FOR n=1 TO 8: DRAW 8,0,PI: DRAW 0,92: DRAW 8,0: DRAW 0,-92: NEXT n: DRAW 0,-8: DRAW 12,-16: DRAW -25,0: DRAW 0,9: DRAW -110,0: DRAW 0,-9: DRAW -25,0\n 120 PRINT AT 5,1;\"\\{vi} 1 2 3 4 5 6 7 8 \\{vn}\"\n 450 IF a$=\"m\" THEN GO TO 700: END IF\n 480 LET M(5,1)=1: LET xp=5: LET yp=1: LET color=1: GO SUB 3000\n 490 GO TO 700\n 500 PRINT AT 12,20; INK 4; FLASH 1;\"THINKING \": LET pp=0\n 510 LET p=0\n 520 FOR i=1 TO 8\n 530 LET x=i: GO SUB 2000\n 540 IF y>6 THEN CONTINUE FOR: END IF: REM NEXT i\n 550 LET color=1: GO SUB 1030: PRINT FLASH 1;AT 5,i+20;i\n 560 IF psp>p AND psp<30 THEN GO SUB 1600: END IF\n 570 IF psp>p THEN LET p=psp: LET xp=x: LET yp=y: END IF\n 575 IF psp=.05 THEN CONTINUE FOR: END IF: REM NEXT i\n 580 LET color=2: GO SUB 1030: IF psp>=30 THEN LET psp=29.9: GOTO 590: END IF\n 585 LET pp=psp:GOSUB 1600:IF psp>=30 THEN LET pp=.05:END IF: LET psp=pp\n 590 IF psp>p THEN LET p=psp: LET xp=x: LET yp=y: END IF\n 600 NEXT i: PRINT INK 1; FLASH 0;AT 5,20;\"             \"\n 610 LET color=1: LET M(xp,yp)=1\n 620 GO SUB 2500: GO SUB 3000: LET j=j+1\n 630 IF p>=30 THEN GO TO 3500: END IF\n 640 IF j=48 THEN PRINT AT 12,20;\"-Draw-\": GO TO 3600: END IF\n 700 REM ********************************  YOU PLAY  *******************************************\n 701 PRINT INK 4;AT 12,20;\"YOUR MOVE\"\n 710 GOSUB 2700: LET x=VAL a$\n 720 IF x<1 OR x>8 THEN GO TO 710: END IF\n 725 LET color=2: GO SUB 2000: IF y>6 THEN PRINT AT 12,20;\"Not valid\": GO TO 710: END IF\n 730 LET yp=y: LET xp=x: LET color=2: GO SUB 3000\n 740 LET M(xp,yp)=2: LET j=j+1\n 750 REM check if you win\n 760 GO SUB 1030\n 770 IF psp>=30 THEN GO TO 3550: END IF\n 780 IF j=48 THEN PRINT OVER 1;AT 21,0;\"              ...end\": GO TO 3600: END IF\n 790 GO TO 500\n1030 LET psp=0: LET np=0\n1040 LET dx=1: LET dy=0: GO SUB 1500\n1050 LET psp=ps\n1060 LET dx=-1: LET dy=0: GO SUB 1500\n1070 LET psp=psp+ps\n1080 LET dx=0: LET dy=-1: GO SUB 1500\n1090 IF ps>psp THEN LET psp=ps: END IF\n1100 LET dx=1: LET dy=-1: GO SUB 1500\n1200 LET np=ps\n1210 LET dx=-1: LET dy=1: GO SUB 1500\n1220 LET np=np+ps\n1230 IF np>psp THEN LET psp=np: END IF\n1240 LET dx=1: LET dy=1: GO SUB 1500\n1250 LET np=ps\n1260 LET dx=-1: LET dy=-1: GO SUB 1500\n1270 LET np=np+ps\n1280 IF np>psp THEN LET psp=np: END IF\n1290 RETURN\n1500 LET ps=0: LET xx=x: LET yy=y: LET b=0\n1510 LET xx=xx+dx: LET yy=yy+dy\n1520 IF (xx<1) OR (yy<1) OR (xx>8) OR (yy>6) THEN RETURN: END IF\n1530 IF M(xx,yy)<>color AND M(xx,yy)<>0 THEN RETURN: END IF\n1540 IF M(xx,yy)=color AND b=0 THEN LET ps=ps+10: GO TO 1510: END IF\n1550 LET ps=ps+1: LET b=1: GO TO 1510\n1599 REM ******************************************************\n1600 LET M(x,y)=1: LET color=2: LET y=y+1\n1610 GO SUB 1030\n1620 IF psp>=30 THEN LET psp=0.05: END IF\n1630 LET y=y-1: LET M(x,y)=0: RETURN\n2000 LET cont=0\n2010 LET cont=cont+1\n2020 IF cont>6 THEN LET y=7: RETURN: END IF\n2030 IF M(x,cont)<>0 THEN GO TO 2010: END IF\n2040 LET y=cont: RETURN\n2500 FOR n=1 TO 6: BEEP n*n/100,n: BEEP n/50,n: NEXT n: RETURN\n2700 REM Waits for a Key press since we lack the INPUT sentence\n2710 LET a$=INKEY$: IF a$=\"\" THEN GO TO 2710: END IF\n2720 RETURN\n2800 GOSUB 2700: IF a$ <> \"y\" AND a$ <> \"m\" THEN GOTO 2800: END IF\n2810 RETURN\n3000 IF color=1 THEN INK 7: END IF\n3005 IF color=2 THEN INK 2: END IF\n3010 LET xx=((xp*2)+1)*8: LET yy=((yp*2)+3)*8\n3020 FOR n=1 TO 7: CIRCLE xx,yy,n: NEXT n: INK 7\n3030 RETURN\n3500 PRINT INK 2;\"  \\{vi}\\  \\::\\::\\  \\::\\  \\  \\  \\  \\::\\::\\::\\  \\  \\  \\::   \\:: \\.'\\::\\  \\::\\  \\  \\  \\::\\::\\::\\::\\::  \\::\\:: \\::\\:: \\::\\::\\:: \\::\\::\\:: \\:: \\:: \\::\\.' \\:: \\:: \\::\\::\\::\\::\\::\\  \\::\\::\\:: \\::\\:: \\::\\::\\:: \\:: \\::   \\:: \\::\\:: \\::\\  \\::\\  \\::\\::\\::\\::\\:: \\::\\::\\::    \\::\\::\\::   \\:: \\:: \\:: \\::\\:: \\::\\  \\  \\  \\{vn}\": GO TO 3600\n3550 PRINT INK 2;\"\\::\\::\\:: \\::\\  \\::   \\::\\::\\:: \\::\\::\\:: \\::\\'.\\  \\:: \\::\\::\\:: \\::\\::\\::\\  \\  \\  \\::\\  \\  \\::\\  \\::\\  \\  \\  \\::\\  \\  \\  \\::\\  \\::\\  \\::\\  \\'.\\::\\  \\::\\  \\::\\  \\'.\\..\\  \\  \\  \\  \\::\\  \\  \\:: \\::   \\:: \\:: \\::\\::\\::\\  \\::\\  \\  \\::\\  \\::\\::\\::\\  \\  \\  \\'.   \\::  \\::\\::\\::\\  \\  \\  \\::\\::\\::\\  \\::\\  \\::\\  \\::\\  \\  \\::\\  \\::\\  \\::\\  \\::\\::\\::\"\n3600 PRINT \"Play Again? (y/n)\": GOSUB 2700: IF a$=\"y\" THEN GO TO 6: END IF: IF a$<>\"n\" THEN GOTO 3600: END IF\n```\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "CIRCLE.BAS": {
    "content": "# Circle.Bas\n\n```\nProgram: circle.bas\n```\n\n```\nREM Sample circle drawing without using the CIRCLE command\n\nDIM i, r, x, y, q as FLOAT\nDIM ax, ay, zx, zy, dx, dy as Integer\n\nx = 127\ny = 87\nr = 40\nq = 1 / r\n\nFOR i = 0 TO PI / 2 STEP q\n    dy = SIN(i) * r\n    dx = COS(i) * r\n\n    zx = x - dx\n    zy = y - dy\n    ax = x + dx\n    ay = y + dy\n\n    PLOT ax, ay\n    PLOT zx, ay\n    PLOT ax, zy\n    PLOT zx, zy\nNEXT i\n```\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "CLOCK.BAS": {
    "content": "# Clock.Bas\n\n```\n Program: clock.bas\n```\n```\nREM From the ZX Spectrum MANUAL\nREM A Clock program\n\nREM First we draw the Sphere\nCLS\nFOR n = 1 to 12\n    PRINT AT 10 - (10 * COS(n * PI / 6) - 0.5), 16 + (0.5 + 10 * SIN(n * PI / 6)); n\nNEXT n\nPRINT AT 23, 0; \"PRESS ANY KEY TO EXIT\";\n\nFUNCTION t AS ULONG\n    REM Reads the FRAMES counter\n    RETURN INT((65536 * PEEK(23674) + 256 * PEEK(23673) + PEEK(23672))/50)\nEND FUNCTION\n\nDIM t1 as FLOAT\n\nOVER 1\nWHILE INKEY$ = \"\"\n    LET t1 = t()\n    LET a = t1 / 30 * PI: REM a is the seconds pointer in radians\n    LET sx = 72 * SIN a : LET sy = 72 * COS a\n    PLOT 131, 107: DRAW sx, sy\n\n    LET t2 = t()\n    WHILE (t2 <= t1) AND (INKEY$ = \"\")\n        REM WARNING: Empty loops might be optimized and removed\n        let t2 = t()\n    END WHILE : REM Wait until the moment to move it\n\n    PLOT 131, 107: DRAW sx, sy\n\nEND WHILE\n```\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "CLOCK2.BAS": {
    "content": "# Clock2.Bas\n\n```\n Program: clock2.bas\n```\n```\nREM From the ZX Spectrum MANUAL\nREM A Clock program\n\nREM First we draw the Sphere\nCLS\nCIRCLE 132, 105, 86\nFOR n = 1 to 12\n    PRINT AT 10 - (10 * COS(n * PI / 6) - 0.5), 16 + (0.5 + 10 * SIN(n * PI / 6)); n\nNEXT n\nCIRCLE 132, 105, 70\n\nPRINT AT 23, 0; \"PRESS ANY KEY TO EXIT\";\n\nFUNCTION t AS ULONG\n    RETURN INT((65536 * PEEK (23674) + 256 * PEEK(23673) + PEEK (23672))/50)\nEND FUNCTION\n\nDIM t1 as FLOAT\n\nOVER 1\nWHILE INKEY$ = \"\"\n    LET t1 = t()\n    LET a = t1 / 30 * PI: REM a is the seconds pointer in radians\n    LET sx = 72 * SIN a : LET sy = 72 * COS a\n    PLOT 131, 107: DRAW sx, sy\n\n    LET t2 = t()\n    WHILE (t2 <= t1) AND (INKEY$ = \"\")\n        REM WARNING: Empty loops might be optimized and removed\n        let t2 = t()\n    END WHILE : REM Wait until the moment to move it\n\n    PLOT 131, 107: DRAW sx, sy\nEND WHILE\n```\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "COLORS.BAS": {
    "content": "# Colors.bas\n\n```\n Program: colors.bas\n```\n```\nREM From the ZX Spectrum 48K Manual\n\nDIM m, n, c AS BYTE\n\nFOR m = 0 TO 1: BRIGHT m\nFOR n = 1 TO 10\nFOR c = 0 TO 7\nPAPER c: PRINT \"    \";: REM 4 coloured spaces\nNEXT c: NEXT n: NEXT m\n\nFOR m = 0 TO 1: BRIGHT m: PAPER 7\nFOR c = 0 TO 3\nINK c: PRINT c; \"   \";\nNEXT c: PAPER 0\nFOR c = 4 TO 7\nINK c: PRINT c; \"   \";\nNEXT c: NEXT m\nPAPER 7: INK 0: BRIGHT 0\n```\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "FACT.BAS": {
    "content": "# Fact.bas\n\n```\n Program: fact.bas\n```\n```\nREM Factorial recursive test\n\nfunction fact(x as ulong) as ulong\n    if x < 2 then\n        return 1\n    end if\n\n    return x * fact(x - 1)\n\nend function\n\ncls\nfor x = 1 To 10:\n    print \"Fact (\"; x; \") = \"; fact(x)\nnext x\n```\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "FLAG.BAS": {
    "content": "# Flag.bas\n\n```\n Program: flag.bas\n```\n\n```\n  5 REM union flag (from the ZX Spectrum Manual)\n\n  7 DIM n AS UInteger: REM Needed to avoid overflow at line 530\n 10 LET r=2: LET w=7: LET b=1\n 20 BORDER 0: PAPER b: INK w: CLS\n\n 30 REM black in bottom of screen\n 40 INVERSE 1\n 50 FOR n=40 TO 0 STEP -8\n 60 PLOT PAPER 0;7,n: DRAW PAPER 0;241,0\n 70 NEXT n: INVERSE 0\n\n100 REM draw in white parts\n105 REM St. George\n110 FOR n=0 TO 7\n120 PLOT 104+n,175: DRAW 0,-35\n130 PLOT 151-n,175: DRAW 0,-35\n140 PLOT 151-n,48: DRAW 0,35\n150 PLOT 104+n,48: DRAW 0,35\n160 NEXT n\n200 FOR n=0 TO 11\n210 PLOT 0,139-n: DRAW 111,0\n220 PLOT 255,139-n: DRAW -111,0\n230 PLOT 255,84+n: DRAW -111,0\n240 PLOT 0,84+n: DRAW 111,0\n250 NEXT n\n\n300 REM St. Andrew\n310 FOR n=0 TO 35\n320 PLOT 1+2*n,175-n: DRAW 32,0\n330 PLOT 224-2*n,175-n: DRAW 16,0\n340 PLOT 254-2*n,48+n: DRAW-32,0\n350 PLOT 17+2*n,48+n: DRAW 16,0\n360 NEXT n\n370 FOR n=0 TO 19\n380 PLOT 185+2*n,140+n: DRAW 32,0\n390 PLOT 200+2*n,83-n: DRAW 16,0\n400 PLOT 39-2*n,83-n: DRAW 32,0\n410 PLOT 54-2*n,140+n: DRAW -16,0\n420 NEXT n\n\n425 REM fill in extra bits\n430 FOR n=0 TO 15\n440 PLOT 255,160+n: DRAW 2*n-30,0\n450 PLOT 0,63-n: DRAW 31-2*n,0\n460 NEXT n\n470 FOR n=0 TO 7\n480 PLOT 0,160+n: DRAW 14-2*n,0\n485 PLOT 255,63-n: DRAW 2*n-15,0\n490 NEXT n\n\n500 REM red stripes\n510 INVERSE 1\n\n520 REM St George\n530 FOR n=96 TO 120 STEP 8\n540 PLOT PAPER r;7,n: DRAW PAPER r;241,0\n550 NEXT n\n560 FOR n=112 TO 136 STEP 8\n570 PLOT PAPER r;n,168: DRAW PAPER r;0,-113\n580 NEXT n\n\n600 REM St Patrick\n610 PLOT PAPER r;170,140: DRAW PAPER r;70,35\n620 PLOT PAPER r;179,140: DRAW PAPER r;70,35\n630 PLOT PAPER r;199,83: DRAW PAPER r;56,-28\n640 PLOT PAPER r;184,83: DRAW PAPER r;70,-35\n650 PLOT PAPER r;86,83: DRAW PAPER r;-70,-35\n660 PLOT PAPER r;72,83: DRAW PAPER r;-70,-35\n670 PLOT PAPER r;56,140: DRAW PAPER r;-56,28\n680 PLOT PAPER r;71,140: DRAW PAPER r;-70,35\n690 INVERSE 0: PAPER 0: INK 7\n```\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "FRACTAL.BAS": {
    "content": "# Fractal.bas\n\n```\nProgram: fractal.bas by @Britlion\n```\n\n\n```\n# define width 256\n# define height 192\n\nDIM x,y as FIXED\nDIM xstart,xstep,ystart,ystep as FIXED\nDIM xend,yend as FIXED\nDIM z,zi,newz,newzi as FIXED\nDIM colour as byte\nDIM iter as uInteger\nDIM col as uInteger\nDIM i,k as uByte\nDIM j as uInteger\ndim inset as uByte\n\nxstart=-1.6\nxend=0.65\nystart=-1.15\nyend=-ystart\niter=24\n\nxstep=(xend-xstart)/width\nystep=(yend-ystart)/height\n\n'Main loop\nx=xstart\ny=ystart\n\nborder 0\npaper 0\nink 7\nCLS\n\nfor i=0 to ( height -1 )/2 +1\n\n        for j=0 to width -1\n            z=0\n            zi=0\n            inset=1\n                for k=0 to iter\n                    ';z^2=(a+bi)*(a+bi) = a^2+2abi-b^2\n                    newz=(z*z)-(zi*zi)+x\n                    newzi=2*z*zi+y\n                    z=newz\n                    zi=newzi\n\n                    if (z*z)+(zi*zi) > 4 then\n                        inset=0\n                        colour=k\n                        goto screen\n                    END IF\n                next k\n\nscreen:\n\n                if NOT inset then\n                    if colour BAND 1 THEN\n                        plot j,i\n                        plot j,192-i\n                    END IF\n                end if\n\n                x=x+xstep\n         next j\n\n        y=y+ystep\n        x=xstart\n\nprint at 23,0;CAST(uinteger,i)*200/height;\"%\"\nnext i\n\nBEEP 1,1\nPAUSE 0\n```\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "FREREGUSTAV.BAS": {
    "content": "# FrereGustav.bas\n\n```\n Program: freregustav.bas\n```\n```\nREM Frere Gustav, from the ZX Spectrum 48K Manual, Chapter 19\n\nPRINT \"Frere Gustav\"\n\nBEEP 1, 0: BEEP 1, 2: BEEP .5, 3: BEEP .5, 2: BEEP 1, 0\nBEEP 1, 0: BEEP 1, 2: BEEP .5, 3: BEEP .5, 2: BEEP 1, 0\n\nBEEP 1, 3: BEEP 1, 5: BEEP 2, 7\nBEEP 1, 3: BEEP 1, 5: BEEP 2, 7\n\nBEEP .75, 7: BEEP .25, 8: BEEP .5, 7: BEEP .5, 5: BEEP .5, 3: BEEP .5, 2: BEEP 1, 0\nBEEP .75, 7: BEEP .25, 8: BEEP .5, 7: BEEP .5, 5: BEEP .5, 3: BEEP .5, 2: BEEP 1, 0\n\nBEEP 1, 0: BEEP 1, -5: BEEP 2, 0\nBEEP 1, 0: BEEP 1, -5: BEEP 2, 0\n```\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "LINES.BAS": {
    "content": "# Lines.bas\n\n```\n Program: lines.bas\n```\n\n```\n 5 REM From the ZX Spectrum manual on Drawing primitives\n 6 DIM x1, y1, x2, y2, c as Integer\n\n10 BORDER 0: PAPER 0: INK 7: CLS: REM turn screen blank\n20 LET x1 = 0: LET y1 = 0: REM line start\n30 LET c = 1: REM Ink color starting from blue\n40 LET x2 = INT(RND * 256): LET y2 = INT(RND * 176): REM Random line end\n50 DRAW INK c; x2 - x1, y2 - y1\n60 LET x1 = x2: LET y1 = y2: REM Next line starts at current one's ending\n70 LET c = c + 1: IF c = 8 THEN LET c = 1: END IF: REM Next color\n80 IF INKEY$ = \"\" THEN GOTO 40: END IF\n```\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "SNAKE.BAS": {
    "content": "# Snake.Bas\n\n```\n Program: snake.bas\n```\n\n```\n   1 REM ********************************************************************\n   2 REM ZXSnake by Federico J. Alvarez Valero (2003-02-05)\n  10 REM This program is free software; you can redistribute it and/or modify\n  11 REM it under the terms of the GNU General Public License as published by\n  12 REM the Free Software Foundation; either version 2 of the License, or\n  13 REM (at your option) any later version.\n  14 REM This program is distributed in the hope that it will be useful,\n  15 REM but WITHOUT ANY WARRANTY; without even the implied warranty of\n  16 REM MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  17 REM GNU General Public License for more details.\n  18 REM You should have received a copy of the GNU General Public License\n  19 REM along with this program; if not, write to the Free Software\n  20 REM Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n  30 REM                   ENGLISH VERSION\n  40 REM ********************************************************************\n\n  50 BORDER 7 : PAPER 7 : INK 0 : CLS\n  51 PRINT AT 3,13 ; PAPER 1 ; INK 7 ; \"ZXSnake\"\n  52 PRINT AT 5,9 ; PAPER 7 ; INK 0 ; \"Q - Up\"\n  53 PRINT AT 6,9 ; PAPER 7 ; INK 0 ; \"A - Down\"\n  54 PRINT AT 7,9 ; PAPER 7 ; INK 0 ; \"O - Left\"\n  55 PRINT AT 8,9 ; PAPER 7 ; INK 0 ; \"P - Right\"\n  56 PRINT AT 10,3 ; PAPER 7 ; INK 0 ; \"You have to pick up every\"\n  57 PRINT AT 11,3 ; PAPER 7 ; INK 0 ; \"fruit on the screen while\"\n  58 PRINT AT 12,3 ; PAPER 7 ; INK 0 ; \"growing up more and more...\"\n  59 PRINT AT 15,3 ; PAPER 7 ; INK 0 ; \"Press any key to start\"\n  60 LET j$ = INKEY$\n  61 IF j$ = \"\" THEN GOTO 60: END IF\n\n  70 REM UDG\n  71 DIM udg(1, 7) AS uByte => { {60, 66, 129, 129, 129, 129, 66, 60}, _\n                                 {24, 60, 60, 60, 126, 251, 247, 126}}\n  73 POKE UINTEGER 23675, @udg(0, 0): REM Sets UDG variable to point to the first element\n  74 LET S$ = CHR$(144): LET F$ = CHR$(145)\n\n  75 REM Variable declaration\n  76 DIM p(23,34) AS UBYTE: REM Screen\n  77 DIM x(23,34) AS UBYTE: REM Xorientations\n  78 DIM y(23,34) AS UBYTE: REM Yorientations\n  79 DIM c, f AS UBYTE\n  80 DIM headx, heady AS UBYTE : REM Head coordinates\n  81 DIM tailx, taily AS UBYTE : REM Tail coordinates\n  90 DIM score, eaten as ULONG\n  95 DIM maxx, maxy, minx, miny as UByte\n\n 100 REM Variable definition\n 110 LET headx = 11 : REM head x coordinate\n 120 LET heady = 5 :  REM head y coordinate\n 130 LET tailx = 5 :  REM tail x coordinate\n 140 LET taily = 5 :  REM tail y coordinate\n 150 LET orientationx = 1\n 160 LET orientationy = 0\n\n 165 REM Clear arrays p, x and y\n 170 FOR c = 1 to 23: FOR f = 1 to 34\n 180 LET p(c, f) = 0: LET x(c, f) = 0: LET y(c, f) = 0\n 190 NEXT f: NEXT c\n\n 200 LET score = 0\n 210 LET eaten = 0\n 220 LET maxx = 33\n 230 LET maxy = 22\n 240 LET minx = 0\n 250 LET miny = 0\n\n1000 REM Screen Initialization\n1010 BORDER 1\n1015 CLS\n1020 PRINT AT 21,0 ; PAPER 1 ; INK 7 ; \" SCORE :                       \"\n1030 FOR c = minx TO maxx\n1040 LET p(miny+1,c+1) = 4\n1050 LET p(maxy+1,c+1) = 4\n1060 NEXT c\n1070 FOR f = miny TO maxy\n1080 LET p(f+1,minx+1) = 4\n1090 LET p(f+1,maxx+1) = 4\n1100 NEXT f\n\n1500 GOSUB 8000 : REM Place first fruit\n\n2000 REM Draw snake in its initial position\n2001 PAPER 7 : INK 0\n2005 REM Draw the body\n2010 FOR c = tailx TO headx-1\n2020 PRINT AT taily,c ; INK 0 ; \"O\"\n2025 LET p(taily+2,c+2) = 3\n2026 LET x(taily+2,c+2) = 1\n2027 LET y(taily+2,c+2) = 0\n2030 NEXT c\n2040 REM Draw the Head\n2050 PRINT AT heady,headx ; INK 0 ; S$;\n2055 LET p(heady+2,headx+2) = 2\n2056 LET x(heady+2,headx+2) = 1\n2057 LET y(heady+2,headx+2) = 0\n\n3000 REM Update snake position\n3005 INK 0\n3010 REM Change the orientation if needed\n3015 LET x(heady+2,headx+2) = orientationx\n3020 LET y(heady+2,headx+2) = orientationy\n3025 REM Erase previous head\n3030 PRINT AT heady,headx ; \"O\"\n3035 LET p(heady+2,headx+2) = 3\n3040 LET headx = headx + orientationx\n3045 LET heady = heady + orientationy\n3050 IF p(heady+2,headx+2) > 1 THEN GOTO 9900: END IF\n3051 IF p(heady+2,headx+2) = 1 THEN\n     LET score = score + 10 : PRINT AT 21,10 ; _\n     PAPER 1 ; INK 7 ; score : LET eaten = 1 : GOSUB 8000: END IF\n3055 REM Print the new head\n3060 PRINT AT heady,headx ; S$;\n3065 LET p(heady+2,headx+2) = 2\n3070 IF eaten = 0 THEN GOSUB 8100: END IF\n3080 LET eaten = 0\n\n3200 REM Read the keyboard\n3210 LET a$ = INKEY$\n3220 IF orientationx < 1 AND (a$ = \"O\" OR a$ = \"o\") THEN\n     LET orientationx = -1 : LET orientationy = 0: END IF\n\n3230 IF orientationx > -1 AND (a$ = \"P\" OR a$ = \"p\") THEN\n     LET orientationx = 1 : LET orientationy = 0: END IF\n\n3240 IF orientationy < 1 AND (a$ = \"Q\" OR a$ = \"q\") THEN\n     LET orientationx = 0 : LET orientationy = -1: END IF\n\n3250 IF orientationy > -1 AND (a$ = \"A\" OR a$ = \"a\") THEN\n     LET orientationx = 0 : LET orientationy = 1: END IF\n\n3500 REM Pausa / Delay\n3505 BEEP 0.005, 0\n3510 FOR i = 1 TO 500:\n     NEXT i\n\n7998 GOTO 3000\n\n8000 REM Fruit placement\n8010 LET fruitx = INT(RND*30)+1\n8020 LET fruity = INT(RND*20)+1\n8030 IF p(fruity+2,fruitx+2) = 0 THEN GOTO 8050: END IF\n8040 GOTO 8010\n8050 PRINT AT fruity,fruitx ; INK 2 ; F$;\n8060 LET p(fruity+2,fruitx+2) = 1\n8070 RETURN\n\n8100 REM Erase tail\n8110 PRINT AT taily,tailx ; \" \"\n8120 LET newtailx = tailx + x(taily+2,tailx+2)\n8130 LET newtaily = taily + y(taily+2,tailx+2)\n8140 LET p(taily+2,tailx+2) = 0\n8150 LET x(taily+2,tailx+2) = 0\n8160 LET y(taily+2,tailx+2) = 0\n8170 LET tailx = newtailx\n8180 LET taily = newtaily\n8190 RETURN\n\n9900 REM Game over\n9910 PRINT AT 10,12 ; INK 2 ; \"GAME OVER...\"\n9920 PRINT AT 11,10 ; INK 2 ; \"SCORE : \" ; score\n9930 PRINT AT 13,10 ; INK 0 ; \"Press any key\"\n9931 REM Mondatory pause so the msg. can be read\n9932 FOR i = 0 TO 100\n\n9933 NEXT i\n9940 LET j$ = INKEY$\n9950 IF j$ <> \"\" THEN GOTO 100: END IF\n9960 GOTO 9940\n```\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "EXTERNAL_RESOURCES": {
    "content": "# External Resources\n\nZX BASIC is an **open compiler toolkit**.\nOther people contribute to it creating alternative IDEs, libraries, tools and utilities. Feel free to browse them, as you might find them useful for your work!\n\n## IDEs\n<abbr title=\"Integrated Development Environments\">IDE</abbr> are integrated source (or bigger projects) editor, sometimes with an integrated debugger and many other tools (e.g. Borland Delphi or Visual Studio are well known IDEs). Some people have developed IDEs usable for ZX BASIC.\n\n### Tommy Gun\nA free IDE created by [Tony Thompson](http://www.users.on.net/~tonyt73). This powerful tool is designed to create\ngeneric 8-bit and 16-bit projects, and can be set up to be used with ZX Basic.\nHave a look at the [TommyGun files](https://sourceforge.net/projects/tommygun/files/) page.\n\nTo integrate ZX Basic with Tommy Gun, please follow this [tutorial](https://www.boriel.com/forum/showthread.php?tid=110).\n\n### SpectNet IDE\nA free and impressive IDE created by [Istvan Novak](https://github.com/Dotneteer).\nThis is a very powerful IDE very advanced and fully documented.\nProceed to the [SpectNet IDE page](https://dotneteer.github.io/spectnetide/) to download the tool and get\nfurther information. The documentation of it is very well maintained.\n\n## Graphics editors\n\n* [SevenUP](http://www.speccy.org/metalbrain/), a ZX Spectrum graphics editor for FreeBSD, GNU/Linux, MacOS and Windows.\n\n* [Multipaint](http://multipaint.kameli.net/), a Java-based graphics editor that allows you to draw pictures with the color limitations of some typical screen formats from 8-bit computer platforms, like ZX Spectrum, C64 and Plus/4 high-resolution and multicolor, MSX 1 and Amstrad CPC0.\n\n* [ZX-Paintbrush] (https://zx-modules.de/), a Windows graphics editor specifically for ZX-Spectrum screen formats, including multicolor.\n\n## Utilities\nOther generic utilities not above are:\n\n### Sublime Text Syntax Highlighting\nSublime Text is a modern macOS/Linux/Windows code editor which now has [ZX BASIC syntax highlighter](https://github.com/patters-syno/zx-basic-syntax) support.\n\n### VIM Syntax Coloring\nIf you use [VIM](http://www.vim.org/) (I do) you can now tell vim to highlight your ZX BASIC .bas listings.\n[Programandala](http://programandala.net/) has a nice Spectrum and retro programming site.\nHe also created a [VIM Syntax File for ZX BASIC](http://programandala.net/en.program.zx_basic_vim_syntax_file).\nI find this very useful.\n\n##Engines\nThere are several external engines that can be used within compiler to achieve effects like multicolour display, or sprite handling.\n\n* [FASE](https://www.boriel.com/forum/showthread.php?tid=568)\n  (or [here](https://www.boriel.com/forum/showthread.php?tid=575)), a sprite, tile and map engine.\n* [Nirvana](https://spectrumcomputing.co.uk/entry/30001/ZX-Spectrum/NIRVANA_ENGINE)\n  (or [https://www.ime.usp.br/~einar/bifrost/ here]), a multicolour 8x2 (30x22 chars) graphics engine.\n* [Nirvana+](https://spectrumcomputing.co.uk/entry/30002/ZX-Spectrum/NIRVANA_ENGINE)\n  (or [https://www.ime.usp.br/~einar/bifrost/ here]), a multicolour 8x2 (32x23 chars) graphics engine.\n* [Bifrost*](https://spectrumcomputing.co.uk/entry/27405/ZX-Spectrum/BIFROST*_ENGINE)\n  (or [https://www.ime.usp.br/~einar/bifrost/ here]), a multicolour 8x1 (18x18 chars) graphics engine.\n* [Bifrost*2](https://spectrumcomputing.co.uk/entry/30003/ZX-Spectrum/BIFROST*2_ENGINE)\n  (or [https://www.ime.usp.br/~einar/bifrost/ here]), a multicolour 8x1 (20x22 chars) graphics engine.\n* [Zxodus\\]\\[Engine](https://spectrumcomputing.co.uk/entry/26639/ZX-Spectrum/ZXodus_Engine)\n  (or [here](https://www.boriel.com/forum/showthread.php?tid=568)), a 3d maze and RPG engine with\n  multicolour 8x1 (18x18 chars) support.\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "IDENTIFIER": {
    "content": "# Identifier\n\n\nIdentifiers are used in your ZX BASIC program to define _variable names_, _function names_, _subroutine names_ and _[labels](labels.md)_. ZX Basic identifiers **must** start with a letter (a..z / A..Z) followed by an arbitrary number of letters and or digits. Original Sinclair BASIC allows spaces within variable names, but ZX BASIC <u>does not</u> (in fact, I found it a bit confusing!)\n\nSome identifiers are **reserved words**. Most of them are either BASIC _statements_ or _functions_. Functions return a value to be used in an _expression_ whilst statements do not.\n\nNote that there are a number of common statements that you may find in ZX BASIC programs that are not technically reserved words, but library functions. Some of the internal libraries form functions that may overlap with your subroutine and function names (such as POS). So while they may not be technically reserved, you should consider the library function names as ones you should avoid. Also, some Sinclair Basic statements are implemented as library functions, so you should be especially aware of identifiers of this type, such as INPUT, POINT and ATTR.\n\n## Reserved Identifiers\n\nThe following identifiers are _reserved words_, and can't be used as variables, functions or labels. Reserved identifiers are _case insensitive_ (it doesn't matter whether you write them in upper or lower case letters, or a mix of them). So **PRINT**, **print** and **PrInT** means all the same in ZX BASIC. On the other hand, non-reserved words can be either case sensitive or not (depending on the [options](options.md)) in effect.\n\nIdentifiers shown in bold are taken from the Sinclair BASIC (beware their meaning here might be different, however). Some of them has been marked as _statements_, _functions_ or _operators_:\n\n* **[ABS](abs.md)** **(function)**\n* **[ACS](acs.md)** **(function)**\n* **[AND](operators.md#AND)** **(operator)**\n* [ASM](asm.md) **(special)**\n* **[ASN](asn.md)** **(function)**\n* **[AT](at.md)**\n* **[ATN](atn.md)** **(function)**\n* **[bAND](bitwiselogic.md)** **(operator)**\n* **[bNOT](bitwiselogic.md)** **(operator)**\n* **[bOR](bitwiselogic.md)** **(operator)**\n* **[bXOR](bitwiselogic.md)** **(operator)**\n* **[BEEP](beep.md)** **(statement)**\n* [BOLD](bold.md)\n* **[BORDER](border.md)** **(statement)**\n* **[BRIGHT](bright.md)** **(statement)**\n* [ByRef](byref.md)\n* [ByVal](byval.md)\n* [CAST](cast.md) **(function)**\n* **[CHR](chr.md)** **(function)** (can also be written as **CHR$**)\n* **[CIRCLE](circle.md)** **(statement)**\n* **[CLS](cls.md)** **(statement)**\n* **[CODE](code.md)** **(function)**\n* [CONST](const.md)\n* **[CONTINUE](continue.md)** **(statement)**\n* **[COS](cos.md)** **(function)**\n* **[DECLARE](declare.md)** **<modifier>**\n* **[DIM](dim.md)** **(statement)**\n* [DO](do.md) **(statement)**\n* **[DATA](data.md)** **(statement)**\n* **[DRAW](draw.md)** **(statement)**\n* [ELSE](if.md)\n* [ELSEIF](if.md)\n* [END](end.md)\n* [EXIT](exit.md) **(statement)**\n* **[EXP](exp.md)** **(function)**\n* [FastCall](fastcall.md)\n* **[FLASH](flash.md)** **(statement)**\n* **[FOR](for.md)** **(statement)**\n* [FUNCTION](function.md)\n* **[GO TO](goto.md)** or [GOTO](goto.md) **(statement)**\n* **[GO SUB](gosub.md)** or [GOSUB](gosub.md) **(statement)**\n* **[IF](if.md)** **(statement)**\n* **[IN](in.md)** **(function)**\n* **[INK](ink.md)** **(statement)**\n* **[INKEY](inkey.md)** **(function)** (can also be written as **INKEY$**)\n* **[INPUT](input.md)** **(function)** (not compatible with ZX BASIC)\n* **[INT](int.md)** **(function)**\n* **[INVERSE](inverse.md)** **(statement)**\n* [ITALIC](italic.md)\n* [LBOUND](lbound.md) **(function)**\n* **[LET](let.md)** **(statement)**\n* **[LEN](len.md)** **(function)**\n* **[LN](ln.md)** **(function)**\n* **[LOAD](load.md)** **(statement)**\n* [LOOP](do.md) **(statement)**\n* [MOD](operators.md#Arithmetic Operators) **(operator)**\n* **[NEXT](for.md)** **(statement)**\n* **[NOT](operators.md#NOT)** **(operator)**\n* **[ON ... GOTO](on_goto.md)** **(statement)**\n* **[ON ... GOSUB](on_gosub.md)** **(statement)**\n* **[OR](operators.md#OR)** **(operator)**\n* **[OVER](over.md)** **(statement)**\n* **[OUT](out.md)** **(statement)**\n* **[PAPER](paper.md)** **(statement)**\n* **[PAUSE](pause.md)** **(statement)**\n* **[PEEK](peek.md)** **(function)**\n* **[PI](pi.md)** **<constant>**\n* **[PLOT](plot.md)** **(statement)**\n* **[POKE](poke.md)** **(statement)**\n* **[PRINT](print.md)** **(statement)**\n* **[RANDOMIZE](randomize.md)** **(statement)**\n* **[READ](read.md)** **(statement)**\n* **[REM](comments.md)** **(commentary)** (can also be written as ')\n* **[RESTORE](restore.md)** **(statement)**\n* **[RETURN](return.md)** **(statement)**\n* **[RND](rnd.md)** **(function)**\n* **[SAVE](load.md)** **(statement)**\n* **[SGN](sgn.md)** **(function)**\n* [SHL or <<](shl.md) (operator)\n* [SHR or >>](shl.md) (operator)\n* **[SIN](sin.md)** **(function)**\n* **[SQR](sqr.md)** **(function)**\n* [StdCall](stdcall.md)\n* **[STEP](for.md)**\n* **[STOP](stop.md)**\n* **[STR](str.md)** **(function)** (Can also be written as **STR$**)\n* **[SUB](sub.md)**\n* **[TAN](tan.md)** **(function)**\n* **[THEN](if.md)**\n* **[TO](to.md)**\n* [UBOUND](ubound.md) **(function)**\n* [USR](usr.md) **(function)**\n* [UNTIL](do.md) **(statement)**\n* **[VAL](val.md)** **(function)**\n* **[VERIFY](load.md)** **(statement)**\n* [WEND](while.md) **(statement)**\n* [WHILE](while.md) **(statement)**\n* **[XOR](operators.md#logical_operators.md)** **(operator)**\n\n## Inbuilt library Functions\nYou should also avoid defining (with a SUB or FUNCTION command) routines with the following names, as they are available in the internal library for your use, though you are almost certainly going to need to use #include before using them. Note that some Sinclair Basic words are listed here. Some Freebasic commands are also available through #include options for compatibility with freebasic.\n\n* [ASC (Library Function)](library/asc.bas.md) **(function)**\n* **[ATTR (Library Function)](library/attr.md)** **(function)**\n* **[CSRLIN (Library Function)](library/csrlin.md)** **(function)**\n* [HEX (Library Function)](library/hex.md) **(function)**\n* [HEX16 (Library Function)](library/hex.md) **(function)**\n* **[INPUT (Library Function)](library/input.md)** **(function)**\n* **[GetKey (Library Function)](library/keys/getkey.md)** **(function)**\n* **[MultiKeys (Library Function)](library/keys/multikeys.md)** **(function)**\n* **[GetKeyScanCode (Library Function)](library/keys/getkeyscancode.md)** **(function)**\n* **[LCase (Library Function)](library/string/lcase.md)** **(function)**\n* **[UCase (Library Function)](library/string/ucase.md)** **(function)**\n* **[POINT (Library Function)](library/point.md)** **(function)**\n* **[POS (Library Function)](library/pos.md)** **(function)**\n* **[print42 (Library Subroutine)](library/print42.bas.md)** **(sub)**\n* **[printat42 (Library Subroutine)](library/print42.bas.md)** **(sub)**\n* **[print64 (Library Subroutine)](library/print64.bas.md)** **(sub)**\n* **[printat64 (Library Subroutine)](library/print64.bas.md)** **(sub)**\n* **[SCREEN(Library Function)](library/screen.md)** **(function)**\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "INSTALLATION": {
    "content": "# Installation\n\n## Installation of ZX Basic SDK\nZX Basic SDK comes two several flavours:\n\n* OS Specific binary package (the recommended way).<br />\n  For Windows, Mac OS and Linux\n* Multiplatform python scripts (will require Python 3.8+ to be installed in your system)\n\n### Prerequisites\nFor the _Multi-platform_ bundle, you will need a [python](http://www.python.org) interpreter **version 3.8** or\nhigher installed in your system (Linux and Mac OS X users will probably have it already).\n\n### Downloading\nTo get the latest version of the ZX BASIC SDK, head to [Download Page](https://zxbasic.readthedocs.io/en/docs/archive/),\nand get the file you want.\n\n### Installation\nInstallation is pretty straightforward: Just uncompress the SDK tree in a directory of your choice and make sure\nthe folder is included in your PATH environment variable.\n\n## Testing your installation\nFor the binary distribution type **zxbc** (ensure this file is in your PATH).\nYou should see something like:\n```\n >zxbc\n Usage: zxbc <input file> [options]\n\n zxbc: error: missing input file. (Try -h)\n```\n\nFor the python distribution type **zxbc.py** (in windows you can type **zxbc**).\nYou should see something like:\n```\n >zxbc.py\n Usage: zxbc.py <input file> [options]\n\n zxbc.py: error: missing input file. (Try -h)\n```\n\nOk, the compiler is working (or it seems so). Now you should proceed to the following section to learn about its usage.\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "OPERATORS": {
    "content": "# Operators\n\nOperators in ZX Basic can be arithmetical, logical and [bitwise](bitwiselogic.md) ones.\nFor bitwise operators checks the [Bitwise Operators](bitwiselogic.md) page.\n\n## Arithmetic Operators\n\nArithmetic operators are _left associative_ (like in Sinclair BASIC) and have the same _precedence_. The following are a list of arithmetic operators (lower precedence operators appears first):\n\n* `+`, `-` (Addition, Subtraction)<br />Operator `+` (addition) can also be used with\n[strings](types.md#strings) to perform string concatenation.\n\n* `*`, `/`, `mod` (Multiplication, Division and Modulo)\n\n>**Note**: `mod` operator returns the _modulus_ (the reminder) of x / y.<br />\n>E.g. _12 `mod` 5_ = 2. It does not exist in Sinclair BASIC.\n\n\n## Exponentiation\n\n* `^` (Power). x`^`y returns _x <sup>y</sup>_\n\n>**Note**: Unlike Sinclair Basic, this operator is **right associative**.\n\nThis is the usual behavior in mathematics. So in ZX BASIC:\n\n```\n2^3^2 = 2^(3^2) = 512\n```\n\n(notice the right associative parenthesis), whilst in Sinclair BASIC,\n\n```\n2^3^2 = (2^3)^2 = 64\n```\n\n\nwhich is _wrong_. If in doubt, use always parenthesis to enforce the desired evaluation order.\n\n## Logical Operators\n\nLogicals operators are like in ZX Spectrum Basic. Their result can be either _False_ (which is represented with 0)\nor _True_, which might be any other value. <u>Don't expect _True_ value number to be always **1**</u>.\nIf you need 0/1 values for boolean evaluations, use `--strict-boolean` [compiler option](zxb.md#Command Line Options).\nThis might add a little overhead to boolean evaluations, tough.\n\nOperator arguments must be numbers and the result is an unsigned byte value. For binary operators,\nif arguments are of different types they are [converted](cast.md) to a common type before being evaluated:\n\n### Table of Logical Operators\n\n#### AND\n Performs the _Logical Conjunction_ and returns _TRUE_ if and only if both arguments are _TRUE_.\n\n| a  | b  | result |\n|:----:|:----:|:------:|\n|  False  | False |  False |\n|  False  | True  |  False |\n|  True  | False |  False |\n|  True  | True  |  True |\n---\n\n#### OR\nPerforms the _Logical Disjunction_ and returns _TRUE_ if any of the arguments is _TRUE_.\n\n| a  | b  | result |\n|:----:|:----:|:------:|\n|  False  | False |  False |\n|  False  | True  |  True |\n|  True  | False |  True |\n|  True  | True  |  True |\n---\n\n#### XOR\nPerforms a logical XOR and returns TRUE if one of the arguments is true and one of the arguments is false.\nIn essence, returns true if ONLY one of the arguments is true.\n\n| a  | b  | result |\n|:----:|:----:|:------:|\n|  False  | False |  False |\n|  False  | True  |  True |\n|  True  | False |  True |\n|  True  | True  |  False |\n---\n\n### NOT\nPerforms the _Logical Negation_ and returns _TRUE_ if the arguments is _False_ and vice versa.\n\n| a  | result |\n|:----:|:----:|\n|  False  | True |\n|  True  | False |\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "OTHER_ARCHITECTURES": {
    "content": "# Other architectures\n\n## home computers\n\n###[Z80](architectures/z80.md)\n\n* [ZX-Spectrum](architectures/zxspectrum.md)\n* [MSX](architectures/msx.md) 1/2/2+\n* [Amstrad CPC](architectures/amstrad_cpc.md)\n* [TRS 80 Model 1](architectures/trs80_model1.md)\n* Sharp [MZ700](architectures/mz700.md)\n* Mattel [Aquarius](architectures/aquarius.md)\n* Casio [PV-2000](architectures/pv2000.md)\n* Sinclair ZX80 / [ZX81](architectures/zx81.md) / Jupiter Ace\n* [Sam Coupé](architectures/sam_coupe.md)\n* Sord [M5](architectures/sord_m5.md)\n* Bandai [RX-78](architectures/rx78.md)\n* [GEM-1000](architectures/gem-1000.md)/[MC-1000](architectures/gem-1000.md)/[SPC-1000](architectures/gem-1000.md)\n* Philips [VG5000](architectures/vg5000.md)\n* Philips [P2000](architectures/p2000.md)\n* Sega [SC-3000](architectures/sc3000.md)\n* [Galaksija](architectures/galaksija.md)\n* Coleco [Adam](architectures/adam.md)\n* [Memotech MTX](architectures/memotech_mtx.md)\n* [Enterprise 64/128](architectures/enterprise.md)\n* Triumph-Adler [Alphatronic-PC](architectures/alphatronicpc.md)\n* Tesla [Ondra](architectures/ondra.md)\n* [Sharp X1](architectures/sharpx1.md)\n* NEC [PC-6001](architectures/nec_pc6001.md)/[PC-8801](architectures/pc88.md)\n* [Camputers Lynx](architectures/camputers_lynx.md)\n* Vtech Laser-210\n* Exidy Sorcerer\n* Luxor ABC-80/800\n* Nascom\n* Toshiba Pasopia/[Pasopia5](architectures/pasopia5.md)/Pasopia7\n* Hanimex Pencil-II\n* Robotron [KC-85](architectures/kc85.md)\n* Mupid\n* Sega [SG1000/MarkIII/MasterSystem](architectures/segamastersystem.md)\n* [Colecovision](architectures/colecovision.md)\n* [Bally Astrocade](architectures/bally_astrocade.md)\n* Casio [PV-1000](architectures/pv1000.md)\n* Zemmix [(MSX)](architectures/msx.md)\n* [Amstrad GX4000](architectures/amstrad_cpc.md)\n* [Epoch Super-Cassette-Vision](architectures/epochsupercassettevision.md)\n\n### 8080\n\n* Interact\n* [DAI](architectures/dai.md)\n* Tesla [PMD-85](architectures/pmd85.md)\n* Orion-128\n* Kvantor BK-1098\n* Krista-2\n* [Vektor-06c](architectures/vektor06c.md)\n* Compucolor 8001/8051\n* Triumph-Adler Alphatronic-PC P1/P2/P3/P4\n\n###Z84C15\n\n* [Sprinter 2000](architectures/sp2000.md)\n\n###[R800](architectures/r800.md)\n\n* MSX Turbo-R\n\n###[6502](architectures/6502.md)\n\n* [BBC-Micro](architectures/bbc_micro.md)\n* [Apple](architectures/apple_ii.md) I/[II](architectures/apple_ii.md)/III/IIe/IIc\n* Commodore PET/[VIC-20](architectures/vic_20.md)\n* Atari 400/[800](architectures/atari_800.md)/XL/XE\n* Acorn Atom/Electron\n* [Orao](architectures/orao.md)\n* [Galeb](architectures/galeb.md)\n* Ohio Scientific\n* Commodore [C64](architectures/c64.md)\n* Commodore Plus4\n* Commodore [C128](architectures/c128.md)\n\n###[6800](architectures/6800.md)\n\n* Goupil-2\n* APF [Imagination-Machine](architectures/imaginationmachine.md)\n* Matsushita [JR-100](architectures/jr100.md)/[JR-200](architectures/jr200.md)\n* Matra-Hachette Alice/Alice-90\n\n###[6809](architectures/6809.md)\n\n* TRS 80 Color Computer (CoCo1/[CoCo2](architectures/coco2.md)/CoCo3/[Dragon32](architectures/coco2.md)/etc.)\n* Thomson/Olivetti [MO5](architectures/mo5.md)/[Prodest](architectures/mo5.md)/TO7\n* Fujitsu FM-7/FM-8\n\n###65816\n\n* Apple IIGS\n\n###65SC12\n\n* BBC-Master\n\n###K1801VM1\n\n* [Elektronika-BK](architectures/elektronika_bk.md)\n\n###Fairchild-F8\n\n* VideoBrain Family-Computer\n\n###TMS7020\n\n* Exelvision\n\n###TMS9900\n\n* TI-99-4A/Geneve/TIM\n* Tomy Pyuuta/Tutor\n\n### TI-74181\n\n* Xerox Alto\n\n###[68000](architectures/68000.md)\n\n* [Sinclair QL](architectures/sinclair_ql.md)\n* [Amiga](architectures/amiga_500.md) 1000/[500](architectures/amiga_500.md)/2000/1500/600\n* [Atari ST](architectures/atari_st.md)/Atari STE\n* Sharp [X68000](architectures/x68000.md)\n* Apple Lisa\n* Apple Macintosh 128k/Plus/Classic\n* Luxor ABC-1600\n* Silicon Graphics Iris 1000\n\n###[68020](architectures/68020.md)\n\n* Amiga 1200\n\n###[68030](architectures/68030.md)\n\n* Atari Falcon\n* Amiga 3000/4000-030\n\n###[68040](architectures/68040.md)\n\n* Amiga 4000-040\n\n###8086\n\n* NEC [PC-9801](architectures/pc98.md)\n* Toshiba Pasopia1600\n\n###8088\n\n* [IBM PC-XT](architectures/ibm_pc-xt.md)\n* Toshiba Pasopia16\n\n###i386\n\n* Fujitsu FM-Towns\n\n###[ARM](architectures/arm.md)\n\n* Acorn Archimedes\n\n## Game Consoles\n###6502\n\n* [NES](architectures/nes.md)\n* Atari 5200/7800/XEGS\n* [PCEngine](architectures/pcengine.md)/[TurboGrafx](architectures/pcengine.md)\n\n###6809\n\n* Vectrex\n\n###6800\n\n* APF-M1000\n\n###CP1600\n\n* Intellivision\n\n###8048\n\n* Odyssey/Videopac\n\nSignetics-2650A\n* Emerson Arcadia-2001\n\n###68000\n\n* Sega Megadrive/Genesis\n* SNK [NeoGeo](architectures/neogeo.md)\n* Amiga [CDTV](architectures/amiga_500.md)\n* Philips CD-i\n\n###68020\n\n* Amiga CD32\n\ni286\n* Tandy Memorex VIS\n\n###i386\n\n* Fujitsu FM-Towns Marty\n\n###65816\n\n* [SNES](architectures/snes.md)\n\n###ARM\n\n* 3DO\n* Ouya\n\n###PowerPC\n\n* Apple/Bandai Pippin\n\n###MIPS\n\n* Atari Jaguar\n* Nintendo64\n* PlayStation1/PSone\n* PlayStation2\n* Gamebox [GBX-1001](architectures/gbx1001.md)\n\n###SuperH\n\n* Casio Loopy\n\n###Atmega\n\n* [Uzebox](architectures/uzebox.md)\n\n## handheld consoles:\n###8048\n\n* Entex [Adventure Vision](architectures/adventurevision.md)\n\n###Z80\n\n* Sega [GameGear](architectures/segamastersystem.md)\n\n###8080\n\n* Nintendo [GameBoy](architectures/gameboy.md)\n\n###6502\n\n* Watara Supervision\n* NEC TurboExpress\n\n###65SC02\n\n* Atari [Lynx](architectures/atarilynx.md)\n\n###TLCS900H\n\n* SNK [NeoGeo Pocket](architectures/neogeopocket.md)\n\n###80186\n\n* Bandai [Wonderswan](architectures/wonderswan.md)\n\n###S1C33209\n\n* Aquaplus [Piece](architectures/aquapluspiece.md)\n\n###ARM\n\n* GP2X\n* Pandora\n\n###MIPS\n\n* Dingoo\n\n## arcade systems:\n\n### Z80\n\n* Capcom [Section-Z](architectures/sectionz.md)\n* Capcom [1942](architectures/capcom1942.md)\n* Capcom [1943](architectures/capcom1943.md)\n* Enerdyne [American SpeedWay](architectures/enerdyneamericanspeedway.md)\n* Irem [M52](architectures/m52.md)\n* Irem [M62](architectures/m62.md)\n* Irem [M63](architectures/m63.md)\n* Komax [Flower](architectures/komaxflower.md)\n* Konami [Ping Pong](architectures/konamipingpong.md)\n* Konami [Scramble](architectures/scramble.md)\n* Konami [Time Pilot](architectures/konamitimepilot.md)\n* Mondial [Lady Frog](architectures/mondialladyfrog.md)\n* Namco [Galaga](architectures/namcogalaga.md)\n* Namco [PacMan](architectures/namcopacman.md)\n* Namco [Galaxian](architectures/namcogalaxian.md)\n* Orca [Marine Boy](architectures/orcamarineboy.md)\n* Poby [News](architectures/pobynews.md)\n* Sega [Appoooh](architectures/segaappoooh.md)\n* Sega [Bank Panic](architectures/segabankpanic.md)\n* Sega [Pengo](architectures/segapengo.md)\n* Sega [Gigas](architectures/segagigas.md)\n* Sega [SG1000](architectures/segamastersystem.md)\n* Sega [System-E](architectures/segamastersystem.md)\n* Sun [Stratovox](architectures/sunstratovox.md)\n* Taito [Chack’n’Pop](architectures/taitochacknpop.md)\n* Taito [Minivader](architectures/taitominivader.md)\n* Taito [Samurai Nihon Ichi](architectures/taitosamurainihonichi.md)\n* Taito [The Fairyland Story](architectures/taitothefairylandstory.md)\n* Taito [The Legend Of Kage](architectures/taitothelegendofkage.md)\n* Taito [L](architectures/taitol.md)\n* [Tecmo](architectures/tecmo.md)\n* Tecmo [WorldCup90](architectures/worldcup90.md)\n* Tehkan [Pinball Action](architectures/tehkanpinballaction.md)\n\n### 6502\n\n* Atari [Centipede](architectures/ataricentipede.md)\n* Irem [M27](architectures/m27.md)\n* Irem [M10](architectures/m10.md)\n* [Vanguard](architectures/vanguard.md)\n\n### 6809\n\n* Konami [Shaolins Road](architectures/shaolinsroad.md)\n* Capcom [GhostsNGoblins](architectures/ghostsngoblins.md)\n\n### TMS34010\n\n* Midway T-Unit/Y-Unit\n\n### 68000\n\n* SNK [NeoGeo](architectures/neogeo.md)\n* Sega MegaTech/System16/[OutRun](architectures/segaoutrun.md)\n* Taito [F1](architectures/taitof1.md)/[F2](architectures/taitof2.md)/[B](architectures/taitob.md)/[H](architectures/taitoh.md)/[X](architectures/taitox.md)/[Z](architectures/taitoz.md)/[Air](architectures/taitoair.md)/Toaplan\n* Atari G1/ArcadeClassics\n* Konami Hornet\n* Konami Nemesis\n* Taito [Darius](architectures/taitodarius.md)\n\n### 68020\n\n* Taito [F3](architectures/taitof3.md)\n* Atari GT\n* Konami Bemani DJ-Main\n\n### NEC V30\n\n* Irem [M90](architectures/m90.md)\n\n### NEC V60\n\n* Sega System32/[Model1](architectures/segamodel1.md)\n\n### i960\n\n* Sega [Model2](architectures/segamodel2.md)\n\n###Hitachi SuperH\n\n* Sega Hikaru/Aurora/Naomi\n* Kaneko SuperNova\n\n###PowerPC\n\n* Sega [Model3](architectures/segamodel3.md)/Triforce\n* Taito Type-Zero\n* Namco 357\n* Konami M2/Viper/Hornet\n\n###MIPS\n\n* SNK Hyper-NeoGeo64\n* Taito FX-1B/G-Net\n* Namco Super256\n* Konami System573\n* Capcom/Sony ZN-1\n* Atari Cojag/Flagstaff/Phoenix/Seattle/Vegas/Denver\n* Konami Bemani 573/Twinkle/Karaoke\n\n###ARM\n\n* DataEast MLC/Simple156\n\n###i586\n\n* Sega Chihiro/Lindbergh\n* Taito Type-X/Type-X-Zero\n* Namco ES-1/N2\n* Konami Bemani PC Type 1/2/3\n* Cave PC\n* Midway Graphite\n\n###amd64\n\n* Sega Europa-R/RingEdge/RingWide/Nu\n* Taito Type-X2\n* Konami Bemani PC Type 4\n\n###Konami Emotion-Engine (128bit)\n\n* Konami Bemani Python\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "ZX81": {
    "content": "# Released Programs - ZX81\n\n## GAMES\n\n\n## DEMOS\n\n### First test\n\nFirst test for ZX81, almost working fine - still struggling on ix and iy registers, stack point, etc.\n\nAuthor: Paulo Silva\n\nType: development test\n\nYear: 2014, 2016\n\nSource: yes\n\nLink: [http://www.sinclairzxworld.com/viewtopic.php?f=6&t=1887&p=19507#p19507](http://www.sinclairzxworld.com/viewtopic.php?f=6&t=1887&p=19507#p19507)\n\n![Zx81_test01.png](img/zx81_test01.png)\n\n---\n\n\n### Slideshow\n\nA Slideshow\n\nAuthor: Paulo Silva\n\nType: development test\n\nYear: 2016\n\nSource: yes\n\nLink: [https://www.boriel.com/forum/showthread.php?tid=730](https://www.boriel.com/forum/showthread.php?tid=730)\n\nDescription: a slideshow.\n\n![Zx81slideshow01.png](img/zx81slideshow01.png)\n\n---\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "RELEASED_PROGRAMS": {
    "content": "# Released Programs\n\nThis is a list of third-party ZX-Spectrum and ZX-Next programs (mostly games) developed with ZX BASIC.\nSome of them also provide full source code, so they can be used as reference about how to create new programs.\n\nA similar list is also available at [https://spectrumcomputing.co.uk/list?group_id=4007](https://spectrumcomputing.co.uk/list?group_id=4007) and the\nlist of programs with source code at [https://spectrumcomputing.co.uk/list?group_id=4007&source=3](https://spectrumcomputing.co.uk/list?group_id=4007&source=3).\n\n\n---\n## PLAYABLE GAMES\n\n### 3 Reyes Magos\n\nAuthor: J.B.G.V.\n\nType: Arcade Game\n\nYear: 2012\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/27998/ZX-Spectrum/3_Reyes_Magos](https://spectrumcomputing.co.uk/entry/27998/ZX-Spectrum/3_Reyes_Magos)\n\n![3ReyesMagos.gif](img/games/3reyesmagos.gif)\n\n\n### 9999 in 1\n\nAuthor: [El Dr. Gusman](https://twitter.com/gusmanb)\n\nType: Arcade Game\n\nYear: 2020\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/36513/ZX-Spectrum/9999_IN_1](https://spectrumcomputing.co.uk/entry/36513/ZX-Spectrum/9999_IN_1)\n\n![9999-1.png](img/games/9999-1.png)\n\n\n---\n### A Broken Friend\n\nAuthor: Paul Jenkinson\n\nType: Text Adventure Game\n\nYear: 2012\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/27296/ZX-Spectrum/A_Broken_Friend](https://spectrumcomputing.co.uk/entry/27296/ZX-Spectrum/A_Broken_Friend)\n\n![BrokenFriend.gif](img/games/brokenfriend.gif)\n\n---\n### Abydos\n\nAuthor: J.B.G.V.\n\nType: Platform Game\n\nYear: 2013\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/28165/ZX-Spectrum/ABYDOS](https://spectrumcomputing.co.uk/entry/28165/ZX-Spectrum/ABYDOS)\n\n![Abydos.png](img/games/abydos.png)\n\n---\n### AD LUNAM\n\nAuthor: [Alessandro Grussu](https://www.alessandrogrussu.it/profilo.html)\n\nType: Simulation / Management\n\nYear: 2019\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/35151/ZX-Spectrum/Ad_Lunam](https://spectrumcomputing.co.uk/entry/35151/ZX-Spectrum/Ad_Lunam)\n\n![ad_lunam.png](img/games/ad_lunam.png)\n\n---\n### AD LUNAM PLUS\n\nAuthor: [Alessandro Grussu](https://www.alessandrogrussu.it/profilo.html)\n\nType: Simulation / Management\n\nYear: 2020\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/36138/ZX-Spectrum/Ad_Lunam_Plus](https://spectrumcomputing.co.uk/entry/36138/ZX-Spectrum/Ad_Lunam_Plus)\n\n![ad_lunam_plus.png](img/games/ad_lunam_plus.png)\n\n---\n### Bacaball\n\nAuthor: Paulo Silva\n\nType: Sport Game\n\nYear: 2011\n\nSource: Yes\n\nLink: [http://www.mojontwins.com/csscgc2011/nitrofurano-bacaball/](http://www.mojontwins.com/csscgc2011/nitrofurano-bacaball/)\n\n![Bacaball.png](img/games/bacaball.png)\n\n---\n### Bacachase\n\nAuthor: Paulo Silva\n\nType: Puzzle Game\n\nYear: 2011\n\nSource: Yes\n\nLink: [http://www.mojontwins.com/csscgc2011/nitrofurano-bacachase/](http://www.mojontwins.com/csscgc2011/nitrofurano-bacachase/)\n\n![Bacachase.png](img/games/bacachase.png)\n\n---\n### BerksMan\n\nAuthor: Paul Fisher\n\nType: Arcade Game\n\nYear: 2012\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/27713/ZX-Spectrum/BerksMan](https://spectrumcomputing.co.uk/entry/27713/ZX-Spectrum/BerksMan)\n\nProgramming tutorial discussing how this was made: [Link](http://goo.gl/4jPd5)\n\n![BerksMan.gif](img/games/berksman.gif)\n\n---\n### Bikers\n\nAuthor: [Cavern Games](https://www.joflof.com)\n\nType: Arcade Game (Racing)\n\nYear: 2020\n\nSource: No\n\nLink: [https://cavern.games/bikers](https://cavern.games/bikers)\n\n![bikers.png](img/games/bikers.png)\n\n---\n### Binary Land\n\nAuthor: [Joflof](https://www.joflof.com)\n\nType: Arcade Game\n\nYear: 2020\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/35777/ZX-Spectrum/Binary_Land](https://spectrumcomputing.co.uk/entry/35777/ZX-Spectrum/Binary_Land)\n\n![binaryland.png](img/games/binaryland.png)\n\n---\n### Bounty - The Search for Frooge\n\nAuthor: Paul Jenkinson\n\nType: Text Adventure Game\n\nYear: 2012\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/27876/ZX-Spectrum/Bounty-The_Search_for_Frooge](https://spectrumcomputing.co.uk/entry/27876/ZX-Spectrum/Bounty-The_Search_for_Frooge)\n\n![Bounty.gif](img/games/bounty.gif)\n\n---\n### Break/Space\n\nAuthor: Blerkotron\n\nType: Strategy Game\n\nYear: 2017\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/30410/ZX-Spectrum/BreakSpace](https://spectrumcomputing.co.uk/entry/30410/ZX-Spectrum/BreakSpace)\n\n![breakspace.gif](img/games/breakspace.gif)\n\n---\n### Chessboard Attack\n\nAuthors: Leszek Chmielewski Daniel (LCD), Kriss\n\nType: Board Game\n\nYear: 2011\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/26121/ZX-Spectrum/Chessboard_Attack](https://spectrumcomputing.co.uk/entry/26121/ZX-Spectrum/Chessboard_Attack)\n\n![ChessboardAttack.gif](img/games/chessboardattack.gif)\n\n---\n### Ciclopes (y Saturno)\n\nAuthors: Apenao\n\nType: Sports\n\nYear: 2013\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/30024/ZX-Spectrum/Ciclopes](https://spectrumcomputing.co.uk/entry/30024/ZX-Spectrum/Ciclopes)\n\n![CiclopesYSaturno.png](img/games/ciclopesysaturno.png)\n\n---\n### Coches\n\nAuthors: Apenao\n\nType: Racing\n\nYear: 2013\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/30025/ZX-Spectrum/Coches](https://spectrumcomputing.co.uk/entry/30025/ZX-Spectrum/Coches)\n\n![Coches.png](img/games/coches.png)\n\n---\n### Cuadragon\n\nAuthor: [Duefectu](http://duefectucorp.com/)\n\nType: Adventure Game\n\nYear: 2020\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/35339/ZX-Spectrum/Cuadragon](https://spectrumcomputing.co.uk/entry/35339/ZX-Spectrum/Cuadragon)\n\n![cuadragon.png](img/games/cuadragon.png)\n\n---\n### Cuadragon Next\n\nAuthor: [Duefectu](http://duefectucorp.com/)\n\nType: Adventure Game\n\nYear: 2021\n\nSource: No\n\nLink: [https://cuadragonnext.duefectucorp.com/](https://cuadragonnext.duefectucorp.com/)\n\n![cuadragon.png](img/games/cuadragon_next.png)\n\n---\n### Dex\n\nAuthor: Lee Tonks\n\nType: Arcade Game\n\nYear: 2011\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/26574/ZX-Spectrum/Dex](https://spectrumcomputing.co.uk/entry/26574/ZX-Spectrum/Dex)\n\n![Dex.gif](img/games/dex.gif)\n\n---\n### Earthraid\n\nAuthors: Leszek Chmielewski Daniel (LCD)\n\nType: Strategy Game\n\nYear: 2012\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/27687/ZX-Spectrum/Earthraid](https://spectrumcomputing.co.uk/entry/27687/ZX-Spectrum/Earthraid)\n\n![earthraidingame.gif](img/games/earthraidingame.gif)\n\n---\n### El Hobbit\n\nAuthor: J.B.G.V.\n\nType: Arcade (Platform)\n\nYear: 2012\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/27993/ZX-Spectrum/El_Hobbit](https://spectrumcomputing.co.uk/entry/27993/ZX-Spectrum/El_Hobbit)\n\n![HobbitEl_2.gif](img/games/hobbitel_2.gif)\n\n---\n### El Hobbit\n\nAuthor: Alejandro Valero\n\nType: Graphic Adventure\n\nYear: 2012\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/27992/ZX-Spectrum/El_Hobbit](https://spectrumcomputing.co.uk/entry/27992/ZX-Spectrum/El_Hobbit)\n\n![HobbitEl.gif](img/games/hobbitel.gif)\n\n---\n### Eleuterio, el Mono Serio (demo)\n\nAuthor: na_th_an (The Mojon Twins)\n\nType: Arcade (Platform)\n\nYear: 2012\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/27307/ZX-Spectrum/Mojon_Twins_Covertape_#1](https://spectrumcomputing.co.uk/entry/27307/ZX-Spectrum/Mojon_Twins_Covertape_#1)\n\n![EleuterioElMonoSerio.gif](img/games/eleuterioelmonoserio.gif)\n\n---\n### Encuerer\n\nAuthor: na_th_an (LOKOsoft)\n\nType: Arcade (Platform)\n\nYear: 2013\n\nSource: Yes\n\nLink: [http://www.csscgc2013.blogspot.com.es/2013/02/encuerer.html](http://www.csscgc2013.blogspot.com.es/2013/02/encuerer.html)\n\n![Encuerer.gif](img/games/encuerer.gif)\n\n---\n### Escape from Cnossus\n\nAuthor: Felix Plesoianu\n\nType: Dungeon Game\n\nYear: 2013\n\nSource: Yes\n\nLink: [http://notimetoplay.org/our-games/escape-from-cnossus/](http://notimetoplay.org/our-games/escape-from-cnossus/)\n\n![cnossus.png](img/games/cnossus.png)\n\n---\n### Explorer\n\nAuthor: Luca bordoni\n\nType: Arcade Game / Shoot-em-up\n\nYear: 2015\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/30212/ZX-Spectrum/Explorer](https://spectrumcomputing.co.uk/entry/30212/ZX-Spectrum/Explorer)\n\n![explorer_scr.png](img/games/explorer_scr.png)\n\n---\n### H7N9\n\nAuthor: Paulo Silva\n\nType: Platform\n\nYear: 2015\n\nSource: Yes\n\nLink: [https://nitrofurano.itch.io/h7n9](https://nitrofurano.itch.io/h7n9)\n\n![h7n9.png](img/games/h7n9.png)\n\n---\n### He had such a big head that if he were a cat he would have to toss the mice from under the bed with a brow\n\nAuthor: The Mojon Twins\n\nType: Arcade (Platform)\n\nYear: 2010\n\nSource: Yes\n\nLink: [http://www.mojontwins.com/2010/05/04/mojontwins-en-la-csscgc-2010/](http://www.mojontwins.com/2010/05/04/mojontwins-en-la-csscgc-2010/)\n\n![Cabezooon.png](img/games/cabezooon.png)\n\n---\n### Hunt the Wumpus\n\nAuthor: Leszek Chmielewski Daniel (LCD)\n\nType: Maze Game\n\nYear: 2013\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/28119/ZX-Spectrum/Hunt_the_Wumpus](https://spectrumcomputing.co.uk/entry/28119/ZX-Spectrum/Hunt_the_Wumpus)\n\n![Hunt_the_wumpus.png](img/games/hunt_the_wumpus.png)\n\n---\n### Italia 1944\n\nAuthor: Alessandro Grussu ([Zankle Soft](https://zanklesoft.itch.io/))\n\nType: RPG - Adventure\n\nYear: 2021\n\nSource: No\n\nLink: [https://zanklesoft.itch.io/italia-1944](https://zanklesoft.itch.io/italia-1944)\n\n![italia1944.png](img/games/italia1944.png)\n\n---\n### Knights & Demons DX\n\nAuthors: Manuel Gomez, Einar Saukas, Craig Stevenson\n\nType: Puzzle Game\n\nYear: 2013\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/28175/ZX-Spectrum/Knights_Demons_DX](https://spectrumcomputing.co.uk/entry/28175/ZX-Spectrum/Knights_Demons_DX)\n\n![KnightsDemonsDX.png](img/games/knightsdemonsdx.png)\n\n---\n### Lamega\n\nAuthor: rikokun\n\nType: Shooter\n\nYear: 2016\n\nSource: no\n\nLink: [https://spectrumcomputing.co.uk/entry/30284/ZX-Spectrum/Lamega](https://spectrumcomputing.co.uk/entry/30284/ZX-Spectrum/Lamega)\n\n![Lamega.png](img/games/lamega.png)\n\n---\n### Looking for a csscgc2012 theme\n\nAuthor: Paulo Silva\n\nType: Adventure Game\n\nYear: 2012\n\nSource: Yes\n\nLink: [https://www.yoursinclair.co.uk/csscgc/csscgc.cgi?search=0301180542lookingforacsscgc2012theme_20120301145340.zip](https://www.yoursinclair.co.uk/csscgc/csscgc.cgi?search=0301180542lookingforacsscgc2012theme_20120301145340.zip)\n\nDescription: optimized for ULA-Plus palette\n\n![Lookingforacsscgc2012theme.png](img/games/lookingforacsscgc2012theme.png)\n\n---\n### Maritrini, Freelance Monster Slayer en: Las Increibles Vicisitudes de Despertarse Resacosa con Fred en la Cama y Tener que Llegar Mas o Menos Puntual a la Prueba de \"Monstruos Vigorosos de Pechos Lustrosos\" featuring Los Fratelli\n\nAuthor: The Mojon Twins\n\nType: Arcade Game\n\nYear: 2012\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/27953/ZX-Spectrum/Maritrini_Freelance_Monster_Slayer_en_Las_Increibles_Vicisitudes_de_Despertarse_](https://spectrumcomputing.co.uk/entry/27953/ZX-Spectrum/Maritrini_Freelance_Monster_Slayer_en_Las_Increibles_Vicisitudes_de_Despertarse_)\n\n![maritrini.gif](img/games/maritrini.gif)\n\n---\n### Memorama\n\nAuthor: Paulo Silva\n\nType: Puzzle Game\n\nYear: 2011\n\nSource: Yes\n\nLink: [http://www.mojontwins.com/csscgc2011/paulo-silva-memorama/](http://www.mojontwins.com/csscgc2011/paulo-silva-memorama/)\n\n![Memorama.png](img/games/memorama.png)\n\n---\n### O-CMAN\n\nAuthor: oblo\n\nType: Arcade Game\n\nYear: 2011\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/26598/ZX-Spectrum/O-Cman](https://spectrumcomputing.co.uk/entry/26598/ZX-Spectrum/O-Cman)\n\n![O-Cman.gif](img/games/o-cman.gif)\n\n---\n### O-TRIX\n\nAuthor: oblo\n\nType: Puzzle Game\n\nYear: 2011\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/26573/ZX-Spectrum/O-Trix](https://spectrumcomputing.co.uk/entry/26573/ZX-Spectrum/O-Trix)\n\n![O-Trix.gif](img/games/o-trix.gif)\n\n---\n### Pets vs Aliens Prologue\n\nAuthors: Einar Saukas, Jarrod Bentley, Yerzmyey\n\nType: Puzzle Game\n\nYear: 2015\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/30197/ZX-Spectrum/Pets_vs_Aliens_Prologue](https://spectrumcomputing.co.uk/entry/30197/ZX-Spectrum/Pets_vs_Aliens_Prologue)\n\n![PvAPrologue.png](img/games/pvaprologue.png)\n\n---\n### Pixel Quest\n\nAuthor: Einar Saukas, MmcM, Craig Stevenson\n\nType: Puzzle\n\nYear: 2015\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/30237/ZX-Spectrum/Pixel_Quest](https://spectrumcomputing.co.uk/entry/30237/ZX-Spectrum/Pixel_Quest)\n\n![pixelquest.png](img/games/pixelquest.png)\n\n---\n### Pixel Quest 2000\n\nAuthor: Einar Saukas, MmcM, PheeL\n\nType: Puzzle\n\nYear: 2017\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/31490/ZX-Spectrum/Pixel_Quest_2000](https://spectrumcomputing.co.uk/entry/31490/ZX-Spectrum/Pixel_Quest_2000)\n\n![pixelquest2000.png](img/games/pixelquest2000.png)\n\n---\n### Pixel Quest Zero\n\nAuthor: Einar Saukas, MmcM, PheeL\n\nType: Puzzle\n\nYear: 2018\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/34291/ZX-Spectrum/Pixel_Quest_Zero](https://spectrumcomputing.co.uk/entry/34291/ZX-Spectrum/Pixel_Quest_Zero)\n\n![pixelquestzero.png](img/games/pixelquestzero.png)\n\n---\n### Quest for Witchcraft\n\nAuthors: Leszek Chmielewski Daniel (LCD), Mister Beep\n\nType: Puzzle Game\n\nYear: 2011\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/27261/ZX-Spectrum/Quest_for_Witchcraft](https://spectrumcomputing.co.uk/entry/27261/ZX-Spectrum/Quest_for_Witchcraft)\n\n![QuestForWitchcraft.gif](img/games/questforwitchcraft.gif)\n\n---\n### Ratul & Zeki\n\nAuthor: Salvacam (Spain)\n\nType: Arcade (Platform)\n\nYear: 2011\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/27055/ZX-Spectrum/Ratul_Zeki](https://spectrumcomputing.co.uk/entry/27055/ZX-Spectrum/Ratul_Zeki)\n\n![RatulZeki.gif](img/games/ratulzeki.gif)\n\n---\n### Retrobsesion\n\nAuthor: J.B.G.V.\n\nType: Arcade Game\n\nYear: 2011\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/26193/ZX-Spectrum/Retrobsesion](https://spectrumcomputing.co.uk/entry/26193/ZX-Spectrum/Retrobsesion)\n\n![Retrobsesion.gif](img/games/retrobsesion.gif)\n\n---\n### Retrobsesion II\n\nAuthor: J.B.G.V.\n\nType: Arcade Game\n\nYear: 2012\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/27389/ZX-Spectrum/Retrobsesion_II](https://spectrumcomputing.co.uk/entry/27389/ZX-Spectrum/Retrobsesion_II)\n\n![RetrobsesionII.gif](img/games/retrobsesionii.gif)\n\n---\n### Saltarin\n\nAuthor: Salvacam (Spain)\n\nType: Arcade (Platform)\n\nYear: 2011\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/27160/ZX-Spectrum/Saltarin](https://spectrumcomputing.co.uk/entry/27160/ZX-Spectrum/Saltarin)\n\n![Saltarin.gif](img/games/saltarin.gif)\n\n---\n### Solitario\n\nAuthor: Paulo Silva\n\nType: Puzzle Game\n\nYear: 2011\n\nSource: Yes\n\nLink: [http://www.mojontwins.com/csscgc2011/nitrofurano-solitario/](http://www.mojontwins.com/csscgc2011/nitrofurano-solitario/)\n\n![Solitario.png](img/games/solitario.png)\n\n---\n### Souls\n\nAuthor: Alxinho\n\nType: Platform Game\n\nYear: 2013\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/28172/ZX-Spectrum/Souls](https://spectrumcomputing.co.uk/entry/28172/ZX-Spectrum/Souls)\n\n![Souls.gif](img/games/souls.gif)\n\n---\n### SpeccyWars\n\nAuthor: Slenkar\n\nType: Strategy Game\n\nYear: 2013\n\nSource: Yes\n\nLink: [https://www.boriel.com/forum/showthread.php?tid=410&highlight=speccywars](https://www.boriel.com/forum/showthread.php?tid=410&highlight=speccywars)\n\n![Speccywars.png](img/games/speccywars.png)\n\n---\n### Stela\n\nAuthor: J.B.G.V.\n\nType: Arcade Game\n\nYear: 2011\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/26527/ZX-Spectrum/Stela](https://spectrumcomputing.co.uk/entry/26527/ZX-Spectrum/Stela)\n\n![Stela.gif](img/games/stela.gif)\n\n---\n### Steroids Sports Diving: Splash\n\nAuthor: apenao\n\nType: Sports Game\n\nYear: 2012\n\nSource: No\n\nLink: [http://cgc.zx.gen.tr/index.php?game=0628182038](http://cgc.zx.gen.tr/index.php?game=0628182038)\n\n![Splash.gif](img/games/splash.gif)\n\n---\n### The Spectral Dungeons\n\nAuthor: Felix Plesoianu\n\nType: Dungeon Game\n\nYear: 2013\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/28173/ZX-Spectrum/The_Spectral_Dungeons](https://spectrumcomputing.co.uk/entry/28173/ZX-Spectrum/The_Spectral_Dungeons)\n\n![SpectralDungeonsThe.gif](img/games/spectraldungeonsthe.gif)\n\n---\n### The Tales of Grupp\n\nAuthor: Alxinho\n\nType: ?\n\nYear: 2015\n\nSource: Yes\n\nLink: [http://retrobytesproductions.blogspot.com.es/2015/02/the-tales-of-grupp.html](http://retrobytesproductions.blogspot.com.es/2015/02/the-tales-of-grupp.html)\n\n![TalesOfGruppThe.png](img/games/talesofgruppthe.png)\n\n---\n### U-Boot Hunt\n\nAuthor: Leszek Chmielewski Daniel (LCD)\n\nType: Puzzle Game\n\nYear: 2012\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/27688/ZX-Spectrum/U-Boot_Hunt](https://spectrumcomputing.co.uk/entry/27688/ZX-Spectrum/U-Boot_Hunt)\n\n![Uboothuntingame.gif](img/games/uboothuntingame.gif)\n\n---\n### Uchi-Danza\n\nAuthor: J.B.G.V.\n\nType: Action Game\n\nYear: 2011\n\nSource: No\n\nLink: [http://www.mojontwins.com/csscgc2011/jbgv-uchi-danza/](http://www.mojontwins.com/csscgc2011/jbgv-uchi-danza/)\n\n![UchiDanza.png](img/games/uchidanza.png)\n\n---\n### VADE RETRO\n\nAuthor: J.B.G.V.\n\nType: Action Game\n\nYear: 2012\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/27878/ZX-Spectrum/VADE_RETRO](https://spectrumcomputing.co.uk/entry/27878/ZX-Spectrum/VADE_RETRO)\n\n![VADERETRO.gif](img/games/vaderetro.gif)\n\n---\n### Vampe: GOTO Vampe\n\nAuthor: Valdir\n\nType: Maze Game\n\nYear: 2013\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/28168/ZX-Spectrum/Vampe_GOTO_Vampe](https://spectrumcomputing.co.uk/entry/28168/ZX-Spectrum/Vampe_GOTO_Vampe)\n\n![Vampe-GOTOVampe.gif](img/games/vampe-gotovampe.gif)\n\n---\n### Walking around Porto\n\nAuthor: Paulo Silva\n\nType: ?\n\nYear: 2013\n\nSource: Yes\n\nLink: [http://csscgc2013.blogspot.pt/2013/06/walking-around-porto.html](http://csscgc2013.blogspot.pt/2013/06/walking-around-porto.html)\n\nDescription: a tour in Porto (or Oporto) city - runs on a 128kb ZX-Spectrum, on a b&w display\n\n![Walkingaroundporto.png](img/games/walkingaroundporto.png)\n\n---\n### Yumiko in the haunted Mansion\n\nAuthor: Leszek Chmielewski Daniel (LCD)\n\nType: Action Game\n\nYear: 2012\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/27988/ZX-Spectrum/Yumiko_in_the_Haunted_Mansion](https://spectrumcomputing.co.uk/entry/27988/ZX-Spectrum/Yumiko_in_the_Haunted_Mansion)\n\n![YIthM.gif](img/games/yithm.gif)\n\n---\n### ZEN\n\nAuthor: Einar Saukas, Mister Beep\n\nType: Puzzle\n\nYear: 2014\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/30157/ZX-Spectrum/ZEN](https://spectrumcomputing.co.uk/entry/30157/ZX-Spectrum/ZEN)\n\n![zen.png](img/games/zen.png)\n\n---\n### ZEN II\n\nAuthor: Einar Saukas, Mister Beep\n\nType: Puzzle\n\nYear: 2015\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/30208/ZX-Spectrum/ZEN_II](https://spectrumcomputing.co.uk/entry/30208/ZX-Spectrum/ZEN_II)\n\n![zen2.png](img/games/zen2.png)\n\n---\n### ZX Connection\n\nAuthor: [Antonio Silva](https://avlixa.itch.io/)\n\nType: Arcade Game\n\nYear: 2020\n\nSource: Yes\n\nLink: [https://avlixa.itch.io/zx-connection](https://avlixa.itch.io/zx-connection)\n\n![zxconnection.png](img/games/zxconnection.png)\n\n---\n### ZX Destroyer\n\nAuthor: Alxinho\n\nType: Shooter\n\nYear: 2014\n\nSource: Yes\n\nLink: [http://retrobytesproductions.blogspot.com.es/2014/03/zx-destroyer.html](http://retrobytesproductions.blogspot.com.es/2014/03/zx-destroyer.html)\n\n![ZXDestroyer.png](img/games/zxdestroyer.png)\n\n---\n### ZX Striker\n\nAuthor: Valdir\n\nType: Sports Game\n\nYear: 2013\n\nSource: No\n\nLink: [https://spectrumcomputing.co.uk/entry/28170/ZX-Spectrum/ZX_Striker](https://spectrumcomputing.co.uk/entry/28170/ZX-Spectrum/ZX_Striker)\n\n![ZXStriker.png](img/games/zxstriker.png)\n\n\n---\n## DEMOS\n\n### EMS Christmas Card Demo\n\nAuthor: Eqx\n\nType:\n\nYear: 2016\n\nSource: No\n\nLink: [http://www.boriel.com/forum/gallery/ems-christmas-card-demo-t1102.html](http://www.boriel.com/forum/gallery/ems-christmas-card-demo-t1102.html)\n\n![EmsChristmasCardDemo.png](img/games/emschristmascarddemo.png)\n\n---\n### JRPG Test\n\nAuthor: rikokun\n\nType:\n\nYear: 2016\n\nSource: No\n\nLink: [http://www.boriel.com/forum/gallery/jrpg-test-and-tileeditor-t1082.html](http://www.boriel.com/forum/gallery/jrpg-test-and-tileeditor-t1082.html)\n\n![JRPGTest.png](img/games/jrpgtest.png)\n\n---\n### Just Something Silly\n\nAuthor: emook\n\nType: Demo\n\nYear: 2016\n\nSource: No\n\nLink: [http://www.boriel.com/forum/gallery/just-something-silly-t1095.html](http://www.boriel.com/forum/gallery/just-something-silly-t1095.html)\n\nDescription:\n\n![JustSomethingSilly.png](img/games/justsomethingsilly.png)\n\n---\n### Nothing Thing\n\nAuthor: Paulo Silva\n\nType: Demo\n\nYear: 2013\n\nSource: Yes\n\nLink: [http://csscgc2013.blogspot.pt/2013/03/nothing-thing.html](http://csscgc2013.blogspot.pt/2013/03/nothing-thing.html)\n\nDescription: optimized for ULA-Plus palette, it will look weird on common ZX-Spectrum machines.\n\n![Nothingthing_fbzx_ulaplus_b.png](img/games/nothingthing_fbzx_ulaplus_b.png)\n\n\n\n---\n## GAME ENGINES\n\n### BIFROST* ENGINE\n\nAuthors: Einar Saukas, Dave Hughes\n\nType: Multicolor Engine\n\nYear: 2012\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/27405/ZX-Spectrum/BIFROST*_ENGINE](https://spectrumcomputing.co.uk/entry/27405/ZX-Spectrum/BIFROST*_ENGINE)\n\n![BIFROST.png](img/games/bifrost.png)\n\n---\n### BIFROST*2 ENGINE\n\nAuthor: Einar Saukas\n\nType: Multicolor Engine\n\nYear: 2016\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/30003/ZX-Spectrum/BIFROST*2_ENGINE](https://spectrumcomputing.co.uk/entry/30003/ZX-Spectrum/BIFROST*2_ENGINE)\n\n![BIFROST2.png](img/games/bifrost2.png)\n\n---\n### Fourspriter Engine\n\nAuthor: The Mojon Twins\n\nType: Sprite Engine\n\nYear: 2010\n\nSource: Yes\n\nLink: [http://www.mojontwins.com/juegos_mojonos/fourspriter-1-0/](http://www.mojontwins.com/juegos_mojonos/fourspriter-1-0/)\n\n![Fourspriter.png](img/games/fourspriter.png)\n\n---\n### NIRVANA ENGINE\n\nAuthor: Einar Saukas\n\nType: Bicolor Engine\n\nYear: 2013\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/30001/ZX-Spectrum/NIRVANA_ENGINE](https://spectrumcomputing.co.uk/entry/30001/ZX-Spectrum/NIRVANA_ENGINE)\n\n![NIRVANA.png](img/games/nirvana.png)\n\n---\n### NIRVANA+ ENGINE\n\nAuthor: Einar Saukas\n\nType: Bicolor Engine\n\nYear: 2015\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/30002/ZX-Spectrum/NIRVANA_ENGINE](https://spectrumcomputing.co.uk/entry/30002/ZX-Spectrum/NIRVANA_ENGINE)\n\n![NIRVANAPLUS.png](img/games/nirvanaplus.png)\n\n\n\n---\n## UTILITIES\n\n### +3e FileBrowser\n\nAuthor: BCH\n\nType: Utility\n\nYear: 2013\n\nSource: Yes\n\nLink: [https://www.boriel.com/forum/showthread.php?tid=529&pid=3334#pid3334](https://www.boriel.com/forum/showthread.php?tid=529&pid=3334#pid3334)\n\n![P3efilebrowser.png](img/games/p3efilebrowser.png)\n\n---\n### Multi I/O Board\n\nAuthor: Ian Johnston\n\nType: Utility\n\nYear: 2014\n\nSource: Yes\n\nLink: [https://www.boriel.com/forum/showthread.php?tid=299&pid=4142#pid4142](https://www.boriel.com/forum/showthread.php?tid=299&pid=4142#pid4142)\n\n![MultiIOboard.png](img/games/multiioboard.png)\n\n---\n### The Spectrum Client\n\nAuthor: ardentcrest\n\nType: Utility\n\nYear: 2015\n\nSource: No\n\nLink: [https://www.boriel.com/forum/showthread.php?tid=644](https://www.boriel.com/forum/showthread.php?tid=644)\n\n![TheSpectrumClient.png](img/games/thespectrumclient.png)\n\n\n\n---\n### ZX0\n\nAuthor: Einar Saukas\n\nType: Utility\n\nYear: 2021\n\nSource: Yes\n\nLink: [https://github.com/einar-saukas/ZX0](https://github.com/einar-saukas/ZX0)\n\n![zx0.png](img/games/zx0.png)\n\n\n\n---\n### ZX7\n\nAuthor: Einar Saukas\n\nType: Utility\n\nYear: 2012\n\nSource: Yes\n\nLink: [https://spectrumcomputing.co.uk/entry/27996/ZX-Spectrum/ZX7](https://spectrumcomputing.co.uk/entry/27996/ZX-Spectrum/ZX7)\n\n![zx7compressionmethodeinarsaukas.png](img/games/zx7compressionmethodeinarsaukas.png)\n\n\n\n---\n## HARDWARE ADD-ONS\n\n- [Spectra](released_programs_-_spectra.md)\n\n---\n## OTHER HARDWARE\n\n### Home Computers\n\n- Sinclair (this page, default)\n\n- ASCII [MSX](released_programs_-_msx.md)\n\n- Mattel [Aquarius](released_programs_-_mattelaquarius.md)\n\n- [ZX-Evolution/ATM-Turbo](released_programs_-_zxevolutionatmturbo.md)\n\n- Amstrad [CPC](released_programs_-_amstradcpc.md)\n\n- MGT [Sam Coupé](released_programs_-_samcoupe.md)\n\n- CCE [MC-1000](released_programs_-_mc1000.md)\n\n- Sinclair [ZX81](released_programs/zx81.md)\n\n- Casio [PV-2000](released_programs_-_pv2000.md)\n\n- Sharp [MZ-700](released_programs_-_mz700.md)\n\n- Sord [M5](released_programs_-_sordm5.md)\n\n- Tandy Radio Shack [TRS-80 Model I](released_programs_-_trs-80.md)\n\n- Bandai [Gundam RX-78](released_programs_-_rx78.md)\n\n- Philips/Radiola [VG5000](released_programs_-_vg5000.md)\n\n- [Enterprise 64/128](released_programs_-_enterprise.md)\n\n### Game Consoles\n\n- Amstrad [GX4000](released_programs_-_amstradcpc.md)\n\n- Bally [Astrocade](released_programs_-_ballyastrocade.md)\n\n- Casio [PV-1000](released_programs_-_pv1000.md)\n\n- Coleco [ColecoVision](released_programs_-_colecovision.md)\n\n- Sega [SG1000](released_programs_-_sg1000.md)\n\n- Sega [Master System](released_programs_-_sms.md)\n\n### Handheld Consoles\n\n- Sega [GameGear](released_programs_-_gamegear.md)\n\n### Arcade Systems\n\n- Ace [Sidewinder](released_programs_-_acesidewinder.md)\n\n- Alphadenshi/Sega [Champion Baseball](released_programs_-_alphadenshisegachampionbaseball.md)\n\n- Bally/Midway [Rampage](released_programs_-_ballymidwayrampage.md)\n\n- Bally/Midway/Zilec [Blue Print](released_programs_-_ballymidwayzilecblueprint.md)\n\n- Barko [One+Two](released_programs_-_barkooneplustwo.md)\n\n- Bordun [Sky Lancer](released_programs_-_bordunskylancer.md)\n\n- Capcom [1942](released_programs_-_capcom1942.md)\n\n- Capcom [BlackTiger](released_programs_-_capcomblacktiger.md)\n\n- Capcom [Higemaru](released_programs_-_capcomhigemaru.md)\n\n- Capcom [Section-Z](released_programs_-_capcomsectionz.md)\n\n- Capcom [Vulgus](released_programs_-_capcomvulgus.md)\n\n- Chuo [Time Limit](released_programs_-_chuotimelimit.md)\n\n- Crawl/Denshi [Dorachan](released_programs_-_crawldenshidorachan.md)\n\n- Daehyun [Pipeline](released_programs_-_daehyunpipeline.md)\n\n- Dyna [Royal Casino](released_programs_-_dynaroyalcasino.md)\n\n- ElectronicDevices [Ping Pong Masters ’93](released_programs_-_electronicdevicespingpongmasters93.md)\n\n- Enerdyne [American SpeedWay](released_programs_-_enerdyneamericanspeedway.md)\n\n- Epos [Megadon](released_programs_-_eposmegadon.md)\n\n- Funai/Gakken [Esh’s Aurunmilla](released_programs_-_funaigakkeneshsaurunmilla.md)\n\n- Funai/Gakken [Interstellar Laser Fantasy](released_programs_-_funaigakkeninterstellarlaserfantasy.md)\n\n- Hoei [Laser Base](released_programs_-_hoeilaserbase.md)\n\n- InChang [Funny Bubble](released_programs_-_inchangfunnybubble.md)\n\n- Invi [Egg Hunt](released_programs_-_inviegghunt.md)\n\n- Irem [M52](released_programs_-_iremm52.md)\n\n- Irem [M62](released_programs_-_iremm62.md)\n\n- Irem/GDI [Oli-Boo-Chu](released_programs_-_iremgdioliboochu.md)\n\n- Jackson [Flipper Jack](released_programs_-_jacksonflipperjack.md)\n\n- Jaleco [D-Day](released_programs_-_jalecodday.md)\n\n- Jaleco [Field Combat](released_programs_-_jalecofieldcombat.md)\n\n- Jaleco [Moero Pro Yakyuu Homerun Kyousou](released_programs_-_jalecomoeroproyakyuuhomerunkyousou.md)\n\n- Jaleco [Naughty Boy](released_programs_-_jaleconaughtyboy.md)\n\n- Kaneko [Fast Freddie](released_programs_-_kanekofastfreddie.md)\n\n- Kaneko [Fighting Roller](released_programs_-_kanekofightingroller.md)\n\n- Kiwako [Mr. Jong](released_programs_-_kiwakomrjong.md)\n\n- Komax [Flower](released_programs_-_komaxflower.md)\n\n- Konami [Green Beret](released_programs_-_konamigreenberet.md)\n\n- Konami [Mogura Desse](released_programs_-_konamimoguradesse.md)\n\n- Konami [Ping Pong](released_programs_-_konamipingpong.md)\n\n- Konami [Pooyan](released_programs_-_konamipooyan.md)\n\n- Konami [Scramble](released_programs_-_scramble.md)\n\n- Konami [Super Cobra](released_programs_-_konamisupercobra.md)\n\n- Konami [Target Panic](released_programs_-_konamitargetpanic.md)\n\n- Konami [Test Board](released_programs_-_konamitestboard.md)\n\n- Konami [Time Pilot](released_programs_-_konamitimepilot.md)\n\n- Meadows [WarpSpeed](released_programs_-_meadowswarpspeed.md)\n\n- Mondial [LadyFrog](released_programs_-_mondialladyfrog.md)\n\n- Namco [PacMan](released_programs_-_pacman.md)\n\n- Nichibutsu [Gomoku Narabe Renju](released_programs_-_nichibutsugomokunaraberenju.md)\n\n- Nichibutsu [Seicross](released_programs_-_nichibutsuseicross.md)\n\n- Nintendo [Donkey Kong](released_programs_-_nintendodonkeykong.md)\n\n- Olympia [D-Day](released_programs_-_olympiadday.md)\n\n- Omori [Car Jamboree](released_programs_-_omoricarjamboree.md)\n\n- Omori [Space Guerrilla](released_programs_-_omorispaceguerrilla.md)\n\n- Orca [Funky Bee](released_programs_-_orcafunkybee.md)\n\n- Orca [Marine Boy](released_programs_-_orcamarineboy.md)\n\n- Orca [Zodiack](released_programs_-_orcazodiack.md)\n\n- Orca/Thunderbolt [Espial](released_programs_-_orcathunderboltespial.md)\n\n- PAL [Chance Thirty Two](released_programs_-_palchance32.md)\n\n- Photon-IK2 [Brodjaga](released_programs_-_photonik2brodjaga.md)\n\n- Poby [News](released_programs_-_pobynews.md)\n\n- San Remo [Number One](released_programs_-_sanremonumberone.md)\n\n- Sanritsu [Dr. Micro](released_programs_-_sanritsudrmicro.md)\n\n- Sega [Appoooh](released_programs_-_segaappoooh.md)\n\n- Sega [Bank Panic](released_programs_-_segabankpanic.md)\n\n- Sega [Dottori Kun](released_programs_-_segadottorikun.md)\n\n- Sega [E](released_programs_-_segae.md)\n\n- Sega [Gigas](released_programs_-_segagigas.md)\n\n- Seibu Kaihatsu [Knuckle Joe](released_programs_-_seibukaihatsuknucklejoe.md)\n\n- Seibu Kaihatsu [Wiz](released_programs_-_seibukaihatsuwiz.md)\n\n- Seoul Coin [Quiz Olympic](released_programs_-_seoulcoinquizolympic.md)\n\n- Seta Kikaku [Hana Awase](released_programs_-_setakikakuhanaawase.md)\n\n- Shoei [Sky Army](released_programs_-_shoeiskyarmy.md)\n\n- Stern [Astro Invader](released_programs_-_sternastroinvader.md)\n\n- Stern [Berzerk](released_programs_-_sternberzerk.md)\n\n- Success/Fujiwara [Super Othello](released_programs_-_successfujiwarasuperothello.md)\n\n- Summit Coin [Push Over](released_programs_-_summitcoinpushover.md)\n\n- Sun [Dai San Wakusei Meteor](released_programs_-_sundaisanwakuseimeteor.md)\n\n- Sun [Markham](released_programs_-_sunmarkham.md)\n\n- Sun [Stratovox](released_programs_-_sunstratovox.md)\n\n- Sun [StrenghtAndSkill](released_programs_-_sunstrenghtandskill.md)\n\n- Taito [Chack'n'Pop](released_programs_-_taitochacknpop.md)\n\n- Taito [Crazy Balloon](released_programs_-_taitocrazyballoon.md)\n\n- Taito [Kusayakyuu](released_programs_-_taitokusayakyuu.md)\n\n- Taito [Marine Date](released_programs_-_taitomarinedate.md)\n\n- Taito [Metal Soldier Isaac II](released_programs_-_taitometalsoldierisaac2.md)\n\n- Taito [Minivader](released_programs_-_taitominivader.md)\n\n- Taito [Pit and Run](released_programs_-_taitopitandrun.md)\n\n- Taito [Samurai Nihon Ichi](released_programs_-_taitosamurainihonichi.md)\n\n- Taito [The Fairyland Story](released_programs_-_taitothefairylandstory.md)\n\n- Taito [The Legend of Kage](released_programs_-_taitothelegendofkage.md)\n\n- Taito [The Pit](released_programs_-_taitothepit.md)\n\n- Taito [WyvernF0](released_programs_-_taitowyvernf0.md)\n\n- Taiyo [ChineseHero](released_programs_-_taiyochinesehero.md)\n\n- Tamtex [Shisensho Joshiryo Hen](released_programs_-_tamtexshisenshojoshiryohen.md)\n\n- Tecfri [Sauro](released_programs_-_tecfrisauro.md)\n\n- [Tecmo](released_programs_-_tecmo.md)\n\n- Tecmo [Solomon’s Key](released_programs_-_tecmosolomonskey.md)\n\n- Tehkan [Bomb Jack](released_programs_-_tehkanbombjack.md)\n\n- Tehkan [Pinball Action](released_programs_-_tehkanpinballaction.md)\n\n- Tehkan [Red Clash](released_programs_-_tehkanredclash.md)\n\n- Teknon Kogyo [Beam Invader](released_programs_-_teknonkogyobeaminvader.md)\n\n- Universal [Cheeky Mouse](released_programs_-_universalcheekymouse.md)\n\n- Universal [Cosmic Alien](released_programs_-_universalcosmicalien.md)\n\n- Universal [Do Castle](released_programs_-_universaldocastle.md)\n\n- Universal [Lady Bug](released_programs_-_universalladybug.md)\n\n- Universal [Mr. Do](released_programs_-_universalmrdo.md)\n\n- Valadon [Bagman](released_programs_-_valadonbagman.md)\n\n- Valadon [Tank Busters](released_programs_-_valadontankbusters.md)\n\n- VEB [Poly-Play](released_programs_-_vebpolyplay.md)\n\n- Wing [Super Wing](released_programs_-_wingsuperwing.md)\n\n- Wonwoo [Domino Block](released_programs_-_wonwoodominoblock.md)\n\n- Zaccaria [Jack Rabbit](released_programs_-_zaccariajackrabbit.md)\n\n- Zilec [Enigma II](released_programs_-_zilecenigma2.md)\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "SAMPLE_PROGRAMS": {
    "content": "# Sample Programs\n\n## Examples\n\nTutorials and examples are the fastest way (in my opinion) to learn a new language.\nWell, ZX BASIC is not so _new_ if you are used to Sinclair BASIC.\nThe following is a list of examples, some of them already bundled with\nthe ZX BASIC distribution in the `examples/` directory:\n\n* [CIRCLE.BAS](examples/circle.bas.md)\n<br />Draws a circle pixel by pixel using [PLOT](plot.md) primitive\n* [CLOCK.BAS](examples/clock.bas.md)\n<br />Sample clock which uses the FRAMES variable (taken from the ZX Spectrum 48K user manual)\n* [CLOCK2.BAS](examples/clock2.bas.md)\n<br />Like above, but a bit improved.\n* [COLORS.BAS](examples/colors.bas.md)\n<br />Colors example from the ZX Spectrum user manual\n* [LINES.BAS](examples/lines.bas.md)\n<br />Random color lines example from the ZX Spectrum 48K user manual.\n* [FACT.BAS](examples/fact.bas.md)\n<br />Factorial ''recursive'' test.\n* [FREREGUSTAV.BAS](examples/freregustav.bas.md)\n<br />A sound demo (taken from the ZX Spectrum 48K user manual)\n* [FLAG.BAS](examples/flag.bas.md)\n<br /> UK Flag drawing (taken from the ZX Spectrum 48K / 128K user manual)\n* [FRACTAL.BAS](examples/fractal.bas.md)\n<br /> Mandelbrot fractal by @Britlion\n\n### Games\n* [SNAKE.BAS](examples/snake.bas.md)<br />\nThe snake game by Federico J. Álvarez Valero (2003-02-05) (English version)\n\n* [4INAROW.BAS](examples/4inarow.bas.md)<br />\nA _4 in a Row_ program with <abbr title=\"Artificial Intelligence\">A.I.</abbr> that plays against you and fit\nin just 16Kb. Published on the 80's in the Spanish\n[MicroHobby magazine, issue 18](https://microhobby.speccy.cz/mhforever/numero018.htm)\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "SYNTAX": {
    "content": "# Syntax\n\n## Introduction\n\nThis page is about the ZX BASIC language syntax. It is part of the Language Reference Guide.\nZX BASIC aims to be a modern BASIC dialect but tries to keep some (many) of the original Sinclair BASIC features for the nostalgic. So you can use it in both ways.\n\nThe BASIC dialect is mainly based in [FreeBasic](http://www.zxbasic.net/wiki/). Many of the language specifications have been taken from there.\n\n## ZX BASIC syntax overview\n\nIf you have ever programmed in legacy BASIC (either Sinclair BASIC or any other flavour) you will already know that BASIC languages are **line oriented**. Each sentence or group of sentences are separated in lines (ended with a carriage return).\n\nNowadays this is not necessary, but ZX BASIC allows you to use lines and line numbers for compatibility (and nostalgic!) reasons:\n\n```\n10 REM This is a comment.\n20 PRINT \"Hello world!\"\n```\n\n\nOther than that, line numbers are ignored (well, not exactly: line numbers are treated as [labels](labels.md)).\nSo the previous BASIC program could be also written this way:\n\n```\nREM This is a comment.\nPRINT \"Hello world!\"\n```\n\n\n### Lines and sentences\n\nSince ZX BASIC is **line oriented** this implies that the ''end of line'' (also known as ''carriage return'' or ''<CR>'') is taken into account during syntax checking, and you cannot break lines in the middle of a sentence:\n\n```\nREM The following line has a syntax error\nPRINT\n    \"Hello world!\"\n```\n\n\nOther languages (like C or Pascal) allows this because they're not line oriented. If you need to break a line, use the\nunderline character (**_**) at the end of line to tell the compiler the current line continues in the next one:\n\n```\nREM The following line is broken into two, but it's ok\nPRINT _\n    \"Hello world!\"\n```\n(Notice the **_** character at the end of the second line).\n\n### Sentences and block of sentences\n\nA sentence is the simplest BASIC instruction (e.g. **[PRINT](print.md)**). Sentences might contain ''arguments'' and can be separated by a ''colon'' (:) as in Sinclair BASIC or by ''end of line''. A ''block of sentences'' are just a group of sentences one after another. Usually the reserved word **END** denotes the end of such block. E.g.\n\n```\nIF a > b THEN\n    PRINT \"A is greater than B\"\n    PRINT \"and that's all\"\nEND IF\n```\n\nIn the previous example, everything between **[THEN](if.md)** and **[END IF](if.md)** conforms a ''block of sentences''. Some sentences (like the shown **[IF](if.md)**) works with sentences block. They are called ''compound sentences''.\n\n### Identifiers\n\n[Identifiers](identifier.md) are used to denote variables, labels, sentences and functions. Some identifiers are\n_reserved_ for ZX BASIC statements (e.g. **[PRINT](print.md)**) or predefined functions (e.g. **[COS](cos.md)**).\nProceed to the [identifiers](identifier.md) page for a list of _reserved words_.\n\n### Numbers\n\nDecimal numbers should be entered as one would normally expect. The compiler also accepts hexadecimal and binary numbers.\n\n* For hexadecimal numbers, use either a trailing h (e.g. `9Ch`) or a leading dollar symbol (`$9C`).\n* For binary numbers, use either a trailing b (e.g. `11001001b`) or a leading percent symbol (`%11001001`)\n\n```\n Note: Take care of using a trailing h for hexadecimals starting with a letter.\n E.g. C9h is an identifier!\n```\nWhen writing an hexadecimal number with a trailing h, if the number begins with a letter (e.g. C9h), prefix it with a 0 digit.\nSo, `C9` hex should be written as `0C9h` or `$C9`.\n\n### Comments\n\nAs shown in the previous examples, the ''reserved word'' **REM** is used for comments and ''remarks''. However, you can also use the single quote (') character for comments instead of **REM**:\n\n```\n10 REM This is a comment\n20 'This is also a comment\n30 PRINT \"Hello world!\"\n```\n\nYou can also comment a block of lines, and even comment _broken_ lines.\nRead [comments](comments.md) article for more information.\n\n### Graphic characters\n\nThe ZX Spectrum had two types of graphics characters; block graphics and user-defined graphics (UDG).\nThe method for entering them into ZX BASIC is the same as that found in the .bas file format created by Paul Dunn\nfor his BASin BASIC IDE.\n\nUDG can be entered into the code with an escape before the letter that corresponds to the udg.\nFor the first udg, for example, use \\A\n\nBlock graphics characters can be entered into code with a similar escape sequence.\nThe \\ is used to escape the characters and a combination of the characters `:` (colon), `'` (apostrophe) and `.` (dot)\nare used to represent the blocks. So a full solid block would be `\\::` An \"L\" shaped block would be `\\:.` and an \"r\"\nshaped one would be `\\:'`. The system is fairly intuitive when you see how it works.\nTo put it another way, a block graphic is an escape ( \\ ) followed by two characters.\nThe `:` represents both top and bottom as ink; `'` represents top only, and `.` represents bottom only.\nA blank space represents both blocks blank or paper. The complete list of possibilities is this:\n\n```\n \\·· (Space, Space)             CHR$(128)\n \\·' (Space, Apostrophe)        CHR$(129)\n \\'· (Apostrophe, Space)        CHR$(130)\n \\'' (Apostrophe, Apostrophe)   CHR$(131)\n \\·. (Space, Period)            CHR$(132)\n \\·: (Space, Colon)             CHR$(133)\n \\'. (Apostrophe, Period)       CHR$(134)\n \\': (Apostrophe, Period)       CHR$(135)\n \\.· (Period, Space)            CHR$(136)\n \\.' (Period, Apostrophe)       CHR$(137)\n \\:· (Colon, Space)             CHR$(138)\n \\:' (Colon, Apostrophe)        CHR$(139)\n \\.. (Period, Period)           CHR$(140)\n \\.: (Period, Colon)            CHR$(141)\n \\:. (Colon, Period)            CHR$(142)\n \\:: (Colon, Colon)             CHR$(143)\n```\n\n\n### Other escaped characters\n```\n \\\\ The \\ backslash symbol.\n \\` The £ pound sterling symbol. (Just backtick ` works too)\n \\#nnn Any character, where nnn is a decimal number in the range 000 to 255.\n \\* The (C) Copyright Symbol.\n```\n\n### Embedded color control codes\n\nSometimes, in a program, one might wish to embed colour control codes into strings for printing. This is possible using the same schema as Paul Dunn's BASIC IDE BASin.\n\nThe escape sequences for control characters are as follows:\n\n* `\\{iN}` Ink colour N, where N is in the range 0 to 8.\n* `\\{pN}` Paper colour N, where N is in the range 0 to 8.\n* `\\{bN}` Bright N, where N is 0 or 1.\n* `\\{fN}` Flash N, where N is 0 or 1.\n\nSo, for example, an embedded control code for red ink would be `\\{i2}`.\n8 is used to signify \"transparent\" (i.e. do not change the ink/paper value in the square being printed)\n\n## Data types\n\nZX Basic [types](types.md) ranges from 8 to 32 bits for integer formats. It also supports floating point format (the ZX ROM 40 bits floating point from the ROM FP Calculator) and ''Fixed'' for fixed point arithmetic. See [types page](types.md) for more information.\n\n## Inline assembly\n\nThe Compiler supports inline assembly, starting with the ASM directive and ending with an END ASM directive. Between these two, raw z80 assembly becomes legal. This assembly data will be passed directly to the assembler as part of the compiled assembler source.\n\nNote that the rules for assembly change dramatically from standard ZX BASIC, and this mode is not for the unwary.\n\n**Of note**\n\n* Comments are begun with a semicolon (`;`) instead of an apostrophe (`'`).\n* The assembler supports `DEFB` to define comma separated bytes, or a quote delimited string.\n* The assembler supports `DEFS n,B` to shortcut a series of n bytes of value B.\n* The assembler supports its own set of #directives, including [incbin](asm/incbin.md)\n\nA novice user of assembly would be well advised to examine code held in the [library](library.md) for examples and usage.\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "TEMPLATE": {
    "content": "**Remarks**\r\n\r\n## Requires:\r\n\r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n\r\n## Links \r\n\r\n[Index](Index.md)\r\n\r\n\r\n## Remarks\r\n\r\nMore info : [https://wiki.specnext.dev/Anti-brick_Register](https://wiki.specnext.dev/Anti-brick_Register)\r\n\r\nRequires: \r\n\r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n\r\n## Requires:\r\n```\r\n#INCLUDE <nextlib.bas>\r\n```\r\n## Links \r\n[DISABLEMUSIC](DisableMusic.md)\r\n[ENABLEMUSIC](EnableMusic.md)\r\n[ENABLESFX](EnableSfx.md)\r\n[InitMusic()](InitMusic.md)\r\n[InitSFX()](InitSFX.md)\r\n[Interrupts](Interrupts.md)\r\n[Index](Index.md) \r\n\r\n\r\n\r\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "TUTORIALS": {
    "content": "# Tutorials\n\nThis is a list of programming tutorials for ZX BASIC.\n\n## How to Write a Pac Man Clone (ZX Basic Project from the beginning)\n\nAuthor: Britlion<br />\nLink: [http://goo.gl/4jPd5](http://goo.gl/4jPd5)\n\n## Making ZX Basic to work with Tommy Gun\n\nAuthor: Boriel<br />\nLink: [https://www.boriel.com/forum/showthread.php?tid=110](https://www.boriel.com/forum/showthread.php?tid=110)\n\n## How to Use Inline Assembly\n\nAuthor: Britlion<br />\nLink: [http://goo.gl/Iw32U](http://goo.gl/Iw32U)\n\n## ZX Basic + Fourspriter (Spanish)\n\nAuthor: na_th_an<br />\nLink: [http://tcyr.wordpress.com/tutoriales/](http://tcyr.wordpress.com/tutoriales/)<br />\n(Don't forget you can get auto translation: via [Google](http://translate.google.com/translate?hl=en&sl=auto&tl=en&u=http%3A%2F%2Ftcyr.wordpress.com%2Ftutoriales%2F))\n\n## Fondos vectoriales con SUVLEIR 3.0 (Spanish)\n\nAuthor: na_th_an<br />\nLink: [http://tcyr.wordpress.com/2012/03/07/suvleir-3-0-super-ultra-vector-library-experience-inspire-redux-3-0/](http://tcyr.wordpress.com/2012/03/07/suvleir-3-0-super-ultra-vector-library-experience-inspire-redux-3-0/)\nand via [Google](http://translate.google.com/translate?sl=auto&tl=en&js=n&prev=_t&hl=en&ie=UTF-8&layout=2&eotf=1&u=http%3A%2F%2Ftcyr.wordpress.com%2F2012%2F03%2F07%2Fsuvleir-3-0-super-ultra-vector-library-experience-inspire-redux-3-0%2F&act=url)\n\n## Using Beepola with ZX BASIC\n\nAuthor: LTee<br />\nLink: [https://www.boriel.com/forum/showthread.php?tid=368](https://www.boriel.com/forum/showthread.php?tid=368)\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "ZX_SPECTRUM_CHARACTER_SET": {
    "content": "# ZX Spectrum Character Set and Z80 Assembly Reference\n\nThis is the complete Spectrum character set, with codes in decimal and hex. If one imagines the codes as being Z80 machine code instructions, then the right hand columns give the corresponding assembly language mnemonics. As you are probably aware if you understand these things, certain Z80 instructions are compounds starting with CBh or EDh; the two right hand columns give these.\n\n| Code | Character | Hex | Z80 Assembler | after CB | after ED |\n|------|-----------|-----|---------------|----------|----------|\n| 0 | Not used | 00 | nop | rlc b | |\n| 1 | Not used | 01 | ld bc,NN | rlc c | |\n| 2 | Not used | 02 | ld (bc),a | rlc d | |\n| 3 | Not used | 03 | inc bc | rlc e | |\n| 4 | Not used | 04 | inc b | rlc h | |\n| 5 | Not used | 05 | dec b | rlc l | |\n| 6 | PRINT comma | 06 | ld b,N | rlc (hl) | |\n| 7 | EDIT | 07 | rlca | rlc a | |\n| 8 | ← | 08 | ex af,af' | rrc b | |\n| 9 | → | 09 | add hl,bc | rrc c | |\n| 10 | ↓ | 0A | ld a,(bc) | rrc d | |\n| 11 | ↑ | 0B | dec bc | rrc e | |\n| 12 | DELETE | 0C | inc c | rrc h | |\n| 13 | ENTER | 0D | dec c | rrc l | |\n| 14 | number | 0E | ld c,N | rrc (hl) | |\n| 15 | not used | 0F | rrca | rrc a | |\n| 16 | INK control | 10 | djnz DIS | rl b | |\n| 17 | PAPER control | 11 | ld de,NN | rl c | |\n| 18 | FLASH control | 12 | ld (de),a | rl d | |\n| 19 | BRIGHT control | 13 | inc de | rl e | |\n| 20 | INVERSE control | 14 | inc d | rl h | |\n| 21 | OVER control | 15 | dec d | rl l | |\n| 22 | AT control | 16 | ld d,N | rl (hl) | |\n| 23 | TAB control | 17 | rla | rl a | |\n| 24 | Not used | 18 | jr DIS | rr b | |\n| 25 | Not used | 19 | add hl,de | rr c | |\n| 26 | Not used | 1A | ld a,(de) | rr d | |\n| 27 | Not used | 1B | dec de | rr e | |\n| 28 | Not used | 1C | inc e | rr h | |\n| 29 | Not used | 1D | dec e | rr l | |\n| 30 | Not used | 1E | ld e,N | rr (hl) | |\n| 31 | Not used | 1F | rra | rr a | |\n| 32 | space | 20 | jr nz, DlS | sla b | |\n| 33 | ! | 21 | ld hl,NN | sla c | |\n| 34 | \" | 22 | ld (NN),hl | sla d | |\n| 35 | # | 23 | inc hl | sla e | |\n| 36 | $ | 24 | inc h | sla h | |\n| 37 | % | 25 | dec h | sla l | |\n| 38 | & | 26 | ld h,N | sla (hl) | |\n| 39 | ' | 27 | daa | sla a | |\n| 40 | ( | 28 | jr z,DlS | sra b | |\n| 41 | ) | 29 | add hl,hl | sra c | |\n| 42 | * | 2A | ld hl,(NN) | sra d | |\n| 43 | + | 2B | dec hl | sra e | |\n| 44 | , | 2C | inc l | sra h | |\n| 45 | - | 2D | dec l | sra l | |\n| 46 | . | 2E | ld l,N | sra (hl) | |\n| 47 | / | 2F | cpl | sra a | |\n| 48 | 0 | 30 | jr nc,DlS | | |\n| 49 | 1 | 31 | ld sp,NN | | |\n| 50 | 2 | 32 | ld (NN),a | | |\n| 51 | 3 | 33 | inc sp | | |\n| 52 | 4 | 34 | inc (hl) | | |\n| 53 | 5 | 35 | dec (hl) | | |\n| 54 | 6 | 36 | ld (hl),N | | |\n| 55 | 7 | 37 | scf | | |\n| 56 | 8 | 38 | jr c,DlS | srl b | |\n| 57 | 9 | 39 | add hl,sp | srl c | |\n| 58 | : | 3A | ld a,(NN) | srl d | |\n| 59 | ; | 3B | dec sp | srl e | |\n| 60 | < | 3C | inc a | srl h | |\n| 61 | = | 3D | dec a | srl l | |\n| 62 | > | 3E | ld a,N | srl (hl) | |\n| 63 | ? | 3F | ccf | srl a | |\n| 64 | @ | 40 | ld b,b | bit 0,b | in b,(c) |\n| 65 | A | 41 | ld b,c | bit 0,c | out (c),b |\n| 66 | B | 42 | ld b,d | bit 0,d | sbc hl,bc |\n| 67 | C | 43 | ld b,e | bit 0,e | ld (NN),bc |\n| 68 | D | 44 | ld b,h | bit 0,h | neg |\n| 69 | E | 45 | ld b,l | bit 0,l | retn |\n| 70 | F | 46 | ld b,(hl) | bit 0,(hl) | im 0 |\n| 71 | G | 47 | ld b,a | bit 0,a | ld i,a |\n| 72 | H | 48 | ld c,b | bit 1,b | in c,(c) |\n| 73 | I | 49 | ld c,c | bit 1,c | out (c),c |\n| 74 | J | 4A | ld c,d | bit 1,d | adc hl,bc |\n| 75 | K | 4B | ld c,e | bit 1,e | ld bc,(NN) |\n| 76 | L | 4C | ld c,h | bit 1,h | |\n| 77 | M | 4D | ld c,l | bit 1,l | reti |\n| 78 | N | 4E | ld c,(hl) | bit 1,(hl) | |\n| 79 | O | 4F | ld c,a | bit 1,a | ld r,a |\n| 80 | P | 50 | ld d,b | bit 2,b | in d,(c) |\n| 81 | Q | 51 | ld d,c | bit 2,c | out (c),d |\n| 82 | R | 52 | ld d,d | bit 2,d | sbc hl,de |\n| 83 | S | 53 | ld d,e | bit 2,e | ld (NN),de |\n| 84 | T | 54 | ld d,h | bit 2,h | |\n| 85 | U | 55 | ld d,l | bit 2,l | |\n| 86 | V | 56 | ld d,(hl) | bit 2,(hl) | im 1 |\n| 87 | W | 57 | ld d,a | bit 2,a | ld a,i |\n| 88 | X | 58 | ld e,b | bit 3,b | in e,(c) |\n| 89 | Y | 59 | ld e,c | bit 3,c | out (c),e |\n| 90 | Z | 5A | ld e,d | bit 3,d | adc hl,de |\n| 91 | [ | 5B | ld e,e | bit 3,e | ld de,(NN) |\n| 92 | \\ | 5C | ld e,h | bit 3,h | |\n| 93 | ] | 5D | ld e,l | bit 3,l | |\n| 94 | ^ | 5E | ld e,(hl) | bit 3,(hl) | im 2 |\n| 95 | _ | 5F | ld e,a | bit 3,a | ld a,r |\n| 96 | £ | 60 | ld h,b | bit 4,b | in h,(c) |\n| 97 | a | 61 | ld h,c | bit 4,c | out (c),h |\n| 98 | b | 62 | ld h,d | bit 4,d | sbc hl,hl |\n| 99 | c | 63 | ld h,e | bit 4,e | ld (NN),hl |\n| 100 | d | 64 | ld h,h | bit 4,h | |\n| 101 | e | 65 | ld h,l | bit 4,l | |\n| 102 | f | 66 | ld h,(hl) | bit 4,(hl) | |\n| 103 | g | 67 | ld h,a | bit 4,a | rrd |\n| 104 | h | 68 | ld l,b | bit 5,b | in l,(c) |\n| 105 | i | 69 | ld l,c | bit 5,c | out (c),l |\n| 106 | j | 6A | ld l,d | bit 5,d | adc hl,hl |\n| 107 | k | 6B | ld l,e | bit 5,e | ld hl,(NN) |\n| 108 | l | 6C | ld l,h | bit 5,h | |\n| 109 | m | 6D | ld l,l | bit 5,l | |\n| 110 | n | 6E | ld l,(hl) | bit 5,(hl) | |\n| 111 | o | 6F | ld l,a | bit 5,a | rld |\n| 112 | p | 70 | ld (hl),b | bit 6,b | in f,(c) |\n| 113 | q | 71 | ld (hl),c | bit 6,c | |\n| 114 | r | 72 | ld (hl),d | bit 6,d | sbc hl,sp |\n| 115 | s | 73 | ld (hl),e | bit 6,e | ld (NN),sp |\n| 116 | t | 74 | ld (hl),h | bit 6,h | |\n| 117 | u | 75 | ld (hl),l | bit 6,l | |\n| 118 | v | 76 | halt | bit 6,(hl) | |\n| 119 | w | 77 | ld (hl),a | bit 6,a | |\n| 120 | x | 78 | ld a,b | bit 7,b | in a,(c) |\n| 121 | y | 79 | ld a,c | bit 7,c | out (c),a |\n| 122 | z | 7A | ld a,d | bit 7,d | adc hl,sp |\n| 123 | { | 7B | ld a,e | bit 7,e | ld sp,(NN) |\n| 124 | \\| | 7C | ld a,h | bit 7,h | |\n| 125 | } | 7D | ld a,l | bit 7,l | |\n| 126 | ~ | 7E | ld a,(hl) | bit 7,(hl) | |\n| 127 | © | 7F | ld a,a | bit 7,a | |\n| 128 | ■ | 80 | add a,b | res 0,b | |\n| 129 | ■ | 81 | add a,c | res 0,c | |\n| 130 | ■ | 82 | add a,d | res 0,d | |\n| 131 | ■ | 83 | add a,e | res 0,e | |\n| 132 | ■ | 84 | add a,h | res 0,h | |\n| 133 | ■ | 85 | add a,l | res 0,l | |\n| 134 | ■ | 86 | add a,(hl) | res 0,(hl) | |\n| 135 | ■ | 87 | add a,a | res 0,a | |\n| 136 | ■ | 88 | adc a,b | res 1,b | |\n| 137 | ■ | 89 | adc a,c | res 1,c | |\n| 138 | ■ | 8A | adc a,d | res 1,d | |\n| 139 | ■ | 8B | adc a,e | res 1,e | |\n| 140 | ■ | 8C | adc a,h | res 1,h | |\n| 141 | ■ | 8D | adc a,l | res 1,l | |\n| 142 | ■ | 8E | adc a,(hl) | res 1,(hl) | |\n| 143 | ■ | 8F | adc a,a | res 1,a | |\n| 144 | (a) | 90 | sub b | res 2,b | |\n| 145 | (b) | 91 | sub c | res 2,c | |\n| 146 | (c) | 92 | sub d | res 2,d | |\n| 147 | (d) | 93 | sub e | res 2,e | |\n| 148 | (e) | 94 | sub h | res 2,h | |\n| 149 | (f) | 95 | sub l | res 2,l | |\n| 150 | (g) | 96 | sub (hl) | res 2,(hl) | |\n| 151 | (h) | 97 | sub a | res 2,a | |\n| 152 | (i) | 98 | sbc a,b | res 3,b | |\n| 153 | (j) | 99 | sbc a,c | res 3,c | |\n| 154 | (k) | 9A | sbc a,d | res 3,d | |\n| 155 | (l) | 9B | sbc a,e | res 3,e | |\n| 156 | (m) | 9C | sbc a,h | res 3,h | |\n| 157 | (n) | 9D | sbc a,l | res 3,l | |\n| 158 | (o) | 9E | sbc a,(hl) | res 3,(hl) | |\n| 159 | (p) | 9F | sbc a,a | res 3,a | |\n| 160 | (q) | A0 | and b | res 4,b | ldi |\n| 161 | (r) | A1 | and c | res 4,c | cpi |\n| 162 | (s) | A2 | and d | res 4,d | ini |\n| 163 | (t) | A3 | and e | res 4,e | outi |\n| 164 | (u) | A4 | and h | res 4,h | |\n| 165 | RND | A5 | and l | res 4,l | |\n| 166 | INKEY$ | A6 | and (hl) | res 4,(hl) | |\n| 167 | PI | A7 | and a | res 4,a | |\n| 168 | FN | A8 | xor b | res 5,b | ldd |\n| 169 | POINT | A9 | xor c | res 5,c | cpd |\n| 170 | SCREEN$ | AA | xor d | res 5,d | ind |\n| 171 | ATTR | AB | xor e | res 5,e | outd |\n| 172 | AT | AC | xor h | res 5,h | |\n| 173 | TAB | AD | xor l | res 5,l | |\n| 174 | VAL$ | AE | xor (hl) | res 5,(hl) | |\n| 175 | CODE | AF | xor a | res 5,a | |\n| 176 | VAL | B0 | or b | res 6,b | ldir |\n| 177 | LEN | B1 | or c | res 6,c | cpir |\n| 178 | SIN | B2 | or d | res 6,d | inir |\n| 179 | COS | B3 | or e | res 6,e | otir |\n| 180 | TAN | B4 | or h | res 6,h | |\n| 181 | ASN | B5 | or l | res 6,l | |\n| 182 | ACS | B6 | or (hl) | res 6,(hl) | |\n| 183 | ATN | B7 | or a | res 6,a | |\n| 184 | LN | B8 | cp b | res 7,b | lddr |\n| 185 | EXP | B9 | cp c | res 7,c | cpdr |\n| 186 | INT | BA | cp d | res 7,d | indr |\n| 187 | SQR | BB | cp e | res 7,e | otdr |\n| 188 | SGN | BC | cp h | res 7,h | |\n| 189 | ABS | BD | cp l | res 7,l | |\n| 190 | PEEK | BE | cp (hl) | res 7,(hl) | |\n| 191 | IN | BF | cp a | res 7,a | |\n| 192 | USR | C0 | ret nz | set 0,b | |\n| 193 | STR$ | C1 | pop bc | set 0,c | |\n| 194 | CHR$ | C2 | jp nz,NN | set 0,d | |\n| 195 | NOT | C3 | jp NN | set 0,e | |\n| 196 | BIN | C4 | call nz,NN | set 0,h | |\n| 197 | OR | C5 | push bc | set 0,l | |\n| 198 | AND | C6 | add a,N | set 0,(hl) | |\n| 199 | <= | C7 | rst 0 | set 0,a | |\n| 200 | >= | C8 | ret z | set 1,b | |\n| 201 | <> | C9 | ret | set 1,c | |\n| 202 | LINE | CA | jp z,NN | set 1,d | |\n| 203 | THEN | CB | | set 1,e | |\n| 204 | TO | CC | call z,NN | set 1,h | |\n| 205 | STEP | CD | call NN | set 1,l | |\n| 206 | DEF FN | CE | adc a,N | set 1,(hl) | |\n| 207 | CAT | CF | rst 8 | set 1,a | |\n| 208 | FORMAT | D0 | ret nc | set 2,b | |\n| 209 | MOVE | D1 | pop de | set 2,c | |\n| 210 | ERASE | D2 | jp nc,NN | set 2,d | |\n| 211 | OPEN # | D3 | out (N),a | set 2,e | |\n| 212 | CLOSE # | D4 | call nc,NN | set 2,h | |\n| 213 | MERGE | D5 | push de | set 2,l | |\n| 214 | VERIFY | D6 | sub N | set 2,(hl) | |\n| 215 | BEEP | D7 | rst 16 | set 2,a | |\n| 216 | CIRCLE | D8 | ret c | set 3,b | |\n| 217 | INK | D9 | exx | set 3,c | |\n| 218 | PAPER | DA | jp c,NN | set 3,d | |\n| 219 | FLASH | DB | in a,(N) | set 3,e | |\n| 220 | BRIGHT | DC | call c,NN | set 3,h | |\n| 221 | INVERSE | DD | [prefixes instructions using ix] | set 3,l | |\n| 222 | OVER | DE | sbc a,N | set 3,(hl) | |\n| 223 | OUT | DF | rst 24 | set 3,a | |\n| 224 | LPRINT | E0 | ret po | set 4,b | |\n| 225 | LLIST | E1 | pop hl | set 4,c | |\n| 226 | STOP | E2 | jp po,NN | set 4,d | |\n| 227 | READ | E3 | ex (sp),hl | set 4,e | |\n| 228 | DATA | E4 | call po,NN | set 4,h | |\n| 229 | RESTORE | E5 | push hl | set 4,l | |\n| 230 | NEW | E6 | and N | set 4,(hl) | |\n| 231 | BORDER | E7 | rst 32 | set 4,a | |\n| 232 | CONTINUE | E8 | ret pe | set 5,b | |\n| 233 | DIM | E9 | jp (hl) | set 5,c | |\n| 234 | REM | EA | jp pe,NN | set 5,d | |\n| 235 | FOR | EB | ex de,hl | set 5,e | |\n| 236 | GO TO | EC | call pe,NN | set 5,h | |\n| 237 | GO SUB | ED | | set 5,l | |\n| 238 | INPUT | EE | xor N | set 5,(hl) | |\n| 239 | LOAD | EF | rst 40 | set 5,a | |\n| 240 | LIST | F0 | ret p | set 6,b | |\n| 241 | LET | F1 | pop af | set 6,c | |\n| 242 | PAUSE | F2 | jp p,NN | set 6,d | |\n| 243 | NEXT | F3 | di | set 6,e | |\n| 244 | POKE | F4 | call p,NN | set 6,h | |\n| 245 | PRINT | F5 | push af | set 6,l | |\n| 246 | PLOT | F6 | or N | set 6,(hl) | |\n| 247 | RUN | F7 | rst 48 | set 6,a | |\n| 248 | SAVE | F8 | ret m | set 7,b | |\n| 249 | RANDOMIZE | F9 | ld sp,hl | set 7,c | |\n| 250 | IF | FA | jp m,NN | set 7,d | |\n| 251 | CLS | FB | ei | set 7,e | |\n| 252 | DRAW | FC | call m,NN | set 7,h | |\n| 253 | CLEAR | FD | [prefixes instructions using iy] | set 7,l | |\n| 254 | RETURN | FE | cp N | set 7,(hl) | |\n| 255 | COPY | FF | rst 56 | set 7,a | |\n\n## Notes\n\n- The table shows character codes 0-255 in decimal\n- Hex column shows the hexadecimal equivalent\n- Z80 Assembler column shows the corresponding Z80 machine code instruction\n- \"after CB\" column shows Z80 instructions that use the CB prefix\n- \"after ED\" column shows Z80 instructions that use the ED prefix\n- Codes 0-31 are mostly control characters and special functions\n- Codes 32-127 include standard ASCII characters\n- Codes 128-255 include ZX Spectrum BASIC keywords and special characters\n- Some graphic characters are represented as ■ in the markdown due to display limitations\n- Arrow characters (codes 8-11) are represented as ←, →, ↓, ↑",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_ZX_INDEX": {
    "content": "# General\n* [About](about.md)\n<br />About the ZX BASIC SDK\n\n* [ChangeLog](https://github.com/boriel/zxbasic/blob/master/Changelog.md)\n<br />A reduced list of changes/bugfixes\n\n* [Installation](installation.md)\n<br />How to install the ZX Basic SDK in your system, and prerequisites for doing so.\n\n* [SDK tools](tools.md)\n<br />Tools available in the SDK.\n\n* [Command line options](zxb.md#Command_Line_Options)\n<br />Command line options table for the compiler (zxb)\n\n# Download\n\nGet the latest version of ZX BASIC from the [archive](archive.md).\n\n# Released programs\n\n* [Released programs](released_programs.md)\n<br />A list of third-party released programs (mostly games) for the ZX-Spectrum developed with ZX BASIC.\n\n# Learning ZX BASIC\n## Language Reference\n* [Language syntax](syntax.md)\n<br />Language Syntax is very close to the original Sinclair BASIC, but it's expanded and enhanced.\n\n* [Data types](types.md)\n<br />Language data types: Instead of working always with Floating Point numbers (also available), there are also some integer types which are faster an take less memory.\n\n* [Reserved words](identifier.md)\n<br />Comprehensive list (alphabetically ordered) of identifiers you shouldn't use as a ''variable name''. E.g. `FOR`, `PRINT`. If you want usage instructions on a statement, also look here.\n\n* [Standard libraries](library/stdlib.md)\n<br />Standard libraries that comes bundled with the ZX Basic compiler.\n\n## Tutorials\n* [Programming tutorials](tutorials.md)\n<br />A collection of third-party tutorials about development with ZX BASIC.\n\n* [Sample Programs](sample_programs.md)\n<br />Sample programs you can try to see what ZX BASIC looks like and how fast it runs.\n\n* [Sample Games](sample_programs.md#Game Examples)\n<br />Some little games examples.\n\n# Help and Support\n\n* [Community Forum](http://www.boriel.com/forum)\n<br />Have a question? Need help or comment a report a bug? Go to the [ZX BASIC forum](http://www.boriel.com/forum)\n\n# External resources\n\n* Here you are [external resources](external_resources.md): other tools, IDEs, graphic designers and projects related to ZX BASIC. Have a look!\n\n# External libraries\n\n* [Library](library.md)\n<br />Library of functions and subroutines you can use in your programs. You might find them really useful.\n\n# Inline assembler\nEmbedding inline assembler in your code is pretty easy. There's a [tutorial](tutorials.md) on it.\n\n# Compiler internals\nOnly for true hackers: This explains how the compiler does it job, how to expand it, etc. You must be a bit crazy if you enter here...\n\n# Other Architectures\nZX Basic was designed from the base as a Retargeable Compiler, so it should be not hard to extend\nit to other architectures. This is `work in progress`. See [other architectures](other_architectures.md) for more info.\n\n# Contributing\nYou can issue a Pull Request to the [GitHub repository](https://github.com/boriel/zxbasic), report bugs in the forum\nwhen using the compiler, suggest new features...\n\n[![ko-fi](https://www.ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/H2H81J0OU)\n",
    "category": "reference",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_AUDIO": {
    "content": "# Music & Sound FX\r\n\r\nThe ZX Spectrum Next comes with 3 x AY8910 programmable sound generators that are each capable of producing square tones on 3 seperate channels ```A,B```or ```C``` giving a total of **9** channel AY audio. \r\n\r\nEach chip can be selected by setting the correct value on port ```$FFDD``` \r\n\r\n```\r\n  ' select chip 1\r\n  out $FFDD, $fd \r\n  ' select chip 2\r\n  out $FFDD, $fe \r\n  ' select chip 3\r\n  out $FFDD, $ff\r\n```\r\n\r\nIt is possible to play music using 1 x AY and sounds effects on another. NextBuild comes with commands that assist you in playing music and sound effects together. \r\n\r\nThe AY sound module runs on an Interrupt, which means it will carry on playing in the background while the action continues. For the AY sound module to work we need to set this up before hand.\r\n\r\n# Example 1 \r\n\r\nTo play music (```.pt3``` files either 3 or 6 channels) and sound effects (```.afb``` AYFX bank files) you will need the following files :\r\n\r\n- Music Player (```ts24000.bin```)\r\n- AYFX Bank    (```.afb```)\r\n- Music File   (```.pt3```)\r\n\r\n**Load block:**\r\nFirst we load the `vt24000.bin` into a memory bank, lets pick bank `33` for this example: \r\n```\r\nLoadSDBank(\"vt24000.bin\",0,0,0,33)\r\n```\r\nLets load a music file into bank `34` and sound fx into bank `36`\r\n```\r\nLoadSDBank(\"shoes.pt3\",0,0,0,34) \r\nLoadSDBank(\"game.afb\",0,0,0,36)\r\n```\r\nThese commands instruct NextBuild to include these files in the final `.`NEX` file. Now we Need to issue some commands to start the music module. It is important to call the commands in correct sequence.\r\n\r\nInitialise the sounds fx bank as `36`:\r\n```\r\nInitSFX(36)\r\n```\r\nInitialise the music, setting the player bank to `33`, point to music bank 34, and an offet into bank `34` of `0 bytes` (this so we can pack more than one song in a bank):\r\n```\r\nInitMusic(33,34,0000)\r\n```\r\nNow setup the interrupt and *enable* SFX and music:\r\n```\r\nSetUpIM()\r\nEnableSFX\r\nEnableMusicstop \r\n```\r\nMusic should start to play, to play a sound effect from the `.afb` bank:\r\n```\r\nPlaySFX(n)\r\n```\r\nTo control audio once playback has started: \r\n\r\n*Disable playback*\r\n```\r\nDisableMusic \r\nDisableSFX \r\n```\r\n*Enable playback*\r\n```\r\nEnableMusic\r\nEnableSFX\r\n```\r\n\r\nA complete example can be found in the [NextBuild_Examples/SOUND/TurboSoundAYFX/SimpleMusic_SFXbas.bas](/NextBuild_Examples/SOUND/TurboSoundAYFX/SimpleMusic_SFXbas.bas)\r\n\r\n# Direct Manipulation \r\n\r\nYou can address each of the AY chips independantly using the classic port values: \r\n```\r\n  ' Select AY chip 1\r\n  out $ffdd, $fd  \r\n  ' AY select register 0-13\r\n  out $ffdd, reg \r\n  out $bffd, value \r\n\r\n  ' Example of making a tone \r\n  \r\n    _ay(0, 34)          ' set tone \r\n    _ay(1, 130)         ' high byte\r\n    _ay(8, 15)          ' set volume \r\n    _ay(7, %00111110)   ' enable channel A tone, disable noise \r\n\r\n    sub _ay(__a as ubyte,__b as ubyte)\r\n        out $fffd, __a \r\n        out $bffd, __b \r\n    end sub \r\n\r\n   do : loop            ' loop forever\r\n```\r\nEach channel can be controlled using the following `registers`:\r\n\r\n| Register | Function |\r\n|:--------:|:---------|\r\n| 0        | Channel A Fine Tune |\r\n| 1        | Channel A Coarse Tune (4 bits) |\r\n| 2        | Channel B Fine Tune |\r\n| 3        | Channel B Coarse Tune (4 bits) |\r\n| 4        | Channel C Fine Tune |\r\n| 5        | Channel C Coarse Tune (4 bits) |\r\n| 6        | Noise Period (5 bits) |\r\n| 7        | Tone enable flags.<br>Bits 0 – 2 enable tone on channels A, B, C respectively (inverted: 0 = enabled).<br>Bits 3 – 5 enable noise on A, B, C (inverted similarly). |\r\n| 8        | Channel A amplitude.<br>Bits 0 – 3 set fixed amplitude if bit 4 = 0. If bit 4 = 1, the envelope generator is used instead (bits 0 – 3 ignored). |\r\n| 9        | Channel B amplitude, same as above. |\r\n| 10       | Channel C amplitude, same as above. |\r\n| 11       | Envelope period fine. |\r\n| 12       | Envelope period coarse. |\r\n| 13       | Envelope shape bits:<br>- **Bit 0 “Hold”**: 1 = one cycle then hold end value; 0 = continuous cycles.<br>- **Bit 1 “Alternate”**: 1 = alternate direction each cycle; 0 = reset each cycle. If Hold=1, chooses whether to hold final (0) or initial (1) value.<br>- **Bit 2 “Attack”**: 1 = count up; 0 = count down.<br>- **Bit 3 “Continue”**: 1 = follow Hold; 0 = perform one cycle then drop amplitude to 0 (overrides Hold). |\r\n\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_COPPER": {
    "content": "## Copper\r\n\r\nCOPPER examples have yet to be written. For now refer to [https://wiki.specnext.dev/Copper](https://wiki.specnext.dev/Copper)\r\n\r\n\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_DMA": {
    "content": "## DMA\r\n\r\nDMA examples have yet to be written. For now refer to [https://wiki.specnext.dev/DMA](https://wiki.specnext.dev/DMA)\r\n\r\n\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_EXAMPLES": {
    "content": "## Examples \r\n\r\nHave a good idea for an example? Please [submit an issue](https://github.com/nextbuild-viewers/issues)\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_FILEIO": {
    "content": "## File IO\r\n\r\n### File Management\r\n\r\nNextBuild Studio supports the following file management commands:\r\n\r\n- `LoadSDBank` - Load a file into a bank\r\n- `LoadSD` - Load a file into RAM \r\n- `SaveSD` - Save a file from RAM\r\n\r\n### LoadSDBank\r\n\r\n```nextbuild\r\nLoadSDBank(filename as string, address as uinteger, length as uinteger, offset as ulong, bank as ubyte)\r\n``` \r\n\r\n`LoadSDBank` is used to load a file into a bank. It is a special commands because wheen used with the precompiler directive `#define NEX` changes the way the file is loaded into the bank.\r\n\r\nNextBuild Studio will scan the main source file for `LoadSDBank` and construct a list of files to be included in the final `.nex` file. These will be included inside the `nex` and the files will not need to loaded into the bank at runtime. The `LoadSDBank` code will then be turned into an empty function.\r\n\r\n`LoadSD` and `SaveSD` are used to load and save files from the SD card. \r\n\r\n### LoadSD \r\n\r\n```nextbuild\r\nLoadSD(filename as string, address as uinteger, length as uinteger, offset as ulong)\r\n```\r\n\r\n### SaveSD\r\n\r\n```nextbuild\r\nSaveSD(filename as string, address as uinteger, length as uinteger)\r\n```\r\n\r\n## Example 1 - Loading a file into a bank\r\n```nextbuild\r\n    ' load 1024 bytes from the start of the file \"myfile.txt\" at address $c000\r\n    LoadSD(\"myfile.txt\", $c000, 1024, 0)\r\n\r\n    ' save 1024 bytes from address $c000 to the file \"myfile.txt\"\r\n    SaveSD(\"myfile.txt\", $c000, 1024)\r\n```\r\n\r\n## Example 2 - Loading a file into a bank\r\n```nextbuild\r\n    ' tell NextBuild to include your file in the final .nex file\r\n    #define NEX\r\n    ' Specify the file to include\r\n    ' load 1024 bytes from the start of the file \"myfile.txt\" at address $c000\r\n    LoadSDBank(\"myfile.txt\", $c000, 1024, 0, 32)\r\n```\r\n\r\nIf you omit the `#define NEX` directive, the file will be loaded into the bank at runtime. This will affect all the ``LoadSDBank`` commands in the project.\r\n\r\n## Related Functions\r\n\r\n - [LoadSDBank](LoadSDBank.md)\r\n - [LoadSD](LoadSD.md)\r\n - [SaveSD](SaveSD.md)\r\n\r\n[Index](index.md)",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_GRAPHICS": {
    "content": "# Graphics \r\n\r\nGraphics can be broken down into cetgories:\r\n\r\n| Graphics Type | Description |\r\n|---------------|-------------|\r\n| [Layer 2](_layer2.md) | 256x192, 320x256, 640x256 resolutions |\r\n| [Sprites](_sprites.md) | Hardware-accelerated sprite system |\r\n| [TileMaps](_tilemaps.md) | Tile-based graphics system |\r\n| [Palettes](_palettes.md) | Color palette management |\r\n\r\nOther systems that can affect Graphics :\r\n\r\n| |  |\r\n|---------------|:-------------------------|\r\n| [DMA](_DMA.md) | Direct Memory Access for fast data transfers |\r\n| [COPPER](_COPPER.md) | Hardware-accelerated display list processor |\r\n\r\n## Remarks\r\n\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_INPUT": {
    "content": "## Input \r\n\r\nThere are vairous ways to handle input in NextBuild. \r\n\r\n### Keyboard\r\n\r\n### Example\r\n\r\n```nextbuild\r\n#include <keys.bas>\r\ndim i as ubyte \r\n\r\ndo \r\n    ' detect keybaord P \r\n    if GetKeyScanCode()=KEYP\r\n        print ink 7;at 0,0;\"p is pressed\" \r\n        i = 7\r\n    end if \r\n\r\n    if i > 0 \r\n        i = i - 1 \r\n        print at 0,0; over 1; ink i;\"                \"       \r\n    endif \r\n\r\n    WaitRaster(192) \r\n\r\nloop \r\n```\r\n\r\nTo detect multiple keys you will use ``MultiKeys`` : \r\n\r\n```\r\n\r\ndo \r\n    ' detect keybaord P \r\n    if MultiKeys(KEYP) & Multikeys(KEYSPACE)\r\n        print ink 7;at 0,0;\"keys are pressed\" \r\n        i = 7\r\n    end if \r\n\r\n    if i > 0 \r\n        i = i - 1 \r\n        print at 0,0; over 1; ink i;\"                \"       \r\n    endif \r\n\r\n    WaitRaster(192) \r\n\r\nloop \r\n```\r\nThe codes for each key are defined in the ``keys.bas`` file. \r\n\r\n``KEYA-KEYZ`` ``KEY0-KEY9`` ``KEYSPACE`` ``KEYENTER`` ``KEYSYMBOL`` ``KEYCAPS``\r\n\r\n### Joystick \r\n\r\n```nextbuild\r\ndim j as ubyte \r\ndim i as ubyte \r\ndo \r\n    ' port 31 if kempston 1, 51 kempston 2\r\n    j = in 31           ' Kempston 1\r\n    ' up and down \r\n    if j band BIT_UP\r\n        print at 0,0; \"up\"\r\n    elseif j band BIT_DOWN\r\n        print at 0,0; \"down\"\r\n    endif \r\n    ' left and right \r\n    if j band BIT_LEFT\r\n        print at 0,0; \"left\"\r\n    elseif j band BIT_RIGHT \r\n        print at 0,0; \"right\"\r\n    endif \r\n    ' fade the ink \r\n    if i > 0 \r\n        i = i - 1 \r\n        print at 0,0; over 1; ink i;\"                \"       \r\n    endif \r\n    WaitRaster(192) \r\nloop\r\n```\r\nThe joystick bit is bitmapped as follows : \r\n\r\n| Bit | Kempston joystick | MD controller |\r\n|-----|-------------------|---------------|\r\n| 7   | 0                 | start button  |\r\n| 6   | 0                 | A button      |\r\n| 5   | Fire 2            | C button      |\r\n| 4   | Fire 1            | B button      |\r\n| 3   | up                | up            |\r\n| 2   | down              | down          |\r\n| 1   | left              | left          |\r\n| 0   | right             | right         |\r\n\r\nFor all bits: **0** = not pressed / **1** = pressed \r\n\r\n## Links\r\n\r\n- [keys.bas](keys.bas)\r\n\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_KEYWORDS": {
    "content": "\nBASIC keywords that are included in the ZX Basic Compiler. Further information can be found in [Indentifers](identifier.md). For ``NextBuild`` commands refer to [NextBuild Commands](_nextbuild.md).\n\n# Keywords\n\n```ABS``` [ABS](abs.md)\n\n```ACS``` [ACS](acs.md)\n\n```AND``` [AND](and.md)\n\n```ASM``` [ASM](asm.md)\n\n```ASN``` [ASN](asn.md)\n\n```AT``` [AT](at.md)\n\n```ATN``` [ATN](atn.md)\n\n```BEEP``` [BEEP](beep.md)\n\n```BOLD``` [BOLD](bold.md)\n\n```BORDER``` [BORDER](border.md)\n\n```BRIGHT``` [BRIGHT](bright.md)\n\n```BYREF``` [BYREF](byref.md)\n\n```BYTE``` [BYTE](byte.md)\n\n```BYVAL``` [BYVAL](byval.md)\n\n```CAST``` [CAST](cast.md)\n\n```CHR``` [CHR](chr.md)\n\n```CIRCLE``` [CIRCLE](circle.md)\n\n```CLS``` [CLS](cls.md)\n\n```CODE``` [CODE](code.md)\n\n```CONST``` [CONST](const.md)\n\n```CONTINUE``` [CONTINUE](continue.md)\n\n```COS``` [COS](cos.md)\n\n```DATA``` [DATA](data.md)\n\n```DECLARE``` [DECLARE](declare.md)\n\n```DEFINE``` [DEFINE](define.md)\n\n```DIM``` [DIM](dim.md)\n\n```DO``` [DO](do.md)\n\n```DRAW``` [DRAW](draw.md)\n\n```ELSE``` [ELSE](else.md)\n\n```END``` [END](end.md)\n\n```ENDIF``` [ENDIF](endif.md)\n\n```END_IF``` [END_IF](end_if.md)\n\n```EXIT``` [EXIT](exit.md)\n\n```EXP``` [EXP](exp.md)\n\n```FASTCALL``` [FASTCALL](fastcall.md)\n\n```FIXED``` [FIXED](fixed.md)\n\n```FLASH``` [FLASH](flash.md)\n\n```FLOAT``` [FLOAT](float.md)\n\n```FOR``` [FOR](for.md)\n\n```FUNCTION``` [FUNCTION](function.md)\n\n```GETSCANCODE``` [GETSCANCODE](getscancode.md)\n\n```GOSUB``` [GOSUB](gosub.md)\n\n```GOTO``` [GOTO](goto.md)\n\n```HELP``` [HELP](help.md)\n\n```IF``` [IF](if.md)\n\n```IN``` [IN](in.md)\n\n```INCLUDE``` [INCLUDE](include.md)\n\n```INK``` [INK](ink.md)\n\n```INKEY``` [INKEY](inkey.md)\n\n```INPUT``` [INPUT](input.md)\n\n```INT``` [INT](int.md)\n\n```INTEGER``` [INTEGER](integer.md)\n\n```INVERSE``` [INVERSE](inverse.md)\n\n```ITALIC``` [ITALIC](italic.md)\n\n```LABELS``` [LABELS](labels.md)\n\n```LBOUND``` [LBOUND](lbound.md)\n\n```LEN``` [LEN](len.md)\n\n```LET``` [LET](let.md)\n\n```LN``` [LN](ln.md)\n\n```LOAD``` [LOAD](load.md)\n\n```LONG``` [LONG](long.md)\n\n```LOOP``` [LOOP](loop.md)\n\n```MOD``` [MOD](mod.md)\n\n```NOT``` [NOT](not.md)\n\n```ON_GOSUB``` [ON_GOSUB](on_gosub.md)\n\n```ON_GOTO``` [ON_GOTO](on_goto.md)\n\n```OR``` [OR](or.md)\n\n```ORG``` [ORG](org.md)\n\n```OUT``` [OUT](out.md)\n\n```OVER``` [OVER](over.md)\n\n```PAPER``` [PAPER](paper.md)\n\n```PAUSE``` [PAUSE](pause.md)\n\n```PEEK``` [PEEK](peek.md)\n\n```PI``` [PI](pi.md)\n\n```PLOT``` [PLOT](plot.md)\n\n```POKE``` [POKE](poke.md)\n\n```PRINT``` [PRINT](print.md)\n\n```RANDOMIZE``` [RANDOMIZE](randomize.md)\n\n```READ``` [READ](read.md)\n\n```REM``` [REM](rem.md)\n\n```RESTORE``` [RESTORE](restore.md)\n\n```RETURN``` [RETURN](return.md)\n\n```RND``` [RND](rnd.md)\n\n```SAVE``` [SAVE](save.md)\n\n```SGN``` [SGN](sgn.md)\n\n```SHL``` [SHL](shl.md)\n\n```SHR``` [SHR](shr.md)\n\n```SIN``` [SIN](sin.md)\n\n```SQR``` [SQR](sqr.md)\n\n```STEP``` [STEP](step.md)\n\n```STOP``` [STOP](stop.md)\n\n```STR``` [STR](str.md)\n\n```SUB``` [SUB](sub.md)\n\n```TAN``` [TAN](tan.md)\n\n```TO``` [TO](to.md)\n\n```TYPES``` [TYPES](types.md)\n\n```UBOUND``` [UBOUND](ubound.md)\n\n```UBYTE``` [UBYTE](ubyte.md)\n\n```UINTEGER``` [UINTEGER](uinteger.md)\n\n```ULONG``` [ULONG](ulong.md)\n\n```UNTIL``` [UNTIL](until.md)\n\n```USR``` [USR](usr.md)\n\n```VAL``` [VAL](val.md)\n\n```WEND``` [WEND](wend.md)\n\n```WHILE``` [WHILE](while.md)\n\n```XOR``` [XOR](xor.md)\n\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_LAYER2": {
    "content": "# Layer 2 Graphics\r\n\r\nLayer 2 provides an additional high-resolution graphics layer that can display **256×192** or **320×256** pixels with **256 colors** each. This layer can appear above, below, or instead of the normal ULA screen.\r\n\r\nLayer 2 is perfect for detailed graphics, smooth scrolling, and modern game visuals while keeping the classic Spectrum feel.\r\n\r\n## Screen Modes\r\n\r\n| Mode | Resolution | Colors | Memory |\r\n|------|------------|--------|--------|\r\n| Standard | 256×192 | 256 | 48KB (3 banks) |\r\n| Extended | 320×256 | 256 | 80KB (5 banks) |\r\n| High-res | 640×256 | 16 | 80KB (5 banks) |\r\n\r\n## Basic Setup\r\n\r\n**Enable Layer 2:**\r\n```basic\r\n' Enable Layer 2 for writing and set to 256x192 mode\r\nInitLayer2(MODE256X192)\r\n' Enable Layer 2 for writing and set to 320x256 mode\r\nInitLayer2(MODE320X256)\r\n' Enable Layer 2 for writing and set to 640x256 mode\r\nInitLayer2(MODE640X256)\r\n```\r\n\r\n**Clear the screen:**\r\n```basic\r\n' Clear Layer 2 to black (color 0)\r\nClearLayer2(0)\r\n```\r\n\r\n## Drawing Pixels\r\n\r\nIn **256×192 mode**, pixels are stored in reading order (left to right, top to bottom):\r\n\r\n```basic\r\n' Example: Draw a red line\r\nfor x = 0 to 100\r\n    PlotL2(x, 50, 255)  ' Color 255 = white\r\nnext x\r\n```\r\n\r\n## Quick Example\r\n\r\nHere's a complete example that sets up Layer 2 and draws some graphics:\r\n\r\n```basic\r\n' Setup Layer 2\r\nInitLayer2(MODE256X192)\r\nClearLayer2(0)  ' Clear to black\r\n\r\n' Draw some colored squares\r\nfor i = 0 to 15\r\n    FillRect(i * 16, i * 8, 16, 16, i + 1)\r\nnext i\r\n\r\n' Show the layer\r\nShowLayer2(TRUE)\r\n\r\ndo : loop  ' Keep running\r\n\r\nsub FillRect(x as ubyte, y as ubyte, w as ubyte, h as ubyte, color as ubyte)\r\n    for py = y to y + h - 1\r\n        for px = x to x + w - 1\r\n            PlotL2(px, py, color)\r\n        next px\r\n    next py\r\nend sub\r\n\r\n```\r\n\r\n## Scrolling\r\n\r\nLayer 2 supports hardware scrolling for smooth movement:\r\n\r\n```basic\r\n' Scroll horizontally\r\nNextReg(LAYER2_X_OFFSET_NR_16, offset_x)      ' X offset (0-255)\r\nNextReg(LAYER2_X_OFFSET_MSB_NR_71, offset_x_msb)  ' X offset high bit\r\n\r\n' Scroll vertically  \r\nNextReg(LAYER2_Y_OFFSET_NR_17, offset_y)      ' Y offset (0-255)\r\n\r\n' Example: Smooth horizontal scroll\r\nfor scroll = 0 to 255\r\n    NextReg(LAYER2_X_OFFSET_NR_16, scroll)\r\n    WaitRaster()  ' Wait for next frame\r\nnext scroll\r\n```\r\n\r\n## Layer Priority\r\n\r\nControl which layer appears on top:\r\n\r\n```basic\r\n' Layer 2 above ULA\r\nNextReg(SPRITE_CONTROL_NR_15, %000_000_10)\r\n\r\n' Layer 2 below ULA \r\nNextReg(SPRITE_CONTROL_NR_15, %000_010_00)\r\n\r\n' Layer 2 instead of ULA, sprites enable & over border  \r\nNextReg(SPRITE_CONTROL_NR_15, %000_000_11)\r\n```\r\n\r\n## Palette\r\n\r\nLayer 2 uses a 256-color palette that you can customize:\r\n\r\n```basic\r\n' Set palette color (0-255)\r\nsub SetPaletteColor(index as ubyte, r as ubyte, g as ubyte, b as ubyte)\r\n    dim c as ubyte \r\n    dim rr, gg, bb as ubyte \r\n    NextRegA(PALETTE_INDEX_NR_40, index)           ' Select palette index\r\n    NextReg(PALETTE_CONTROL_NR_41, %00000000)       ' Layer 2 palette\r\n    rr = r << 5\r\n    gg=  g & $1f \r\n    bb=  b & $1f \r\n    ' rrrgggbb \r\n    c = r or g or b \r\n    NextRegA(PALETTE_VALUE_NR_41 c)               ' \r\nend sub\r\n\r\n' Example: Set color 1 to bright red\r\nSetPaletteColor(1, 255, 0, 0)\r\n```\r\n\r\n## Memory Layout\r\n\r\nOn a default Spectrum 128k, the Layer 2 memory is mapped to banks 9-11.\r\n\r\n- **Banks 9-11** are used by default for 256×192 mode\r\n- Each bank holds 64 lines of graphics\r\n- **Bank 9**: Lines 0-63\r\n- **Bank 10**: Lines 64-127  \r\n- **Bank 11**: Lines 128-191\r\n\r\n## Tips\r\n\r\n- Always clear Layer 2 before drawing - it contains random data at startup\r\n- Layer 2 pixels are in simple x,y order - no interlacing like ULA\r\n- You can double-buffer by switching between different bank sets\r\n- Avoid using banks 5, 7, and 8 for Layer 2 unless you know what you're doing\r\n\r\n## Links\r\n\r\n- [InitLayer2](InitLayer2.md)\r\n- [ClearLayer2](ClearLayer2.md)\r\n- [PlotL2](PlotL2.md)\r\n- [InitPalette](InitPalette.md)\r\n\r\nA complete example can be found in [NextBuild_Examples/Layer2Demo/main.bas](/NextBuild_Examples/Layer2Demo/main.bas) ",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_PALETTES": {
    "content": "## Palettes\r\n\r\nPalettes examples have yet to be written. For now refer to [https://wiki.specnext.dev/Palettes](https://wiki.specnext.dev/Palettes)\r\n\r\n\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_PORTS": {
    "content": "# Mapped Spectrum Ports\r\n\r\n## A Note on Partial Decoding\r\n\r\nMost Spectrum peripherals did not actually decode all 16 bits of the address bus; they checked only for certain bits, and would respond if those bit values were set correctly, regardless of the other bits. The \"bitmask\" column for each port shows the bits that are tested for by the device. Traditionally all \"unused\" bits are set to 1 to avoid conflicts with other devices, which is the basis of the given port numbers; but alternate port numbers may be used in some cases. However, beware of creating clashes: in particular any port which does not intend to access the ULA should have the LSB set, as the ULA checks only for a reset LSB.\r\n\r\nIt is not known if the Next's built-in devices will have this decoding restriction, but it seems a safe presumption that they will not except where needed by legacy code.\r\n\r\nOn the other hand, partial decoding can allow use of the multiple output opcodes such as OTIR, which normally places the loop counter on the top half of the address bus - thus making it useless except for devices which ignore this top half. This is the reason why some of the Next registers do ignore the top half of the port address.\r\n\r\n## Port Reference Table\r\n\r\n| Port | Hex | Dec | Mask | Description |\r\n|------|-----|-----|------|-------------|\r\n| [Keyboard](keyboard.md) | $**FE | 254 | %xxxx xxxx ---- ---0 where only one bit in x is 0 | Series of specific ports that read keyboard key presses. |\r\n| [I2C Clock](i2c_clock.md) | $103B | 4155 | %0001 0000 0011 1011 ?? | Sets and reads the I2C SCL line. |\r\n| [I2C Data](i2c_data.md) | $113B | 4411 | %0001 0001 0011 1011 ?? | Sets and reads the I2C SDA line |\r\n| [Layer 2 Access Port](layer_2_access_port.md) | $123B | 4667 | %0001 0010 0011 1011 ?? | Enables Layer 2 and controls paging of layer 2 screen into lower memory. |\r\n| [UART TX](uart_tx.md) | $133B | 4923 | %0001 0011 0011 1011 | Sends byte to serial port. If read, tells if data in RX buffer |\r\n| [UART RX](uart_rx.md) | $143B | 5179 | %0001 0100 0011 1011 | Reads data from serial port, write sets the baudrate |\r\n| [UART Control](uart_control.md) | $153B | 5435 | %0001 0101 0011 1011 | Configuration of UART interfaces |\r\n| [UART Frame](uart_frame.md) | $163B | 5691 | %0001 0110 0011 1011 | UART Frame |\r\n| [CTC Channels](ctc_channels.md) | $183B | 6203 | %0001 1XXX 0011 1011 | CTC 8 channels 0x183b - 0x1f3b |\r\n| [Plus 3 Memory Paging Control](plus_3_memory_paging_control.md) | $1FFD | 8189 | %0001 ---- ---- --0- | Controls ROM paging and special paging options from the +2a/+3. |\r\n| [TBBlue Register Select](tbblue_register_select.md) | $243B | 9275 | %0010 0100 0011 1011 | Selects active port for TBBlue/Next feature configuration. |\r\n| [TBBlue Register Access](tbblue_register_access.md) | $253B | 9531 | %0010 0101 0011 1011 | Reads and/or writes the selected TBBlue control register. |\r\n| [Sprite Status/Slot Select](sprite_status_slot_select.md) | $303B | 12347 | %0011 0000 0011 1011 ?? | Sets active sprite-attribute index and pattern-slot index, reads sprite status. |\r\n| [Memory Paging Control](memory_paging_control.md) | $7FFD | 32765 | %01-- ---- ---- --0- | Selects active RAM, ROM, and displayed screen. |\r\n| [AY Info](ay_info.md) | $BFF5 | 49141 | 1011111111110101 | AY information |\r\n| [Sound Chip Register Write](sound_chip_register_write.md) | $BFFD | 49149 | %10-- ---- ---- --0- | Writes to the selected register of the selected sound chip. |\r\n| [Next Memory Bank Select](next_memory_bank_select.md) | $DFFD | 57341 | %1101 1111 1111 1101 | Provides additional bank select bits for extended memory. |\r\n| [DIVMMC](divmmc.md) | $E3 | 227 |  | Divmmc control |\r\n| [Pentagon 1024 Paging](pentagon_1024_paging.md) | $EFF7 | 61431 | 1110111111110111 | Paging in Pentagon 1024K mode |\r\n| [Kempston Mouse Buttons](kempston_mouse_buttons.md) | $FADF | 64223 | %---- ---0 --0- ---- | Reads buttons on Kempston Mouse. |\r\n| [Kempston Mouse X](kempston_mouse_x.md) | $FBDF | 64479 | %---- -0-1 --0- ---- | X coordinate of Kempston Mouse, 0-255. |\r\n| [Kempston Mouse Y](kempston_mouse_y.md) | $FFDF | 65503 | %---- -1-1 --0- ---- | Y coordinate of Kempston Mouse, 0-255. |\r\n| [Turbo Sound Next Control](turbo_sound_next_control.md) | $FFFD | 65533 | %11-- ---- ---- --0- | Controls stereo channels and selects active sound chip and sound chip channel. |\r\n| [MB02 DMA Port](mb02_dma_port.md) | $xx0B | 11 | ---- ---- 0000 1011 | Controls Z8410 DMA chip via MB02 standard. |\r\n| [Kempston Joystick](kempston_joystick.md) | $xx1F | 31 | %---- ---- 0001 1111 | Reads movement of joysticks using Kempston interface. |\r\n| [Kempston Joystick 2, Joystick I/O](kempston_joystick_2_joystick_io.md) | $xx37 | 55 |  | Kempston interface second joystick variant and controls joystick I/O. |\r\n| [Sprite Attribute Upload](sprite_attribute_upload.md) | $xx57 | 87 | %---- ---- 0101 0111 | Uploads sprite positions, visibility, colour type and effect flags. |\r\n| [Sprite Pattern Upload](sprite_pattern_upload.md) | $xx5B | 91 | %---- ---- 0101 1011 ?? | Used to upload the pattern of the selected sprite. |\r\n| [Datagear DMA Port](datagear_dma_port.md) | $xx6B | 107 | ---- ---- 0110 1011 | Controls zxnDMA chip |\r\n| [SpecDrum DAC Output](specdrum_dac_output.md) | $xxDF | 223 | %---- ---- --01 1111 | Output to SpecDrum DAC. |\r\n| [ULA Control Port](ula_control_port.md) | $xxFE | 254 |  | Controls border color and base Spectrum audio settings. |\r\n| [Timex Sinclair Video Mode Control](timex_sinclair_video_mode_control.md) | $xxFF | 255 |  | Controls Timex Sinclair video modes and colours in hi-res mode. |\r\n\r\n## Port Decoding Guidelines\r\n\r\n### Key Points:\r\n- **ULA Access**: Ports with LSB = 0 access the ULA\r\n- **Non-ULA Access**: Should have LSB = 1 to avoid ULA conflicts\r\n- **Partial Decoding**: Many devices only check specific address bits\r\n- **OTIR Compatibility**: Some Next registers ignore high address bits\r\n- **Bitmask**: Shows which address bits are actually decoded by each device\r\n\r\n### Legacy Compatibility:\r\n- Next maintains compatibility with original Spectrum port decoding\r\n- Built-in Next devices may have full address decoding except where legacy compatibility is required",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_QUICKREFERENCE": {
    "content": "# NextBuild Quick Reference\r\n\r\nThis is a reference-only page that will appear in the help system but not in hover help or autocomplete.\r\n\r\n## Syntax Quick Reference\r\n\r\n### Control Structures\r\n```nextbuild\r\nIF condition THEN\r\n    statements\r\nELSEIF condition THEN\r\n    statements\r\nELSE\r\n    statements\r\nEND IF\r\n\r\nFOR i = start TO end [STEP step]\r\n    statements\r\nNEXT [i]\r\n\r\nDO [WHILE|UNTIL condition]\r\n    statements\r\nLOOP [WHILE|UNTIL condition]\r\n\r\nWHILE condition\r\n    statements\r\nWEND\r\n\r\n```\r\n\r\n### Common NextBuild Commands\r\n\r\n#### Graphics\r\n- `InitLayer2(MODE256X192)` - Initialize Layer 2 graphics\r\n- `ShowLayer2(visible)` - Show/hide Layer 2\r\n- `PlotL2(x, y, color)` - Plot a pixel on Layer 2\r\n- `InitSprites2(number of sprites, address ,bank)` - Initialize sprites from a bank \r\n- `UpdateSprite(x, y, pattern, frame, rot, mirror)` - Draw sprite see [Sprites](sprites.md)\r\n\r\n#### Input/Output\r\n- `WaitKey()` - Wait for key press\r\n- `Inkey$()` - Get current key press as string\r\n- `Print \"text\"` - Output text to screen\r\n- `NextReg(r, v)` - Write to Next register\r\n\r\n#### File Operations\r\n- `LoadSDBank(filename, bank)` - Load file to RAM bank\r\n- `SaveSDBank(filename, bank, length)` - Save RAM bank to file\r\n\r\n### Useful Constants\r\n- `TRUE` = -1\r\n- `FALSE` = 0\r\n- `NULL` = 0\r\n- `PI` = 3.14159265359\r\n\r\n[Back to Index](index.md#welcome-to-nextbuild) ",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_REGISTERS": {
    "content": "# Registers\r\n\r\n## Hardware Registers\r\n\r\n| Register | Name                 Description                                     |\r\n|---------|:----------------------------------------------------------------------|\r\n| $00 | [MACHINE_ID_NR_00](MACHINE_ID_NR_00.md) - Identifies TBBlue board type. Should always be 10 (binary 0000 1010) on Next.|\r\n| $01 | [NEXT_VERSION_NR_01](NEXT_VERSION_NR_01.md) - Identifies core (FPGA image) version.|\r\n| $02 | [NEXT_RESET_NR_02](NEXT_RESET_NR_02.md) - Identifies type of last reset. Can be written to force reset.|\r\n| $03 | [MACHINE_TYPE_NR_03](MACHINE_TYPE_NR_03.md) - Identifies timing and machine type.|\r\n| $04 | [ROM_MAPPING_NR_04](ROM_MAPPING_NR_04.md) - In config mode, allows RAM to be mapped to ROM area.|\r\n| $05 | [PERIPHERAL_1_NR_05](PERIPHERAL_1_NR_05.md) - Sets joystick mode, video frequency and Scandoubler.|\r\n| $06 | [PERIPHERAL_2_NR_06](PERIPHERAL_2_NR_06.md) - Enables CPU Speed key, DivMMC, Multiface, Mouse and AY audio.|\r\n| $07 | [TURBO_CONTROL_NR_07](TURBO_CONTROL_NR_07.md) - Sets CPU Speed, reads actual speed.|\r\n| $08 | [PERIPHERAL_3_NR_08](PERIPHERAL_3_NR_08.md) - ABC/ACB Stereo, Internal Speaker, SpecDrum, Timex Video Modes, Turbo Sound Next, RAM contention and [un]lock 128k paging.|\r\n| $09 | [PERIPHERAL_4_NR_09](PERIPHERAL_4_NR_09.md) - Sets scanlines, AY mono output, Sprite-id lockstep, reset DivMMC mapram and disable HDMI audio.|\r\n| $0A | [PERIPHERAL_5_NR_0A](PERIPHERAL_5_NR_0A.md) - Multiface type, Divmmc automap, Mouse buttons and DPI config.|\r\n| $0B | [JOYSTICK_I_O_MODE_NR_0B](JOYSTICK_I_O_MODE_NR_0B.md) - Joystick port I/O control.|\r\n| $0E | [NEXT_VERSION_MINOR_NR_0E](NEXT_VERSION_MINOR_NR_0E.md) - Identifies core (FPGA image) version (sub minor number).|\r\n| $0F | [BOARD_ID_NR_0F](BOARD_ID_NR_0F.md) - Spectrum next issue ID.|\r\n| $10 | [ANTI_BRICK_NR_10](ANTI_BRICK_NR_10.md) - Used within the Anti-brick system.|\r\n| $11 | [VIDEO_TIMING_NR_11](VIDEO_TIMING_NR_11.md) - Sets video output timing variant.|\r\n| $12 | [LAYER2_RAM_BANK_NR_12](LAYER2_RAM_BANK_NR_12.md) - Sets the bank number where Layer 2 video memory begins.|\r\n| $13 | [LAYER2_RAM_SHADOW_BANK_NR_13](LAYER2_RAM_SHADOW_BANK_NR_13.md) - Sets the bank number where the Layer 2 shadow screen begins.|\r\n| $14 | [GLOBAL_TRANSPARENCY_NR_14](GLOBAL_TRANSPARENCY_NR_14.md) - Sets the \"transparent\" colour for Layer 2, ULA and LoRes pixel data.|\r\n| $15 | [SPRITE_CONTROL_NR_15](SPRITE_CONTROL_NR_15.md) - Enables/disables Sprites and Lores Layer, and chooses priority of sprites and Layer 2.|\r\n| $16 | [LAYER2_XOFFSET_NR_16](LAYER2_XOFFSET_NR_16.md) - Sets the pixel offset used for drawing Layer 2 graphics on the screen.|\r\n| $17 | [LAYER2_YOFFSET_NR_17](LAYER2_YOFFSET_NR_17.md) - Sets the Y offset used when drawing Layer 2 graphics on the screen.|\r\n| $18 | [CLIP_LAYER2_NR_18](CLIP_LAYER2_NR_18.md) - Sets and reads clip-window for Layer 2.|\r\n| $19 | [CLIP_SPRITE_NR_19](CLIP_SPRITE_NR_19.md) - Sets and reads clip-window for Sprites.|\r\n| $1A | [CLIP_ULA_LORES_NR_1A](CLIP_ULA_LORES_NR_1A.md) - Sets and reads clip-window for ULA/LoRes layer.|\r\n| $1B | [CLIP_TILEMAP_NR_1B](CLIP_TILEMAP_NR_1B.md) - Sets and reads clip-window for Tilemap.|\r\n| $1C | [CLIP_WINDOW_CONTROL_NR_1C](CLIP_WINDOW_CONTROL_NR_1C.md) - Controls (resets) the clip-window registers indices.|\r\n| $1E | [VIDEO_LINE_MSB_NR_1E](VIDEO_LINE_MSB_NR_1E.md) - Holds the MSB (only, as bit 0) of the raster line currently being drawn.|\r\n| $1F | [VIDEO_LINE_LSB_NR_1F](VIDEO_LINE_LSB_NR_1F.md) - Holds the eight LSBs of the raster line currently being drawn.|\r\n| $20 | [GENERATE_MASKABLE_INTERRUPT_NR_20](GENERATE_MASKABLE_INTERRUPT_NR_20.md) - Trigger interrupt.|\r\n| $22 | [VIDEO_INTERUPT_CONTROL_NR_22](VIDEO_INTERUPT_CONTROL_NR_22.md) - Controls the timing of raster interrupts and the ULA frame interrupt.|\r\n| $23 | [VIDEO_INTERUPT_VALUE_NR_23](VIDEO_INTERUPT_VALUE_NR_23.md) - Holds the eight LSBs of the line on which a raster interrupt should occur.|\r\n| $24 | [RESERVED_NR_24](RESERVED_NR_24.md) - n/a.|\r\n| $26 | [ULA_XOFFSET_NR_26](ULA_XOFFSET_NR_26.md) - Pixel X offset (0..255) to use when drawing ULA Layer.|\r\n| $27 | [ULA_YOFFSET_NR_27](ULA_YOFFSET_NR_27.md) - Pixel Y offset (0..191) to use when drawing ULA Layer.|\r\n| $28 | [HIGH_ADRESS_KEYMAP_NR_28](HIGH_ADRESS_KEYMAP_NR_28.md) - PS/2 Keymap address MSB, read (pending) first byte of palette colour.|\r\n| $29 | [LOW_ADRESS_KEYMAP_NR_29](LOW_ADRESS_KEYMAP_NR_29.md) - PS/2 Keymap address LSB.|\r\n| $2A | [HIGH_DATA_TO_KEYMAP_NR_2A](HIGH_DATA_TO_KEYMAP_NR_2A.md) - High data to PS/2 Keymap (MSB of data in bit 0).|\r\n| $2B | [LOW_DATA_TO_KEYMAP_NR_2B](LOW_DATA_TO_KEYMAP_NR_2B.md) - Low eight LSBs of PS/2 Keymap data.|\r\n| $2C | [DAC_B_MIRROR_NR_2C](DAC_B_MIRROR_NR_2C.md) - DAC B mirror, read current I2S left MSB.|\r\n| $2D | [DAC_AD_MIRROR_NR_2D](DAC_AD_MIRROR_NR_2D.md) - SpecDrum port 0xDF / DAC A+D mirror, read current I2S LSB.|\r\n| $2E | [DAC_C_MIRROR_NR_2E](DAC_C_MIRROR_NR_2E.md) - DAC C mirror, read current I2S right MSB.|\r\n| $2F | [TILEMAP_XOFFSET_MSB_NR_2F](TILEMAP_XOFFSET_MSB_NR_2F.md) - Sets the pixel offset (two high bits) used for drawing Tilemap graphics on the screen.|\r\n| $30 | [TILEMAP_XOFFSET_LSB_NR_30](TILEMAP_XOFFSET_LSB_NR_30.md) - Sets the pixel offset (eight low bits) used for drawing Tilemap graphics on the screen.|\r\n| $31 | [TILEMAP_YOFFSET_NR_31](TILEMAP_YOFFSET_NR_31.md) - Sets the pixel offset used for drawing Tilemap graphics on the screen.|\r\n| $32 | [LORES_XOFFSET_NR_32](LORES_XOFFSET_NR_32.md) - Pixel X offset (0..255) to use when drawing LoRes Layer.|\r\n| $33 | [LORES_YOFFSET_NR_33](LORES_YOFFSET_NR_33.md) - Pixel Y offset (0..191) to use when drawing LoRes Layer.|\r\n| $34 | [SPRITE_ATTR_SLOT_SEL_NR_34](SPRITE_ATTR_SLOT_SEL_NR_34.md) - Selects sprite index 0..127 to be affected by writes to other Sprite ports (and mirrors).|\r\n| $35 | [SPRITE_ATTR0_NR_35](SPRITE_ATTR0_NR_35.md) - Nextreg port-mirror to write directly into \"byte 1\" of Sprite Attribute Upload ($xx57 / 87).|\r\n| $36 | [SPRITE_ATTR1_NR_36](SPRITE_ATTR1_NR_36.md) - Nextreg port-mirror to write directly into \"byte 2\" of Sprite Attribute Upload ($xx57 / 87).|\r\n| $37 | [SPRITE_ATTR2_NR_37](SPRITE_ATTR2_NR_37.md) - Nextreg port-mirror to write directly into \"byte 3\" of Sprite Attribute Upload ($xx57 / 87).|\r\n| $38 | [SPRITE_ATTR3_NR_38](SPRITE_ATTR3_NR_38.md) - Nextreg port-mirror to write directly into \"byte 4\" of Sprite Attribute Upload ($xx57 / 87).|\r\n| $39 | [SPRITE_ATTR4_NR_39](SPRITE_ATTR4_NR_39.md) - Nextreg port-mirror to write directly into \"byte 5\" of Sprite Attribute Upload ($xx57 / 87).|\r\n| $40 | [PALETTE_INDEX_NR_40](PALETTE_INDEX_NR_40.md) - Chooses an palette element (index) to manipulate with.|\r\n| $41 | [PALETTE_VALUE_NR_41](PALETTE_VALUE_NR_41.md) - Use to set/read 8-bit colours of the ULANext palette.|\r\n| $42 | [PALETTE_FORMAT_NR_42](PALETTE_FORMAT_NR_42.md) - Specifies mask to extract ink colour from attribute cell value in ULANext mode.|\r\n| $43 | [PALETTE_CONTROL_NR_43](PALETTE_CONTROL_NR_43.md) - Enables or disables Enhanced ULA interpretation of attribute values and toggles active palette.|\r\n| $44 | [PALETTE_VALUE_9BIT_NR_44](PALETTE_VALUE_9BIT_NR_44.md) - Use to set 9-bit (2-byte) colours of the Enhanced ULA palette, or to read second byte of colour.|\r\n| $4A | [TRANSPARENCY_FALLBACK_COL_NR_4A](TRANSPARENCY_FALLBACK_COL_NR_4A.md) - 8-bit colour to be used when all layers contain transparent pixel.|\r\n| $4B | [SPRITE_TRANSPARENCY_I_NR_4B](SPRITE_TRANSPARENCY_I_NR_4B.md) - Index into sprite palette (of \"transparent\" colour).|\r\n| $4C | [TILEMAP_TRANSPARENCY_I_NR_4C](TILEMAP_TRANSPARENCY_I_NR_4C.md) - Index into Tilemap palette (of \"transparent\" colour).|\r\n| $50 | [MMU0_0000_NR_50](MMU0_0000_NR_50.md) - Selects the 8k-bank stored in 8k-slot 0 (see Memory map).|\r\n| $51 | [MMU1_2000_NR_51](MMU1_2000_NR_51.md) - Selects the 8k-bank stored in 8k-slot 1 (see Memory map).|\r\n| $52 | [MMU2_4000_NR_52](MMU2_4000_NR_52.md) - Selects the 8k-bank stored in 8k-slot 2 (see Memory map).|\r\n| $53 | [MMU3_6000_NR_53](MMU3_6000_NR_53.md) - Selects the 8k-bank stored in 8k-slot 3 (see Memory map).|\r\n| $54 | [MMU4_8000_NR_54](MMU4_8000_NR_54.md) - Selects the 8k-bank stored in 8k-slot 4 (see Memory map).|\r\n| $55 | [MMU5_A000_NR_55](MMU5_A000_NR_55.md) - Selects the 8k-bank stored in 8k-slot 5 (see Memory map).|\r\n| $56 | [MMU6_C000_NR_56](MMU6_C000_NR_56.md) - Selects the 8k-bank stored in 8k-slot 6 (see Memory map).|\r\n| $57 | [MMU7_E000_NR_57](MMU7_E000_NR_57.md) - Selects the 8k-bank stored in 8k-slot 7 (see Memory map).|\r\n| $60 | [COPPER_DATA_NR_60](COPPER_DATA_NR_60.md) - Used to upload code to the Copper.|\r\n| $61 | [COPPER_CONTROL_LO_NR_61](COPPER_CONTROL_LO_NR_61.md) - Holds low byte of Copper control bits.|\r\n| $62 | [COPPER_CONTROL_HI_NR_62](COPPER_CONTROL_HI_NR_62.md) - Holds high byte of Copper control flags.|\r\n| $63 | [COPPER_DATA_16B_NR_63](COPPER_DATA_16B_NR_63.md) - Used to upload code to the Copper.|\r\n| $64 | [VIDEO_LINE_OFFSET_NR_64](VIDEO_LINE_OFFSET_NR_64.md) - Offset numbering of raster lines in copper/interrupt/active register.|\r\n| $68 | [ULA_CONTROL_NR_68](ULA_CONTROL_NR_68.md) - Disable ULA, controls ULA mixing/blending, enable ULA+.|\r\n| $69 | [DISPLAY_CONTROL_NR_69](DISPLAY_CONTROL_NR_69.md) - Layer2, ULA shadow, Timex $FF port.|\r\n| $6A | [LORES_CONTROL_NR_6A](LORES_CONTROL_NR_6A.md) - LoRes Radastan mode.|\r\n| $6B | [TILEMAP_CONTROL_NR_6B](TILEMAP_CONTROL_NR_6B.md) - Controls Tilemap mode.|\r\n| $6C | [TILEMAP_DEFAULT_ATTR_NR_6C](TILEMAP_DEFAULT_ATTR_NR_6C.md) - Default tile attribute for 8-bit only maps.|\r\n| $6E | [TILEMAP_BASE_ADR_NR_6E](TILEMAP_BASE_ADR_NR_6E.md) - Base address of the 40x32 or 80x32 tile map (similar to text-mode of other computers).|\r\n| $6F | [TILEMAP_GFX_ADR_NR_6F](TILEMAP_GFX_ADR_NR_6F.md) - Base address of the tiles' graphics.|\r\n| $70 | [LAYER2_CONTROL_NR_70](LAYER2_CONTROL_NR_70.md) - Layer 2 resolution, palette offset.|\r\n| $71 | [LAYER2_XOFFSET_MSB_NR_71](LAYER2_XOFFSET_MSB_NR_71.md) - Sets the pixel offset used for drawing Layer 2 graphics on the screen.|\r\n| $75 | [SPRITE_ATTR0_INC_NR_75](SPRITE_ATTR0_INC_NR_75.md) - Same as Sprite port-mirror Attribute 0 Register ($35) (write first byte of sprite-attributes), plus increments Sprite port-mirror Index Register ($34).|\r\n| $76 | [SPRITE_ATTR1_INC_NR_76](SPRITE_ATTR1_INC_NR_76.md) - Same as Sprite port-mirror Attribute 1 Register ($36) (write second byte of sprite-attributes), plus increments Sprite port-mirror Index Register ($34).|\r\n| $77 | [SPRITE_ATTR2_INC_NR_77](SPRITE_ATTR2_INC_NR_77.md) - Same as Sprite port-mirror Attribute 2 Register ($37) (write third byte of sprite-attributes), plus increments Sprite port-mirror Index Register ($34).|\r\n| $78 | [SPRITE_ATTR3_INC_NR_78](SPRITE_ATTR3_INC_NR_78.md) - Same as Sprite port-mirror Attribute 3 Register ($38) (write fourth byte of sprite-attributes), plus increments Sprite port-mirror Index Register ($34).|\r\n| $79 | [SPRITE_ATTR4_INC_NR_79](SPRITE_ATTR4_INC_NR_79.md) - Same as Sprite port-mirror Attribute 4 Register ($39) (write fifth byte of sprite-attributes), plus increments Sprite port-mirror Index Register ($34).|\r\n| $7F | [USER_STORAGE_0_NR_7F](USER_STORAGE_0_NR_7F.md) - 8-bit storage for user.|\r\n| $80 | [EXPANSION_BUS_ENABLE_REGISTER_NR_80](EXPANSION_BUS_ENABLE_REGISTER_NR_80.md) - Expansion bus enable/config.|\r\n| $81 | [EXPANSION_BUS_CONTROL_NR_81](EXPANSION_BUS_CONTROL_NR_81.md) - Expansion bus controls.|\r\n| $82 | [INTERNAL_PORT_DECODING_0_NR_82](INTERNAL_PORT_DECODING_0_NR_82.md) - Enabling internal ports decoding.|\r\n| $83 | [INTERNAL_PORT_DECODING_1_NR_83](INTERNAL_PORT_DECODING_1_NR_83.md) - Enabling internal ports decoding.|\r\n| $84 | [INTERNAL_PORT_DECODING_2_NR_84](INTERNAL_PORT_DECODING_2_NR_84.md) - Enabling internal ports decoding.|\r\n| $85 | [INTERNAL_PORT_DECODING_3_NR_85](INTERNAL_PORT_DECODING_3_NR_85.md) - Enabling internal ports decoding.|\r\n| $86 | [EXPANSION_BUS_DECODING_0_NR_86](EXPANSION_BUS_DECODING_0_NR_86.md) - When expansion bus is enabled: Internal ports decoding mask.|\r\n| $87 | [EXPANSION_BUS_DECODING_1_NR_87](EXPANSION_BUS_DECODING_1_NR_87.md) - When expansion bus is enabled: Internal ports decoding mask.|\r\n| $88 | [EXPANSION_BUS_DECODING_2_NR_88](EXPANSION_BUS_DECODING_2_NR_88.md) - When expansion bus is enabled: Internal ports decoding mask.|\r\n| $89 | [EXPANSION_BUS_DECODING_3_NR_89](EXPANSION_BUS_DECODING_3_NR_89.md) - When expansion bus is enabled: Internal ports decoding mask.|\r\n| $8A | [EXPANSION_BUS_PROPAGATE_NR_8A](EXPANSION_BUS_PROPAGATE_NR_8A.md) - Monitoring internal I/O or adding external keyboard.|\r\n| $8C | [ALTERNATE_ROM_NR_8C](ALTERNATE_ROM_NR_8C.md) - Enable alternate ROM or lock 48k ROM.|\r\n| $8E | [ZX_MEM_MAPPING_NR_8E](ZX_MEM_MAPPING_NR_8E.md) - Control classic 128K Spectrum memory mapping.|\r\n| $8F | [MEMORY_MAPPING_MODE_REGISTER_NR_8F](MEMORY_MAPPING_MODE_REGISTER_NR_8F.md) - Select memory mapping mode.|\r\n| $90 | [PI_GPIO_OUT_ENABLE_0_NR_90](PI_GPIO_OUT_ENABLE_0_NR_90.md) - Enables GPIO pins output.|\r\n| $98 | [PI_GPIO_0_NR_98](PI_GPIO_0_NR_98.md) - GPIO pins mapped to Next Register.|\r\n| $A0 | [PI_PERIPHERALS_ENABLE_NR_A0](PI_PERIPHERALS_ENABLE_NR_A0.md) - Enable Pi peripherals: UART, Pi hats, I2C, SPI.|\r\n| $A2 | [PI_I2S_AUDIO_CONTROL_NR_A2](PI_I2S_AUDIO_CONTROL_NR_A2.md) - Pi I2S controls.|\r\n| $A3 | [PI_I2S_CLOCK_DIVIDE_REGISTER_NR_A3](PI_I2S_CLOCK_DIVIDE_REGISTER_NR_A3.md) - Pi I2S clock divide in master mode.|\r\n| $A8 | [ESP_WIFI_GPIO_OUTPUT_NR_A8](ESP_WIFI_GPIO_OUTPUT_NR_A8.md) - ESP WiFi GPIO Output.|\r\n| $A9 | [ESP_WIFI_GPIO_NR_A9](ESP_WIFI_GPIO_NR_A9.md) - ESP WiFi GPIO Read/Write.|\r\n| $B0 | [EXTENDED_KEYS_0_NR_B0](EXTENDED_KEYS_0_NR_B0.md) - Read Next keyboard compound keys separately.|\r\n| $B1 | [EXTENDED_KEYS_1_NR_B1](EXTENDED_KEYS_1_NR_B1.md) - Read Next keyboard compound keys separately.|\r\n| $B2 | [DIVMMC_TRAP_ENABLE_1_REGISTER_NR_B2](DIVMMC_TRAP_ENABLE_1_REGISTER_NR_B2.md) - DivMMC trap configuration.|\r\n| $B2 | [EXTENDED_MD_PAD_BUTTONS_NR_B2](EXTENDED_MD_PAD_BUTTONS_NR_B2.md) - Reading additional buttons on MD pads.|\r\n| $B4 | [DIVMMC_TRAP_ENABLE_2_REGISTER_NR_B4](DIVMMC_TRAP_ENABLE_2_REGISTER_NR_B4.md) - DivMMC trap configuration.|\r\n| $B8 | [DIVMMC_ENTRY_POINTS_0_NR_B8](DIVMMC_ENTRY_POINTS_0_NR_B8.md) - DivMMC automap control.|\r\n| $B9 | [DIVMMC_ENTRY_POINTS_VALID_0_NR_B9](DIVMMC_ENTRY_POINTS_VALID_0_NR_B9.md) - DivMMC entry point validity.|\r\n| $BA | [DIVMMC_ENTRY_POINTS_TIMING_0_NR_BA](DIVMMC_ENTRY_POINTS_TIMING_0_NR_BA.md) - Adjust delay of divmmc mapping.|\r\n| $BB | [DIVMMC_ENTRY_POINTS_1_NR_BB](DIVMMC_ENTRY_POINTS_1_NR_BB.md) - DivMMC automap control.|\r\n| $C0 | [INTERRUPT_CONTROL_NR_C0](INTERRUPT_CONTROL_NR_C0.md) - Interrupt control configuration.|\r\n| $C2 | [NMI_RETURN_ADDRESS_LSB_REGISTER_NR_C2](NMI_RETURN_ADDRESS_LSB_REGISTER_NR_C2.md) - LSB of NMI return address.|\r\n| $C3 | [NMI_RETURN_ADDRESS_MSB_REGISTER_NR_C3](NMI_RETURN_ADDRESS_MSB_REGISTER_NR_C3.md) - MSB of NMI return address.|\r\n| $C4 | [INTERRUPT_ENABLE_0_REGISTER_NR_C4](INTERRUPT_ENABLE_0_REGISTER_NR_C4.md) - Interrupt type enable control.|\r\n| $C5 | [INTERRUPT_ENABLE_1_REGISTER_NR_C5](INTERRUPT_ENABLE_1_REGISTER_NR_C5.md) - ctc interrupt enable control.|\r\n| $C6 | [INTERRUPT_ENABLE_2_REGISTER_NR_C6](INTERRUPT_ENABLE_2_REGISTER_NR_C6.md) - UART interrupt enable control.|\r\n| $C8 | [INTERRUPT_STATUS_0_REGISTER_NR_C8](INTERRUPT_STATUS_0_REGISTER_NR_C8.md) - Has interrupt occurred?.|\r\n| $C9 | [INTERRUPT_STATUS_1_REGISTER_NR_C9](INTERRUPT_STATUS_1_REGISTER_NR_C9.md) - Has ctc interrupt occurred?.|\r\n| $CA | [INTERRUPT_STATUS_2_REGISTER_NR_CA](INTERRUPT_STATUS_2_REGISTER_NR_CA.md) - Has UART interrupt happened?.|\r\n| $CC | [DMA_INTERRUPT_ENABLE_0_NR_CC](DMA_INTERRUPT_ENABLE_0_NR_CC.md) - Interrupts that can override DMA.|\r\n| $CD | [DMA_INTERRUPT_ENABLE_1_NR_CD](DMA_INTERRUPT_ENABLE_1_NR_CD.md) - CTC Interrupts that can override DMA.|\r\n| $CE | [DMA_INTERRUPT_ENABLE_2_NR_CE](DMA_INTERRUPT_ENABLE_2_NR_CE.md) - UART Interrupts that can override DMA.|\r\n| $D8 | [I_O_TRAPS_REGISTER_NR_D8](I_O_TRAPS_REGISTER_NR_D8.md) - experimental.|\r\n| $D9 | [I_O_TRAP_WRITE_REGISTER_NR_D9](I_O_TRAP_WRITE_REGISTER_NR_D9.md) - experimental.|\r\n| $DA | [I_O_TRAP_CAUSE_REGISTER_NR_DA](I_O_TRAP_CAUSE_REGISTER_NR_DA.md) - experimental.|\r\n| $F0 | [XDEV_COMMAND_REGISTER_NR_F0](XDEV_COMMAND_REGISTER_NR_F0.md) - Issue 4 only.|\r\n| $F8 | [XADC_REGISTER_NR_F8](XADC_REGISTER_NR_F8.md) - Issue 4 only.|\r\n| $F9 | [XADC_D0_REGISTER_NR_F9](XADC_D0_REGISTER_NR_F9.md) - Issue 4 only.|\r\n| $FA | [XADC_D1_REGISTER_NR_FA](XADC_D1_REGISTER_NR_FA.md) - Issue 4 only.|\r\n| $FF | [DEBUG_LED_CONTROL_NR_FF](DEBUG_LED_CONTROL_NR_FF.md) - Turns debug LEDs on and off on TBBlue implementations that have them.|\r\n|-----|-------------------------------------------------------------------|\r\n\r\n## Links\r\n\r\n[Index](index.md)",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_RESOURCES": {
    "content": "# Resources\r\n\r\n## Boriel ZX Basic Compiler \r\n- [Main Index](zxb_index.md)\r\n- [Syntax](syntax.md)\r\n\r\n## Dezog\r\n- [DeZog Help](dezog.md)\r\n- [DeZog Online Help](https://github.com/maziac/DeZog/blob/main/documentation/Usage.md)\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  },
  "_TEMPLATES": {
    "content": "# Templates\r\n- [Templates](#templates)\r\n  - [System Assets](#system-assets)\r\n    - [Example](#example)\r\n  - [Project Creator](#project-creator)\r\n    - [Creating a proect](#creating-a-proect)\r\n\r\n## System Assets\r\n\r\nNextBuild now comes with a special operator that allows you to load `stock` data, such as fonts and palettes. The files are stored in the `Scripts/system_data`. The files in this folder will be available to all projects when loaded using the ``[]`` indicator. This identifier is replaced by ``nextbuild.py`` when the program is compiled into a NEX. \r\n\r\n### Example\r\n```\r\nLoadSDBank(\"[]atserix_font.fnt\",0,0,0,34)\r\n```\r\nWill load the assets from ```ROOT/Scripts/System/``` \r\n\r\nSo far the following files are available: \r\n- aterix_font.fnt ([``L2Text``](l2text.md) font)\r\n- mouse.spr (16x16 mouse sprite)\r\n- TESKO.PT3 (6Ch ``pt3`` music file)\r\n\r\n## Project Creator\r\n\r\nNextBuild Studio can create a new project structure from a set of preset templates. These templates will assist building the correct folder structure for ```modules```, which are used for multi binary applications **```The module system are not 100% complete```**\r\n\r\n### Creating a proect \r\n\r\nClick the ```New Project``` Icon on the bottom of the window. The ```Create NextBuild Project``` will open. Fill in the details.\r\n\r\n- ```Project Name``` - Name of your project & folder (avoid spaces!)\r\n\r\n- ```Preject Template``` - Pick from a list, the structure is shown below\r\n\r\n- Ensure the Base Sources direction is correct\r\n\r\n- Click ```Create Project```\r\n\r\nNBS will ask you if you want to open the project, when you click ``OK`` the project will open in the editor. As it will be build from a template - you should be able to ```Compile``` it right away!\r\n",
    "category": "manual",
    "showInKeywordList": false,
    "isManualOnly": true
  }
}