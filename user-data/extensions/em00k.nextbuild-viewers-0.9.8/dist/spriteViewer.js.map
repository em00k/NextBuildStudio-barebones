{"version":3,"file":"spriteViewer.js","mappings":"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","sources":["webpack://nextbuild-viewers/./src/drawingUtils.ts","webpack://nextbuild-viewers/./src/paletteUtils.ts","webpack://nextbuild-viewers/webpack/bootstrap","webpack://nextbuild-viewers/./src/webview/spriteRenderer.js","webpack://nextbuild-viewers/./src/webview/eventHandlers.js","webpack://nextbuild-viewers/./src/webview/spriteViewer.js"],"sourcesContent":["/**\r\n * Utility functions for manipulating 1D pixel arrays representing 2D sprites.\r\n */\r\n\r\n/**\r\n * Flips a sprite vertically (top to bottom).\r\n * @param pixels The 1D array of pixel values.\r\n * @param width The width of the sprite.\r\n * @param height The height of the sprite.\r\n * @returns A new array with the flipped pixel data.\r\n */\r\nexport function flipVertical(pixels: number[], width: number, height: number): number[] {\r\n    const newPixels = new Array(pixels.length);\r\n    for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n            const originalIndex = y * width + x;\r\n            const newIndex = (height - 1 - y) * width + x;\r\n            newPixels[newIndex] = pixels[originalIndex];\r\n        }\r\n    }\r\n    return newPixels;\r\n}\r\n\r\n/**\r\n * Flips a sprite horizontally (left to right).\r\n * @param pixels The 1D array of pixel values.\r\n * @param width The width of the sprite.\r\n * @param height The height of the sprite.\r\n * @returns A new array with the flipped pixel data.\r\n */\r\nexport function flipHorizontal(pixels: number[], width: number, height: number): number[] {\r\n    const newPixels = new Array(pixels.length);\r\n    for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n            const originalIndex = y * width + x;\r\n            const newIndex = y * width + (width - 1 - x);\r\n            newPixels[newIndex] = pixels[originalIndex];\r\n        }\r\n    }\r\n    return newPixels;\r\n}\r\n\r\n/**\r\n * Scrolls a sprite vertically, wrapping pixels around.\r\n * @param pixels The 1D array of pixel values.\r\n * @param width The width of the sprite.\r\n * @param height The height of the sprite.\r\n * @param amount The number of pixels to scroll (positive for down, negative for up).\r\n * @returns A new array with the scrolled pixel data.\r\n */\r\nexport function scrollVertical(pixels: number[], width: number, height: number, amount: number): number[] {\r\n    const newPixels = new Array(pixels.length);\r\n    const actualAmount = amount % height; // Ensure amount is within height bounds\r\n\r\n    for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n            const originalIndex = y * width + x;\r\n            // Calculate new Y with wrapping (handle negative modulo correctly)\r\n            const newY = (y + actualAmount + height) % height; \r\n            const newIndex = newY * width + x;\r\n            newPixels[newIndex] = pixels[originalIndex];\r\n        }\r\n    }\r\n    return newPixels;\r\n}\r\n\r\n/**\r\n * Scrolls a sprite horizontally, wrapping pixels around.\r\n * @param pixels The 1D array of pixel values.\r\n * @param width The width of the sprite.\r\n * @param height The height of the sprite.\r\n * @param amount The number of pixels to scroll (positive for right, negative for left).\r\n * @returns A new array with the scrolled pixel data.\r\n */\r\nexport function scrollHorizontal(pixels: number[], width: number, height: number, amount: number): number[] {\r\n    const newPixels = new Array(pixels.length);\r\n    const actualAmount = amount % width; // Ensure amount is within width bounds\r\n\r\n    for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n            const originalIndex = y * width + x;\r\n            // Calculate new X with wrapping (handle negative modulo correctly)\r\n            const newX = (x + actualAmount + width) % width;\r\n            const newIndex = y * width + newX;\r\n            newPixels[newIndex] = pixels[originalIndex];\r\n        }\r\n    }\r\n    return newPixels;\r\n}\r\n\r\n/**\r\n * Rotates a sprite 90 degrees clockwise.\r\n * Note: This changes the dimensions of the sprite.\r\n * @param pixels The 1D array of pixel values.\r\n * @param width The original width of the sprite.\r\n * @param height The original height of the sprite.\r\n * @returns An object containing the new pixel array, new width, and new height.\r\n */\r\nexport function rotateClockwise(pixels: number[], width: number, height: number): { newPixels: number[], newWidth: number, newHeight: number } {\r\n    const newWidth = height;\r\n    const newHeight = width;\r\n    const newPixels = new Array(width * height);\r\n\r\n    for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n            const originalIndex = y * width + x;\r\n            // New position is (y, width - 1 - x) in the new grid\r\n            const newX = y;\r\n            const newY = width - 1 - x;\r\n            const newIndex = newY * newWidth + newX;\r\n            newPixels[newIndex] = pixels[originalIndex];\r\n        }\r\n    }\r\n    return { newPixels, newWidth, newHeight };\r\n}\r\n\r\n/**\r\n * Rotates a sprite 90 degrees counter-clockwise.\r\n * Note: This changes the dimensions of the sprite.\r\n * @param pixels The 1D array of pixel values.\r\n * @param width The original width of the sprite.\r\n * @param height The original height of the sprite.\r\n * @returns An object containing the new pixel array, new width, and new height.\r\n */\r\nexport function rotateCounterClockwise(pixels: number[], width: number, height: number): { newPixels: number[], newWidth: number, newHeight: number } {\r\n    const newWidth = height;\r\n    const newHeight = width;\r\n    const newPixels = new Array(width * height);\r\n\r\n    for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n            const originalIndex = y * width + x;\r\n            // New position is (height - 1 - y, x) in the new grid\r\n            const newX = height - 1 - y;\r\n            const newY = x;\r\n            const newIndex = newY * newWidth + newX;\r\n            newPixels[newIndex] = pixels[originalIndex];\r\n        }\r\n    }\r\n    return { newPixels, newWidth, newHeight };\r\n}\r\n\r\n/**\r\n * Fills a contiguous area of the same color with a new color.\r\n * Uses a queue-based iterative approach.\r\n * Modifies the input pixel array directly.\r\n * @param pixels The 1D array of pixel values (will be modified).\r\n * @param width The width of the sprite.\r\n * @param height The height of the sprite.\r\n * @param startX The starting X coordinate for the fill.\r\n * @param startY The starting Y coordinate for the fill.\r\n * @param fillColor The new color index to fill with.\r\n * @returns boolean True if any pixels were changed, false otherwise.\r\n */\r\nexport function floodFill(pixels: number[], width: number, height: number, startX: number, startY: number, fillColor: number): boolean {\r\n    const startIndex = startY * width + startX;\r\n\r\n    // Basic bounds check for start point\r\n    if (startX < 0 || startX >= width || startY < 0 || startY >= height || startIndex < 0 || startIndex >= pixels.length) {\r\n        console.error(`[floodFill] Invalid start coordinates (${startX}, ${startY}) for dimensions ${width}x${height}.`);\r\n        return false;\r\n    }\r\n    \r\n    const targetColor = pixels[startIndex];\r\n\r\n    if (targetColor === fillColor) {\r\n        // console.log('[floodFill] Target color is same as fill color.');\r\n        return false; // Nothing to fill\r\n    }\r\n\r\n    const queue: [number, number][] = [[startX, startY]];\r\n    pixels[startIndex] = fillColor; // Fill starting pixel\r\n    let processedPixels = 0;\r\n    const maxProcess = width * height * 2; // Safety limit to prevent infinite loops\r\n    let changed = true; // Already changed the starting pixel\r\n\r\n    while (queue.length > 0) {\r\n        if (processedPixels++ > maxProcess) { // Check safety limit first\r\n            console.error(\"[floodFill] Processed too many pixels, aborting.\");\r\n            return changed; // Return whether pixels were changed before aborting\r\n        }\r\n\r\n        const [cx, cy] = queue.shift()!;\r\n            \r\n        // Check neighbors (Up, Down, Left, Right)\r\n        const neighbors: [number, number][] = [\r\n            [cx, cy - 1], // Up\r\n            [cx, cy + 1], // Down\r\n            [cx - 1, cy], // Left\r\n            [cx + 1, cy]  // Right\r\n        ];\r\n\r\n        for (const [nx, ny] of neighbors) {\r\n            // Check bounds\r\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n                const nIndex = ny * width + nx;\r\n                // Check if neighbor has the target color\r\n                if (pixels[nIndex] === targetColor) {\r\n                    pixels[nIndex] = fillColor; // Fill neighbor\r\n                    queue.push([nx, ny]);       // Add neighbor to queue\r\n                    changed = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // console.log(`[floodFill] Completed. Processed approx ${processedPixels} pixels.`);\r\n    return changed; // Indicate if any pixels were changed\r\n} ","import * as vscode from 'vscode';\r\n\r\n// Default ZX Next palette - 9-bit RGB format (3 bits per component)\r\nconst defaultPaletteRgb: number[][] = [];\r\nfor (let i = 0; i < 256; i++) {\r\n    const r = (i & 0xE0) >> 5;                   // Extract top 3 bits for red\r\n    const g = (i & 0x1C) >> 2;                   // Extract middle 3 bits for green\r\n    const b = ((i & 0x03) << 1) | ((i & 0x03) > 0 ? 1 : 0); // Extract bottom 2 bits for blue, duplicate LSB\r\n    defaultPaletteRgb.push([r, g, b]);\r\n}\r\n\r\nexport const defaultPaletteRGB = defaultPaletteRgb; // Export the raw RGB values\r\n\r\n// --- Constants ---\r\nconst DEFAULT_PALETTE_ENTRIES = 256;\r\nconst BYTES_PER_COLOR_ENTRY = 2; // RRRGGGBB PIIIIIII (P=Priority, I=Ignored/Intensity?)\r\n\r\n// --- Types ---\r\nexport interface Rgb9 {\r\n    r9: number; // 0-7\r\n    g9: number; // 0-7\r\n    b9: number; // 0-7\r\n}\r\n\r\nexport interface PaletteColor {\r\n    hex: string;    // Standard #RRGGBB hex color (quantized to 9-bit)\r\n    priority: boolean; // Priority flag state\r\n}\r\n\r\n// --- Core Conversion Functions ---\r\n\r\n/**\r\n * Converts an RGB9 color object to its 16-bit hardware representation.\r\n * Format: RRRGGGBB PxxxxxxL\r\n */\r\nfunction rgb9To16BitValue(rgb9: Rgb9, priority: boolean): number {\r\n    const rrr = rgb9.r9 & 0b111;         // 3 bits for red (0-7)\r\n    const ggg = rgb9.g9 & 0b111;         // 3 bits for green (0-7)\r\n    const b3bit = rgb9.b9 & 0b111;       // 3 bits for blue (0-7)\r\n\r\n    // Extract components for the RRRGGGBB PxxxxxxL format\r\n    const bb_high = (b3bit >> 1) & 0b11; // Top 2 bits of Blue (B2, B1)\r\n    const b_low = b3bit & 0b1;           // Least significant bit of Blue (B0 or L)\r\n    const p = priority ? 0b1 : 0b0;\r\n\r\n    // Construct the bytes\r\n    const byte1 = (rrr << 5) | (ggg << 2) | bb_high; // RRRGGGBB\r\n    const byte2 = (p << 7) | b_low;                  // P000000L\r\n\r\n    return (byte1 << 8) | byte2;  // Combine into 16-bit value (big-endian)\r\n}\r\n\r\n/**\r\n * Converts a 16-bit hardware palette value to RGB9 and priority.\r\n * Format: RRRGGGBB PxxxxxxL\r\n */\r\nexport function value16BitToRgb9Priority(value: number): { rgb9: Rgb9, priority: boolean } {\r\n    const byte1 = (value >> 8) & 0xFF; // RRRGGGBB\r\n    const byte2 = value & 0xFF;        // PxxxxxxL\r\n\r\n    // Extract components from byte1\r\n    const rrr = (byte1 >> 5) & 0b111;    // Extract top 3 bits (7-5) for red\r\n    const ggg = (byte1 >> 2) & 0b111;    // Extract middle 3 bits (4-2) for green\r\n    const bb_high = byte1 & 0b11;        // Extract bottom 2 bits (1-0) for Blue High (B2, B1)\r\n\r\n    // Extract components from byte2\r\n    const priority = ((byte2 >> 7) & 0b1) === 1; // Extract Priority bit (P)\r\n    const b_low = byte2 & 0b1;                   // Extract Blue LSB (L or B0)\r\n\r\n    // Reconstruct the 3-bit Blue value\r\n    const bbb3bit = (bb_high << 1) | b_low;\r\n\r\n    return { rgb9: { r9: rrr, g9: ggg, b9: bbb3bit }, priority };\r\n}\r\n\r\n// Specific mapping from 3-bit component (0-7) to 8-bit component value\r\nconst rgb3to8Map: number[] = [0x00, 0x24, 0x49, 0x6D, 0x92, 0xB6, 0xDB, 0xFF];\r\n\r\n/**\r\n * Converts 3-bit RGB components (0-7) to a standard hex string (#RRGGBB)\r\n * using the specific ZX Next hardware mapping.\r\n */\r\nexport function rgb9ToHex(r9: number, g9: number, b9: number): string {\r\n    // Ensure inputs are within the valid 0-7 range\r\n    const rClamped = Math.max(0, Math.min(7, Math.round(r9)));\r\n    const gClamped = Math.max(0, Math.min(7, Math.round(g9)));\r\n    const bClamped = Math.max(0, Math.min(7, Math.round(b9)));\r\n\r\n    // Use the lookup table for conversion\r\n    const r = rgb3to8Map[rClamped];\r\n    const g = rgb3to8Map[gClamped];\r\n    const b = rgb3to8Map[bClamped];\r\n\r\n    // Convert to hex and pad\r\n    const rHex = r.toString(16).padStart(2, '0');\r\n    const gHex = g.toString(16).padStart(2, '0');\r\n    const bHex = b.toString(16).padStart(2, '0');\r\n\r\n    return `#${rHex}${gHex}${bHex}`;\r\n}\r\n\r\n/**\r\n * Finds the closest 3-bit value (0-7) for a given 8-bit value (0-255)\r\n * based on the specific ZX Next hardware mapping.\r\n */\r\nfunction findClosest3BitValue(value8bit: number): number {\r\n    let closestValue = 0;\r\n    let minDifference = Infinity;\r\n\r\n    for (let i = 0; i < rgb3to8Map.length; i++) {\r\n        const difference = Math.abs(value8bit - rgb3to8Map[i]);\r\n        if (difference < minDifference) {\r\n            minDifference = difference;\r\n            closestValue = i;\r\n        }\r\n        // If the difference is the same, prefer the lower index (matches hardware?)\r\n        // or stick with the first one found (arbitrary choice)\r\n    }\r\n    return closestValue;\r\n}\r\n\r\n\r\n/**\r\n * Converts a standard hex color string (#RRGGBB) to the nearest RGB9 object\r\n * using the specific ZX Next hardware mapping.\r\n */\r\nexport function hexToRgb9(hexColor: string): Rgb9 {\r\n    const hexClean = hexColor.startsWith('#') ? hexColor.substring(1) : hexColor;\r\n    if (hexClean.length !== 6) { return { r9: 0, g9: 0, b9: 0 }; } // Invalid format\r\n\r\n    const r8 = parseInt(hexClean.substring(0, 2), 16);\r\n    const g8 = parseInt(hexClean.substring(2, 4), 16);\r\n    const b8 = parseInt(hexClean.substring(4, 6), 16);\r\n\r\n    // Find the closest 3-bit value for each component\r\n    const r9 = findClosest3BitValue(r8);\r\n    const g9 = findClosest3BitValue(g8);\r\n    const b9 = findClosest3BitValue(b8);\r\n\r\n    return { r9, g9, b9 };\r\n}\r\n\r\n// --- Palette File Handling ---\r\n\r\n/**\r\n * Generates the standard ZX Next 256-color default palette.\r\n * Returns an array of PaletteColor objects.\r\n */\r\nexport function generateDefaultPalette(): PaletteColor[] {\r\n    const palette: PaletteColor[] = [];\r\n    for (let i = 0; i < DEFAULT_PALETTE_ENTRIES; i++) {\r\n        // Formula for default palette: bits 7-5 are R, 4-2 are G, 1-0 are B\r\n        // The lowest blue bit (bit 0 of the 9-bit value) is an OR of the two blue bits present (bits 1 and 0 of the 8-bit value)\r\n        const rrr = (i >> 5) & 0b111;\r\n        const ggg = (i >> 2) & 0b111;\r\n        // Original formula seems correct for deriving 9-bit Blue from 8-bit RRRGGGBB byte i\r\n        // B2 = original B1, B1 = original B0, B0 = original B1 | original B0\r\n        const bbb = ((i & 0x03) << 1) | ((i & 0x03) > 0 ? 1 : 0);\r\n        \r\n        // Convert the 3-bit components using the specific hardware mapping\r\n        const hex = rgb9ToHex(rrr, ggg, bbb);\r\n        palette.push({ hex, priority: false });\r\n    }\r\n    // Add Logging\r\n    console.log(`[paletteUtils] Generated default palette. First 5 entries: ${JSON.stringify(palette.slice(0, 5))}`);\r\n    return palette;\r\n}\r\n\r\n/**\r\n * Parses palette data (expects .nxp or .pal format - 512 bytes).\r\n * Returns an array of PaletteColor objects.\r\n */\r\nexport function parsePaletteFile(fileData: Uint8Array): PaletteColor[] {\r\n    // Allow files smaller than 512, but must be multiple of 2 bytes\r\n    if (fileData.length % BYTES_PER_COLOR_ENTRY !== 0) {\r\n        throw new Error(`Invalid palette file size. Size (${fileData.length}) must be a multiple of ${BYTES_PER_COLOR_ENTRY}.`);\r\n    }\r\n    if (fileData.length > DEFAULT_PALETTE_ENTRIES * BYTES_PER_COLOR_ENTRY) {\r\n        console.warn(`Palette file size (${fileData.length}) > ${DEFAULT_PALETTE_ENTRIES * BYTES_PER_COLOR_ENTRY}. Only the first ${DEFAULT_PALETTE_ENTRIES} colors will be used.`);\r\n    }\r\n\r\n    const numColorsInFile = Math.min(DEFAULT_PALETTE_ENTRIES, fileData.length / BYTES_PER_COLOR_ENTRY);\r\n    console.log(`Parsing ${numColorsInFile} colors from palette file (size: ${fileData.length} bytes).`);\r\n\r\n    const dataView = new DataView(fileData.buffer, fileData.byteOffset, fileData.byteLength);\r\n    const palette: PaletteColor[] = [];\r\n    \r\n    // Read colors present in the file\r\n    for (let i = 0; i < numColorsInFile; i++) {\r\n        const offset = i * BYTES_PER_COLOR_ENTRY;\r\n        const value = dataView.getUint16(offset, false); // false for big-endian\r\n        const { rgb9, priority } = value16BitToRgb9Priority(value);\r\n        const hex = rgb9ToHex(rgb9.r9, rgb9.g9, rgb9.b9);\r\n        // --- Log first 8 entries --- \r\n        if (i < 8) {\r\n            console.log(`[parsePaletteFile] Raw[${i}]: ${value.toString(16).padStart(4, '0')}, Parsed: { hex: \"${hex}\", priority: ${priority} }`);\r\n        }\r\n        // --- End Log ---\r\n        palette.push({ hex, priority });\r\n    }\r\n\r\n    // Pad the palette with black up to 256 entries if file was smaller\r\n    while (palette.length < DEFAULT_PALETTE_ENTRIES) {\r\n        palette.push({ hex: '#000000', priority: false });\r\n    }\r\n\r\n    return palette; // Always return a 256-color array\r\n}\r\n\r\n/**\r\n * Encodes an array of PaletteColor objects into a buffer (512 bytes, .nxp/.pal format).\r\n */\r\nexport function encodePaletteFile(palette: PaletteColor[]): Uint8Array {\r\n    // Use Uint8Array and DataView for platform-independent writing\r\n    const buffer = new ArrayBuffer(DEFAULT_PALETTE_ENTRIES * BYTES_PER_COLOR_ENTRY);\r\n    const dataView = new DataView(buffer);\r\n    const outputArray = new Uint8Array(buffer); // Create Uint8Array view\r\n\r\n    if (palette.length !== DEFAULT_PALETTE_ENTRIES) {\r\n        console.warn(`Palette array length (${palette.length}) is not ${DEFAULT_PALETTE_ENTRIES}. Output buffer might be incomplete or padded.`);\r\n    }\r\n\r\n    for (let i = 0; i < DEFAULT_PALETTE_ENTRIES; i++) {\r\n        const offset = i * BYTES_PER_COLOR_ENTRY;\r\n        const colorEntry = palette[i] || { hex: '#000000', priority: false }; // Default if missing\r\n\r\n        const rgb9 = hexToRgb9(colorEntry.hex);\r\n        const value = rgb9To16BitValue(rgb9, colorEntry.priority);\r\n\r\n        // Write the 16-bit value (big-endian to match the parse function)\r\n        dataView.setUint16(offset, value, false); // false for big-endian (RRRGGGBB byte first, then priority byte)\r\n    }\r\n    return outputArray; // Return the Uint8Array\r\n}\r\n\r\n// --- Helper for Webview ---\r\n\r\n/**\r\n * Converts an `rgb(r, g, b)` string to a hex string.\r\n * Assumes standard 0-255 values in the rgb string.\r\n */\r\nexport function rgbStringToHex(rgbString: string): string | null {\r\n  const match = rgbString.match(/^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/);\r\n  if (!match) {\r\n    return null; // Return null or throw error?\r\n  }\r\n  const r = parseInt(match[1], 10);\r\n  const g = parseInt(match[2], 10);\r\n  const b = parseInt(match[3], 10);\r\n\r\n  const rHex = r.toString(16).padStart(2, '0');\r\n  const gHex = g.toString(16).padStart(2, '0');\r\n  const bHex = b.toString(16).padStart(2, '0');\r\n\r\n  return `#${rHex}${gHex}${bHex}`;\r\n}\r\n\r\n// --- Deprecated / To Be Removed ---\r\n/** @deprecated Use generateDefaultPalette() instead */\r\nexport function generateDefaultHexPalette(): string[] {\r\n    return generateDefaultPalette().map(c => c.hex);\r\n}\r\n/** deprecated Use rgb9To16BitValue and Buffer.writeUInt16LE instead */\r\nexport function rgb9ToBytes(r9: number, g9: number, b9: number): [number, number] {\r\n    const value = rgb9To16BitValue({ r9, g9, b9 }, false); // Assume false priority\r\n    return [(value >> 8) & 0xFF, value & 0xFF];\r\n}\r\n/** @deprecated Use value16BitToRgb9Priority instead */\r\nexport function bytesToRgb9(byte1: number, byte2: number): Rgb9 {\r\n     const value = (byte1 << 8) | byte2;\r\n     const { rgb9 } = value16BitToRgb9Priority(value);\r\n     return rgb9;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/* eslint-disable curly */\n// src/webview/spriteRenderer.js\n\n// Helper functions related to updating the webview's HTML content.\n\n// Import necessary utilities if they are needed *within* these functions\n// (e.g., if getDisplayColorIndex was complex and moved to a util)\n// import { getDisplayColorIndex } from './someUtils'; \n\n// --- Helper to get final color index based on mode and offset --- \n// Keep this helper local to the renderer as it's only used here\nfunction getDisplayColorIndex(rawIndex, currentPalette, viewState) {\n    if (!viewState || !currentPalette) return 0; // Return 0 (black) if no palette or viewState\n\n    const mode = viewState.mode;\n    const offsetBank = viewState.paletteOffset;\n    let finalIndex = rawIndex;\n\n    if (mode === 'sprite4' || mode === 'tile8x8') {\n        finalIndex = offsetBank + rawIndex;\n    } \n    \n    // Ensure the index is always valid - if it's beyond the current palette length\n    // or the entry doesn't exist, return 0 (black) as a fallback\n    if (finalIndex < 0 || finalIndex >= currentPalette.length || !currentPalette[finalIndex]) {\n        return 0;\n    }\n    \n    return finalIndex;\n}\n\n// --- Palette Picker Rendering --- \nexport function populatePalettePicker(palettePicker, paletteState, selectionState, isDefaultPaletteActive, selectPrimaryColor, selectSecondaryColor, vscode) {\n    console.log(\"[Renderer] populatePalettePicker START\"); // Add START log\n    if (!palettePicker) { \n        console.error(\"[Renderer] Palette picker element not found!\");\n        return; \n    }\n    palettePicker.innerHTML = '';\n    console.log(\"[Renderer] Cleared palettePicker innerHTML\"); // Log after clear\n\n    if (!paletteState || !paletteState.current || paletteState.current.length === 0) {\n        console.warn(\"[Renderer] No valid current palette data found in paletteState.\");\n        return; \n    }\n\n    const currentPalette = paletteState.current; \n\n    const limit = Math.min(currentPalette.length, paletteState.visibleSize);\n    \n    for (let index = 0; index < limit; index++) {\n        const color = currentPalette[index];\n        const swatch = document.createElement('div');\n        swatch.className = 'color-swatch';\n        swatch.style.backgroundColor = color.hex;\n        swatch.dataset.colorIndex = index.toString();\n        swatch.draggable = true;\n        \n        // Add tooltip with color information\n        // Extract RGB components from hex\n        const r = parseInt(color.hex.substring(1, 3), 16);\n        const g = parseInt(color.hex.substring(3, 5), 16);\n        const b = parseInt(color.hex.substring(5, 7), 16);\n        \n        // Calculate RGB9 values (simplified approximation)\n        const r9 = Math.round(r * 7 / 255);\n        const g9 = Math.round(g * 7 / 255);\n        const b9 = Math.round(b * 3 / 255);\n        \n        // Calculate RGB9 bytes (would need proper conversion but this is simplified)\n        const rgb9Byte1 = ((r9 & 0x7) << 5) | ((g9 & 0x7) << 2) | ((b9 & 0x3) >> 1);\n        const rgb9Byte2 = ((b9 & 0x1) << 7) | (color.priority ? 0x80 : 0);\n        \n        swatch.title = `Index: ${index}\nHex: ${color.hex}\nRGB9 bytes: (${rgb9Byte1}, ${rgb9Byte2})\nRGB9: (${r9},${g9},${b9})\nRGB24: (${r},${g},${b})\nPriority: ${color.priority}`;\n\n        // Add appropriate selection classes\n        if (index === selectionState.primaryColorIndex) {\n            swatch.classList.add('primary-selected');\n        }\n        \n        if (index === selectionState.secondaryColorIndex) {\n            swatch.classList.add('secondary-selected');\n        }\n        \n        // Color selection (primary on left click)\n        swatch.addEventListener('click', (event) => {\n            if (!event.ctrlKey) { // Only select if not ctrl-clicking (which is for swap)\n                selectPrimaryColor(index);\n            } else {\n                // Log that we're ignoring the click due to Ctrl key\n                console.log(`[Renderer] Ignoring color selection click on index ${index} because Ctrl key is pressed`);\n            }\n        });\n        \n        // Color selection (secondary on right click)\n        swatch.addEventListener('contextmenu', (event) => {\n            event.preventDefault();\n            selectSecondaryColor(index);\n            // Store right-click state in window for persistence\n            if (!window.colorCopyState) window.colorCopyState = {};\n            window.colorCopyState.isCopying = true;\n            window.colorCopyState.sourceIndex = index;\n            console.log(`[Renderer] Right-click on color ${index} - ready for copy`);\n        });\n\n        palettePicker.appendChild(swatch);\n    }\n    \n    console.log(\"[Renderer] populatePalettePicker END - Added swatches\"); // Add END log\n}\n\n// --- Sprite Grid Rendering --- \nexport function redrawSpriteGrid(spriteListContainer, spriteData, viewState, currentPalette, vscode, appState) {\n    console.log(`[Renderer] >>> redrawSpriteGrid START (Mode: ${viewState.mode})`); \n    if (!spriteListContainer || !spriteData) {\n        console.log(\"[Renderer] redrawSpriteGrid END - Early exit (no container or spriteData)\"); \n        return;\n    }\n    spriteListContainer.innerHTML = '';\n    if (!spriteData.sprites) {\n        console.log(\"[Renderer] redrawSpriteGrid END - Early exit (no sprites array)\"); \n        return;\n    }\n\n    const brush = viewState.spriteBrush || { width: 1, height: 1 }; // Default to 1x1 if undefined\n    const gridColumnCount = brush.width > 0 ? brush.width : 1; // Ensure at least 1 column\n    console.log(`[Renderer redrawSpriteGrid] Brush width: ${brush.width}, Grid column count: ${gridColumnCount}`); // Log the calculated column count\n    spriteListContainer.style.gridTemplateColumns = `repeat(${gridColumnCount}, 1fr)`;\n\n    const SPRITES_PER_ROW = 16; // This constant might be less relevant now for display, but used for highlight calc context\n    const topLeftBrushIndex = viewState.currentSprite;\n    const topLeftBrushRow = Math.floor(topLeftBrushIndex / SPRITES_PER_ROW);\n    const topLeftBrushCol = topLeftBrushIndex % SPRITES_PER_ROW;\n\n    spriteData.sprites.forEach((sprite) => {\n        const spriteBox = document.createElement('div');\n        spriteBox.className = 'sprite-box';\n\n        // New logic to determine if the current sprite is in the brush area\n        let isActuallyInBrushArea = false;\n        for (let by = 0; by < brush.height; by++) {\n            for (let bx = 0; bx < brush.width; bx++) {\n                if (sprite.index === topLeftBrushIndex + bx + (by * brush.width)) {\n                    isActuallyInBrushArea = true;\n                    break;\n                }\n            }\n            if (isActuallyInBrushArea) break;\n        }\n\n        if (isActuallyInBrushArea) {\n            spriteBox.classList.add('brush-area-sprite'); // New class for general brush area\n        }\n\n        if(sprite.index === topLeftBrushIndex) { // Top-left of brush is the primary selection\n            spriteBox.classList.add('selected');\n        }\n        spriteBox.dataset.index = sprite.index.toString();\n        spriteBox.draggable = true;\n\n        const spriteContainer = document.createElement('div');\n        spriteContainer.className = 'sprite-container';\n        spriteContainer.style.gridTemplateColumns = `repeat(${sprite.width}, 1fr)`;\n        \n        sprite.pixels.forEach((rawPixelIndex) => {\n            const pixelDiv = document.createElement('div');\n            pixelDiv.className = 'sprite-pixel';\n            const displayIndex = getDisplayColorIndex(rawPixelIndex, currentPalette, viewState);\n           //if (sprite.index === 0 && rawPixelIndex !== 0) { // Log for first sprite, non-zero raw index\n            //     console.log(`[Renderer Grid] Sprite ${sprite.index}, Raw ${rawPixelIndex} -> Display ${displayIndex}, Color: ${currentPalette[displayIndex]?.hex}`);\n            //}\n            pixelDiv.style.backgroundColor = currentPalette[displayIndex]?.hex || '#FF00FF'; \n            spriteContainer.appendChild(pixelDiv);\n        });\n\n        const spriteIndexDiv = document.createElement('div');\n        spriteIndexDiv.className = 'sprite-index';\n        spriteIndexDiv.textContent = sprite.index.toString();\n\n        spriteBox.appendChild(spriteContainer);\n        spriteBox.appendChild(spriteIndexDiv);\n\n        // Event listeners for interaction \n        spriteBox.addEventListener('click', (event) => {\n            const index = parseInt(spriteBox.dataset.index || '0', 10);\n            if (event.altKey) {\n                vscode.postMessage({ command: 'pasteSprite', targetIndex: index });\n            } else {\n                // Optimistically update the UI immediately before waiting for the round-trip\n                if (appState && appState.viewState && appState.spriteData) {\n                    const previousIndex = appState.viewState.currentSprite;\n                    if (previousIndex === index) return; // No change\n\n                    appState.viewState.currentSprite = index;\n                    \n                    // 1. Redraw the entire sprite grid to update selection and brush highlights\n                    const currentSpriteListContainer = document.querySelector('.sprites-grid'); // Or pass spriteListContainer if available in this scope\n                    if (currentSpriteListContainer) {\n                        redrawSpriteGrid(currentSpriteListContainer, appState.spriteData, appState.viewState, appState.palette.current, vscode, appState);\n                    }\n                    \n                    // 2. Update the detail view with the new sprite\n                    const detailContainer = document.querySelector('.detail-container');\n                    if (detailContainer) {\n                        redrawDetailView(\n                            detailContainer, \n                            appState.spriteData, \n                            appState.viewState, \n                            appState.palette.current, \n                            !appState.palette.isCustom\n                        );\n                    }\n                    \n                    // 3. Update detail title (already handled by redrawDetailView typically)\n                    // const detailTitle = document.querySelector('.sprite-detail h2');\n                    // if (detailTitle) {\n                    // detailTitle.textContent = `Sprite ${index} Detail`;\n                    // }\n                }\n                \n                // Then send the message to the extension to make it official\n                vscode.postMessage({ command: 'viewSprite', index });\n            }\n        });\n        spriteBox.addEventListener('contextmenu', (event) => {\n            event.preventDefault();\n            const index = parseInt(spriteBox.dataset.index || '0', 10);\n            if (event.ctrlKey && event.shiftKey) {\n                vscode.postMessage({ command: 'removeSprite', index: index });\n            } else {\n                vscode.postMessage({ command: 'copySprite', sourceIndex: index });\n            }\n        });\n\n        spriteListContainer.appendChild(spriteBox);\n    });\n\n    // --- Append the \"Add New Sprite\" box --- \n    const addBox = document.createElement('div');\n    addBox.className = 'add-sprite-box';\n    addBox.title = 'Add new sprite';\n    addBox.innerHTML = `\n        <div class=\"add-sprite-plus\">+</div>\n        <div class=\"add-sprite-text\">New</div>\n    `;\n    addBox.addEventListener('click', () => {\n        vscode.postMessage({ command: 'addNewSprite' });\n    });\n    spriteListContainer.appendChild(addBox);\n    console.log(`[Renderer] >>> redrawSpriteGrid END (Mode: ${viewState.mode})`); // <<< ADDED LOG\n}\n\n// --- Sprite Detail View Rendering --- \nexport function redrawDetailView(mainSpriteDetailContainer, spriteData, viewState, currentPalette, isDefaultPaletteMode) {\n    console.log(`[Renderer] >>> redrawDetailView START (Mode: ${viewState.mode}, Sprite: ${viewState.currentSprite})`); // <<< ADDED LOG\n    if (!mainSpriteDetailContainer || !spriteData || !spriteData.sprites) {\n        if (mainSpriteDetailContainer) {\n            mainSpriteDetailContainer.innerHTML = '<div>Error: Sprite data unavailable.</div>';\n        }\n        console.log(\"[Renderer] redrawDetailView END - Early exit (no container or spriteData)\");\n        return;\n    }\n\n    const brush = viewState.spriteBrush || { width: 1, height: 1 };\n    const SPRITES_PER_ROW = 16; // Consistent with other parts\n    const topLeftSpriteIndex = viewState.currentSprite;\n\n    // Determine the actual dimensions of the sprite (assuming all sprites in brush are same size as top-left)\n    const refSpriteForDim = spriteData.sprites[topLeftSpriteIndex];\n    if (!refSpriteForDim) {\n        if (mainSpriteDetailContainer) {\n            mainSpriteDetailContainer.innerHTML = `<div>Error: Top-left sprite for brush (index: ${topLeftSpriteIndex}) not found.</div>`;\n        }\n        console.log(\"[Renderer] redrawDetailView END - Early exit (top-left sprite not found)\");\n        return;\n    }\n    const singleSpriteWidth = refSpriteForDim.width;\n    const singleSpriteHeight = refSpriteForDim.height;\n\n    const compositeWidthInSprites = brush.width;\n    const compositeHeightInSprites = brush.height;\n    const compositePixelWidth = singleSpriteWidth * compositeWidthInSprites;\n    const compositePixelHeight = singleSpriteHeight * compositeHeightInSprites;\n\n    mainSpriteDetailContainer.innerHTML = ''; \n    mainSpriteDetailContainer.style.gridTemplateColumns = `repeat(${compositePixelWidth}, 1fr)`;\n    // Adjust container size if needed, or rely on CSS to handle overflow if it becomes too large\n    // For now, let --detail-pixel-size control individual pixel size, and grid will expand.\n\n    const compositePixels = []; // This will store pixels row by row for the final composite image\n\n    // Iterate over each row of pixels in the final composite brush image\n    for (let compositeRow = 0; compositeRow < compositePixelHeight; compositeRow++) {\n        // Determine which row of sprites in the brush this compositeRow belongs to\n        const brushSpriteRow = Math.floor(compositeRow / singleSpriteHeight); // e.g., 0 or 1 for a 2-sprite high brush\n\n        // Determine which pixel row *within* that sprite this compositeRow corresponds to\n        const pixelRowInSprite = compositeRow % singleSpriteHeight;\n\n        // Now iterate over each column of sprites in the brush\n        for (let brushSpriteCol = 0; brushSpriteCol < brush.width; brushSpriteCol++) {\n            // Determine the actual original sprite index for this part of the brush\n            const actualOriginalSpriteIndex = topLeftSpriteIndex + brushSpriteCol + (brushSpriteRow * brush.width);\n\n            const sprite = (actualOriginalSpriteIndex >= 0 && actualOriginalSpriteIndex < spriteData.count) ? spriteData.sprites[actualOriginalSpriteIndex] : null;\n            const spriteIsValid = sprite && sprite.pixels && sprite.width === singleSpriteWidth && sprite.height === singleSpriteHeight;\n\n            // Now iterate over each pixel column *within* the current source sprite\n            for (let pixelColInSprite = 0; pixelColInSprite < singleSpriteWidth; pixelColInSprite++) {\n                if (spriteIsValid) {\n                    const pixelIndexInSourceSprite = pixelRowInSprite * singleSpriteWidth + pixelColInSprite;\n                    const rawPixelValue = sprite.pixels[pixelIndexInSourceSprite];\n                    const displayPaletteIndex = getDisplayColorIndex(rawPixelValue, currentPalette, viewState);\n                    compositePixels.push({\n                        raw: rawPixelValue,\n                        displayHex: currentPalette[displayPaletteIndex]?.hex || '#FF00FF',\n                        spriteIndex: actualOriginalSpriteIndex,\n                        localPixelIndex: pixelIndexInSourceSprite\n                    });\n                } else {\n                    // Handle placeholder for invalid/missing sprite part of brush\n                    compositePixels.push({ raw: 0, displayHex: 'rgba(0,0,0,0.1)' /* Placeholder */, spriteIndex: -1, localPixelIndex: -1 });\n                }\n            }\n        }\n    }\n    \n    compositePixels.forEach((pixelData, i) => {\n        const pixelDiv = document.createElement('div');\n        pixelDiv.className = 'detail-pixel';\n        pixelDiv.style.backgroundColor = pixelData.displayHex;\n        // Store data attributes for interaction if needed later by drawPixel\n        pixelDiv.dataset.originalSpriteIndex = pixelData.spriteIndex;\n        pixelDiv.dataset.localPixelIndex = pixelData.localPixelIndex;\n        pixelDiv.dataset.compositePixelIndex = i.toString(); // Index in the composite view\n\n        pixelDiv.draggable = false; // Explicitly prevent dragging\n        mainSpriteDetailContainer.appendChild(pixelDiv);\n    });\n    \n    // Update detail info text\n    const detailInfoDiv = document.querySelector('.detail-info');\n    if (detailInfoDiv) {\n        let paletteName = 'Default';\n        if (!isDefaultPaletteMode) {\n            const statusElement = document.getElementById('paletteStatus');\n            if (statusElement && statusElement.textContent && statusElement.textContent.includes('Palette:')) {\n                paletteName = statusElement.textContent.replace('Palette: ','').trim() || 'Custom';\n            } else {\n                paletteName = 'Custom';\n            }\n        }\n        let infoText = `Size: ${compositePixelWidth}x${compositePixelHeight} pixels (${compositeWidthInSprites}x${compositeHeightInSprites} sprites) | Palette: ${paletteName}`;\n        if (viewState.mode === 'sprite4' || viewState.mode === 'tile8x8') {\n            infoText += ` | Offset: ${viewState.paletteOffset}`;\n        }\n        detailInfoDiv.textContent = infoText;\n    }\n    \n    // Update footer text\n    const footerDiv = document.querySelector('.footer'); \n    if (footerDiv) {\n        footerDiv.textContent = `ZX Next Sprite format: ${spriteData.count} sprites loaded. Brush: ${brush.width}x${brush.height}.`;\n    }\n    \n    // Update detail title\n    const detailTitleH2 = document.querySelector('.sprite-detail-container h2'); \n    if (detailTitleH2) {\n        detailTitleH2.innerHTML = `Sprite Brush Detail (Top-Left: ${topLeftSpriteIndex}, Size: ${brush.width}x${brush.height})`;\n    }\n\n    // Update the CSS variable for detail pixel size\n    if (typeof window.updateDetailPixelSizeCss === 'function') {\n        window.updateDetailPixelSizeCss();\n    }\n\n    console.log(`[Renderer] >>> redrawDetailView END (Mode: ${viewState.mode}, Sprite: ${viewState.currentSprite}, Brush: ${brush.width}x${brush.height})`);\n}\n\n// --- Helper to update sprite pixel display colors when palette changes --- \nexport function updateSpritePixelColors(spriteListContainer, mainSpriteDetailContainer, spriteData, viewState, currentPalette, colorIndexToUpdate, newHexColor) {\n    const displayIndexToUpdate = colorIndexToUpdate; \n    \n    // Update pixels in the main grid\n    const spriteBoxes = spriteListContainer?.querySelectorAll('.sprite-box');\n    spriteBoxes?.forEach(box => {\n        const spriteIndex = parseInt(box.dataset.index, 10);\n        if (!isNaN(spriteIndex) && spriteData?.sprites && spriteIndex < spriteData.sprites.length) {\n            const sprite = spriteData.sprites[spriteIndex];\n            const pixelElements = box.querySelectorAll('.sprite-pixel');\n            pixelElements.forEach((pixelEl, pixelIdx) => {\n                const rawPixelIndex = sprite.pixels[pixelIdx];\n                const displayIndex = getDisplayColorIndex(rawPixelIndex, currentPalette, viewState);\n                if (displayIndex === displayIndexToUpdate) {\n                    (pixelEl).style.backgroundColor = newHexColor;\n                }\n            });\n        }\n    });\n\n    // Update pixels in the detail view\n    if (mainSpriteDetailContainer && spriteData?.sprites && viewState.currentSprite < spriteData.sprites.length) {\n        const currentSprite = spriteData.sprites[viewState.currentSprite];\n        const detailPixelElements = mainSpriteDetailContainer.querySelectorAll('.detail-pixel');\n         detailPixelElements.forEach((pixelEl, pixelIdx) => {\n            const rawPixelIndex = currentSprite.pixels[pixelIdx];\n            const displayIndex = getDisplayColorIndex(rawPixelIndex, currentPalette, viewState);\n            if (displayIndex === displayIndexToUpdate) {\n                (pixelEl).style.backgroundColor = newHexColor;\n            }\n        });\n    }\n} ","/* eslint-disable curly */\n// src/webview/eventHandlers.js\nconsole.log(\"[Webview Handlers] eventHandlers.js script started\"); // Log script start\n\n// Import necessary functions if needed\nimport { floodFill, flipVertical, flipHorizontal, scrollVertical, scrollHorizontal, rotateClockwise, rotateCounterClockwise } from '../drawingUtils';\nimport { redrawDetailView } from './spriteRenderer.js'; // Import the redrawDetailView function\nimport { hexToRgb9, rgb9ToHex, rgb9ToBytes, bytesToRgb9, rgbStringToHex } from '../paletteUtils';\nimport { redrawSpriteGrid } from './spriteRenderer.js'; // Import the redrawSpriteGrid function\n\n// This module encapsulates event handling logic for the sprite viewer webview.\n\n// --- State and Dependencies --- \n// These will be passed in or accessed via a context object\nlet localState = {\n    isDrawing: false,\n    lastDrawnPixelIndex: -1,\n    draggedIndex: -1,\n    draggedSpriteIndex: -1, // Added for sprite dragging\n    drawButton: 0, \n    editTimeout: null, \n    isCopyingColor: false, \n    colorCopySourceIndex: -1, \n    colorUpdateTimeout: null, \n    lastMessageTime: 0, \n    isSwappingColor: false, \n    currentlyHoverHighlightedIndex: -1,\n    isFillModeActive: false,\n    // Add state for Ctrl+LMB drag swapping\n    ctrlDragActive: false,\n    ctrlDragSourceIndex: -1,\n    ctrlDragTargetIndex: -1,\n    dragDisabledSwatch: null, // Store swatch element when disabling draggable\n    // Add state for tracking 'c' key for color replacement\n    isColorReplaceActive: false\n};\n\nlet appState = {}; // Will hold the main application state object\nlet domElements = {}; // Will hold references to DOM elements\nlet utils = {}; // Will hold utility functions like markAsDirty, selectPrimaryColor, etc.\nlet vscode = null; // Reference to vscode API object\n\n// --- Event Handler Definitions --- \n\n// --- Add the color replacement function ---\nfunction replaceColorInSprite(sourceColorIndex, targetColorIndex, spriteIndex) {\n    if (!appState.spriteData || !appState.spriteData.sprites || \n        spriteIndex < 0 || spriteIndex >= appState.spriteData.sprites.length) {\n        return false;\n    }\n    \n    const sprite = appState.spriteData.sprites[spriteIndex];\n    let colorChanged = false;\n    \n    // Replace all instances of sourceColorIndex with targetColorIndex\n    for (let i = 0; i < sprite.pixels.length; i++) {\n        if (sprite.pixels[i] === sourceColorIndex) {\n            sprite.pixels[i] = targetColorIndex;\n            colorChanged = true;\n        }\n    }\n    \n    return colorChanged;\n}\n\nfunction handleDragStart(event) {\n    const swatch = event.target;\n    localState.draggedIndex = parseInt(swatch.dataset.colorIndex, 10);\n    event.dataTransfer.effectAllowed = 'move';\n    event.dataTransfer.setData('text/plain', localState.draggedIndex.toString());\n    swatch.classList.add('dragging');\n    localState.isSwappingColor = event.ctrlKey;\n    // console.log(`[Webview Handlers] Drag Start: index=${localState.draggedIndex}, isSwapping=${localState.isSwappingColor}`); \n}\n\nfunction handleDragOver(event) {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'move';\n    const targetSwatch = event.target.closest('.color-swatch');\n    if (targetSwatch && parseInt(targetSwatch.dataset.colorIndex, 10) !== localState.draggedIndex) {\n        targetSwatch.classList.add('drag-over');\n    }\n}\n\nfunction handleDragLeave(event) {\n    const targetSwatch = event.target.closest('.color-swatch');\n     if (targetSwatch) {\n        targetSwatch.classList.remove('drag-over');\n    }\n}\n\nfunction handleDrop(event) {\n    event.preventDefault();\n    const targetSwatch = event.target.closest('.color-swatch');\n    const sourceIndex = localState.draggedIndex;\n    let targetIndex = -1;\n    \n    if (targetSwatch) {\n        targetIndex = parseInt(targetSwatch.dataset.colorIndex, 10);\n        targetSwatch.classList.remove('drag-over');\n    }\n\n    const draggingElement = document.querySelector('.color-swatch.dragging');\n     \n    if (draggingElement) draggingElement.classList.remove('dragging');\n    \n    // Log the drop operation details\n    console.log(`[Webview Handlers] Drop event - source=${sourceIndex}, target=${targetIndex}, swapping=${localState.isSwappingColor}`);\n    \n    if (targetIndex === -1 || sourceIndex === -1 || targetIndex === sourceIndex) {\n        console.log('[Webview Handlers] Drop cancelled: Invalid indices or dropped on self.');\n        localState.isSwappingColor = false;\n        localState.draggedIndex = -1;\n        return; \n    }\n    \n    if (utils.isDefaultPaletteActive()) {\n        vscode.postMessage({ command: 'promptEditDefaultPalette' });\n        localState.isSwappingColor = false;\n        localState.draggedIndex = -1;\n        return;\n    }\n    \n    // Ensure target index is within the 256-color limit\n    if (targetIndex >= 256) {\n        console.log('[Webview Handlers] Drop cancelled: Target index beyond 256-color limit.');\n        localState.isSwappingColor = false;\n        localState.draggedIndex = -1;\n        return;\n    }\n    \n    if (localState.isSwappingColor) {\n        // Swap Logic \n        if (sourceIndex < appState.palette.current.length && targetIndex < 256) {\n            console.log('[Webview Handlers] Performing color and pixel swap.');\n            \n            // First store the colors for swapping\n            const sourceColor = { ...appState.palette.current[sourceIndex] };\n            \n            // If we're swapping to a palette index beyond what's loaded, create a black color there\n            if (targetIndex >= appState.palette.current.length) {\n                // Create a new color at the target position if needed\n                while (appState.palette.current.length <= targetIndex) {\n                    appState.palette.current.push({ hex: '#000000', priority: false });\n                }\n                console.log(`[Webview Handlers] Extended palette to index ${targetIndex}`);\n            }\n            \n            const targetColor = { ...appState.palette.current[targetIndex] };\n            \n            // Now perform the swap in the local palette\n            appState.palette.current[sourceIndex] = targetColor;\n            appState.palette.current[targetIndex] = sourceColor;\n            \n            // Swap pixel indices in sprites\n            const modifiedSpriteIndices = utils.swapPixelIndices(sourceIndex, targetIndex);\n            \n            // Update UI - mark sprite as dirty because pixel values change\n            utils.markAsDirty(false); // false = this is a sprite change\n            \n            // Send message to extension to sync state\n            vscode.postMessage({\n                command: 'paletteSwap', \n                indexA: sourceIndex,\n                indexB: targetIndex,\n                newColorA: appState.palette.current[sourceIndex],\n                newColorB: appState.palette.current[targetIndex]\n            });\n            \n            // Send updated sprite data\n            modifiedSpriteIndices.forEach(spriteIdx => {\n                if (appState.spriteData && appState.spriteData.sprites && appState.spriteData.sprites[spriteIdx]) {\n                     vscode.postMessage({\n                         command: 'updateSpritePixels',\n                         spriteIndex: spriteIdx,\n                         pixels: appState.spriteData.sprites[spriteIdx].pixels,\n                         skipVsCodeDirtyNotification: true\n                     });\n                }\n            });\n            \n            // Redraw the UI\n            utils.requestFullRedraw();\n        }\n    } else {\n        // Move Logic - only affects palette order, not sprite pixels\n        if (sourceIndex < appState.palette.current.length && targetIndex < 256) {\n            console.log('[Webview Handlers] Performing palette color move.');\n            \n            // Copy the source color\n            const sourceColor = { ...appState.palette.current[sourceIndex] };\n            \n            // If we're moving to a palette index beyond what's loaded, extend the palette\n            if (targetIndex >= appState.palette.current.length) {\n                // Create new black colors to pad the palette up to the target index\n                while (appState.palette.current.length <= targetIndex) {\n                    appState.palette.current.push({ hex: '#000000', priority: false });\n                }\n                console.log(`[Webview Handlers] Extended palette to index ${targetIndex}`);\n            }\n            \n            // Splice it out and in at the target position\n            appState.palette.current.splice(sourceIndex, 1);\n            appState.palette.current.splice(targetIndex, 0, sourceColor);\n            \n            // Update UI - mark only palette as dirty since this doesn't affect pixel values\n            utils.markAsDirty(true); // true = this is a palette-only change\n            \n            // Send message to extension to sync state\n            vscode.postMessage({\n                command: 'updatePaletteOrder',\n                palette: appState.palette.current\n            });\n            \n            // Redraw the UI\n            utils.requestFullRedraw();\n        }\n    }\n    \n    // Reset state\n    localState.isSwappingColor = false;\n    localState.draggedIndex = -1;\n}\n\nfunction handleDragEnd(event) {\n     if(event.target && event.target.classList) { \n        event.target.classList.remove('dragging');\n     }\n     document.querySelectorAll('.color-swatch.drag-over').forEach(sw => sw.classList.remove('drag-over'));\n     localState.draggedIndex = -1;\n     localState.isSwappingColor = false;\n     console.log('[Webview Handlers] Drag ended, reset draggedIndex and isSwappingColor');\n}\n\nfunction handleColorUpdate() {\n    // console.log(`[Webview Handlers] handleColorUpdate START - editorColorIndex: ${appState?.selection?.editorColorIndex}`); // <<< REMOVE LOG\n    if (utils.isDefaultPaletteActive()) {\n        vscode.postMessage({ command: 'promptEditDefaultPalette' });\n        utils.updateEditorPanel(appState.selection.editorColorIndex);\n        return;\n    }\n    const editorActiveIndex = appState.selection.editorColorIndex;\n    // --- FIX: Ensure index is valid before proceeding --- \n    if (editorActiveIndex < 0) {\n        console.warn(\"[Webview Handlers] handleColorUpdate: Invalid editorActiveIndex\", editorActiveIndex);\n        return;\n    }\n    // --- END FIX ---\n\n    const r9 = parseInt(domElements.sliderR.value, 10);\n    const g9 = parseInt(domElements.sliderG.value, 10);\n    const b9 = parseInt(domElements.sliderB.value, 10);\n    const newHexColor = utils.rgb9ToHex(r9, g9, b9);\n    // console.log(`[Webview Handlers] handleColorUpdate - Calculated newHexColor: ${newHexColor}`); // <<< REMOVE LOG\n    \n    // --- FIX: Update appState, call previews and extension update --- \n    // Extend palette if needed (e.g., editing beyond current length)\n    // console.log(`[Webview Handlers] handleColorUpdate - Before palette extend loop. Current length: ${appState.palette.current?.length}`); // <<< REMOVE LOG\n    while (appState.palette.current.length <= editorActiveIndex) {\n        appState.palette.current.push({ hex: '#000000', priority: false });\n    }\n    // console.log(`[Webview Handlers] handleColorUpdate - After palette extend loop. New length: ${appState.palette.current?.length}`); // <<< REMOVE LOG\n    \n    // Update the hex value in the appState\n    // console.log(`[Webview Handlers] handleColorUpdate - Before updating appState hex for index ${editorActiveIndex}`); // <<< REMOVE LOG\n    appState.palette.current[editorActiveIndex].hex = newHexColor;\n    // console.log(`[Webview Handlers] handleColorUpdate - After updating appState hex for index ${editorActiveIndex}`); // <<< REMOVE LOG\n    \n    // Update UI previews (swatch, L/R boxes, detail/grid pixels)\n    // console.log(`[Webview Handlers] handleColorUpdate - Before calling updateColorPreviews`); // <<< REMOVE LOG\n    utils.updateColorPreviews(editorActiveIndex, newHexColor);\n    // console.log(`[Webview Handlers] handleColorUpdate - After calling updateColorPreviews`); // <<< REMOVE LOG\n    \n    // Update the text/color picker input (redundant with updateEditorPanel, but safe)\n     \n    if (domElements.colorPickerInput) domElements.colorPickerInput.value = newHexColor;\n    if (domElements.primaryColorHexInput) domElements.primaryColorHexInput.value = newHexColor; \n    \n    // Mark palette as dirty and send update to extension (throttled)\n    // Note: sendColorUpdateToExtension handles marking dirty\n    // console.log(`[Webview Handlers] handleColorUpdate - Before calling sendColorUpdateToExtension (throttled)`); // <<< REMOVE LOG\n    const now = Date.now();\n    if (now - localState.lastMessageTime >= 100) {\n        utils.sendColorUpdateToExtension(editorActiveIndex, newHexColor); // Remove skipDirty flag\n        localState.lastMessageTime = now;\n    } else {\n        if (localState.colorUpdateTimeout) {\n            clearTimeout(localState.colorUpdateTimeout);\n        }\n        localState.colorUpdateTimeout = setTimeout(() => {\n            utils.sendColorUpdateToExtension(editorActiveIndex, newHexColor); // Remove skipDirty flag\n            localState.lastMessageTime = Date.now();\n        }, 100);\n    }\n    // console.log(`[Webview Handlers] handleColorUpdate - After calling sendColorUpdateToExtension (throttled)`); // <<< REMOVE LOG\n    // --- END FIX ---\n}\n\nfunction drawPixel(event, button) { // topLeftSpriteIndex might not be directly needed here anymore for drawing logic itself\n    if (!localState.isDrawing && event.type === 'mousemove') return;\n\n    const clickedCompositePixel = event.target.closest('.detail-pixel');\n    if (!clickedCompositePixel || !appState.spriteData || !appState.palette.current) return;\n\n    const originalSpriteIndex = parseInt(clickedCompositePixel.dataset.originalSpriteIndex, 10);\n    const localPixelIndex = parseInt(clickedCompositePixel.dataset.localPixelIndex, 10);\n    // const compositePixelIndex = parseInt(clickedCompositePixel.dataset.compositePixelIndex, 10);\n\n    if (isNaN(originalSpriteIndex) || isNaN(localPixelIndex) || originalSpriteIndex < 0 || originalSpriteIndex >= appState.spriteData.count) {\n        console.warn(\"[DrawPixel] Invalid data attributes on clicked pixel or sprite index out of bounds.\", clickedCompositePixel.dataset);\n        return;\n    }\n\n    const spriteToModify = appState.spriteData.sprites[originalSpriteIndex];\n    if (!spriteToModify || localPixelIndex < 0 || localPixelIndex >= spriteToModify.pixels.length) {\n        console.warn(\"[DrawPixel] Sprite to modify not found or local pixel index out of bounds.\");\n        return;\n    }\n\n    let selectedPaletteIndex = button === 2 ? appState.selection.secondaryColorIndex : appState.selection.primaryColorIndex;\n    let valueToStore;\n\n    if (appState.viewState.mode === 'sprite4' || appState.viewState.mode === 'tile8x8') {\n        const baseOffset = appState.viewState.paletteOffset;\n        if (selectedPaletteIndex >= baseOffset && selectedPaletteIndex < baseOffset + 16) {\n            valueToStore = selectedPaletteIndex - baseOffset;\n        } else {\n            vscode.postMessage({\n                command: 'showColorOutOfBankWarning',\n                selectedColorIndex: selectedPaletteIndex,\n                paletteOffset: baseOffset,\n                mode: appState.viewState.mode\n            });\n            return;\n        }\n    } else {\n        valueToStore = selectedPaletteIndex;\n    }\n\n    if (spriteToModify.pixels[localPixelIndex] !== valueToStore) {\n        spriteToModify.pixels[localPixelIndex] = valueToStore;\n\n        const displayIndex = utils.getDisplayColorIndex(valueToStore);\n        const colorEntry = appState.palette.current[displayIndex];\n        const hexColor = colorEntry?.hex || '#FF00FF';\n\n        // Update the clicked pixel in the composite detail view\n        clickedCompositePixel.style.backgroundColor = hexColor;\n\n        // Update the corresponding pixel in the main sprite grid\n        const gridPixelBox = domElements.spriteListContainer?.querySelector(`.sprite-box[data-index=\"${originalSpriteIndex}\"]`);\n        const gridPixel = gridPixelBox?.querySelector(`.sprite-container .sprite-pixel:nth-child(${localPixelIndex + 1})`);\n        if (gridPixel) gridPixel.style.backgroundColor = hexColor;\n\n        // Debounce message sending\n        if (localState.editTimeout) clearTimeout(localState.editTimeout);\n        localState.editTimeout = setTimeout(() => {\n                            vscode.postMessage({ \n                    command: 'updateSpritePixels', \n                    spriteIndex: originalSpriteIndex, \n                    pixels: spriteToModify.pixels,\n                    skipVsCodeDirtyNotification: true \n                });\n                // Don't notify VSCode of dirty state - only use internal state\n        }, 250);\n\n        if (!appState.editor.isDirty) {\n            const saveButton = document.getElementById('saveButton');\n            if (saveButton) {\n                saveButton.disabled = false;\n                saveButton.classList.add('save-button-dirty');\n            }\n            appState.editor.isDirty = true;\n        }\n    }\n    // localState.lastDrawnPixelIndex = localPixelIndex; // Still useful if drawing continues on same sprite\n}\n\nfunction handleDetailGridHover(event) {\n    if (localState.isDrawing) return;\n    if (!appState.spriteData || appState.spriteData.sprites.length === 0 || !appState.palette.current) return;\n    \n    const spriteIndex = appState.viewState.currentSprite;\n    const currentSprite = appState.spriteData.sprites[spriteIndex];\n    if (!currentSprite) return;\n\n    const spriteWidth = currentSprite.width;\n    const spriteHeight = currentSprite.height;\n    let pixelDisplaySize = 18;\n    try {\n        const sizeString = getComputedStyle(document.documentElement).getPropertyValue('--detail-pixel-size').trim();\n        if (sizeString.endsWith('px')) pixelDisplaySize = parseInt(sizeString, 10);\n        if (isNaN(pixelDisplaySize) || pixelDisplaySize <= 0) pixelDisplaySize = 18;\n    } catch (e) { pixelDisplaySize = 18; }\n\n    const rect = domElements.mainSpriteDetailContainer.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    const pixelX = Math.floor(x / pixelDisplaySize);\n    const pixelY = Math.floor(y / pixelDisplaySize);\n    const pixelIndex = pixelY * spriteWidth + pixelX;\n\n    if (localState.currentlyHoverHighlightedIndex !== -1) {\n        const prevSwatch = domElements.palettePicker?.querySelector(`.color-swatch[data-color-index=\"${localState.currentlyHoverHighlightedIndex}\"]`);\n        prevSwatch?.classList.remove('hover-highlight');\n        localState.currentlyHoverHighlightedIndex = -1;\n    }\n\n    if (pixelX >= 0 && pixelX < spriteWidth && pixelY >= 0 && pixelY < spriteHeight) {\n        const rawValue = currentSprite.pixels[pixelIndex];\n        const finalPaletteIndex = utils.getDisplayColorIndex(rawValue);\n        const colorEntry = appState.palette.current[finalPaletteIndex] || { hex: '#FF00FF', priority: false };\n        const hexColor = colorEntry.hex;\n        \n        // Get RGB9 values from the color\n        const rgb9 = utils.hexToRgb9(hexColor);\n        \n        // Convert to ZX Next hardware bytes format\n        // Format: %RRRGGGBB,%P000000B\n        const r9 = rgb9.r9;\n        const g9 = rgb9.g9;\n        const b9 = rgb9.b9;\n        \n        // Calculate first byte: RRRGGGBB\n        const byte1 = ((r9 & 0x7) << 5) | ((g9 & 0x7) << 2) | ((b9 & 0x6) >> 1);\n        // Calculate second byte: P000000B (where P is priority bit)\n        const byte2 = ((colorEntry.priority ? 1 : 0) << 7) | (b9 & 0x1);\n        \n        // Convert to binary strings for display\n        const byte1Binary = byte1.toString(2).padStart(8, '0');\n        const byte2Binary = byte2.toString(2).padStart(8, '0');\n\n        if (domElements.hoverPreviewBox) domElements.hoverPreviewBox.style.backgroundColor = hexColor;\n        if (domElements.hoverRawValue) domElements.hoverRawValue.textContent = rawValue.toString();\n        if (domElements.hoverPaletteIndex) domElements.hoverPaletteIndex.textContent = finalPaletteIndex.toString();\n        if (domElements.hoverHexValue) domElements.hoverHexValue.textContent = hexColor;\n        \n        // Update byte display elements\n        const hoverByte1 = document.getElementById('hoverByte1');\n        const hoverByte2 = document.getElementById('hoverByte2');\n        \n        if (hoverByte1) hoverByte1.textContent = byte1Binary;\n        if (hoverByte2) hoverByte2.textContent = byte2Binary;\n        \n        if (domElements.hoverInfoContainer) domElements.hoverInfoContainer.style.display = 'flex'; \n        \n        if (finalPaletteIndex < appState.palette.visibleSize) {\n            const currentSwatch = domElements.palettePicker?.querySelector(`.color-swatch[data-color-index=\"${finalPaletteIndex}\"]`);\n            currentSwatch?.classList.add('hover-highlight');\n            localState.currentlyHoverHighlightedIndex = finalPaletteIndex;\n        }\n    } else {\n        if (domElements.hoverPreviewBox) domElements.hoverPreviewBox.style.backgroundColor = 'transparent';\n        if (domElements.hoverRawValue) domElements.hoverRawValue.textContent = '--';\n        if (domElements.hoverPaletteIndex) domElements.hoverPaletteIndex.textContent = '--';\n        if (domElements.hoverHexValue) domElements.hoverHexValue.textContent = '--';\n        \n        // Clear byte display elements\n        const hoverByte1 = document.getElementById('hoverByte1');\n        const hoverByte2 = document.getElementById('hoverByte2');\n        \n        if (hoverByte1) hoverByte1.textContent = '-';\n        if (hoverByte2) hoverByte2.textContent = '-';\n    }\n}\n\nfunction handleDetailGridLeave(event) {\n    if (localState.currentlyHoverHighlightedIndex !== -1) {\n        const prevSwatch = domElements.palettePicker?.querySelector(`.color-swatch[data-color-index=\"${localState.currentlyHoverHighlightedIndex}\"]`);\n        prevSwatch?.classList.remove('hover-highlight');\n        localState.currentlyHoverHighlightedIndex = -1;\n    }\n    if (domElements.hoverPreviewBox) domElements.hoverPreviewBox.style.backgroundColor = 'transparent';\n    if (domElements.hoverRawValue) domElements.hoverRawValue.textContent = '--';\n    if (domElements.hoverPaletteIndex) domElements.hoverPaletteIndex.textContent = '--';\n    if (domElements.hoverHexValue) domElements.hoverHexValue.textContent = '--';\n    \n    // Clear byte display elements\n    const hoverByte1 = document.getElementById('hoverByte1');\n    const hoverByte2 = document.getElementById('hoverByte2');\n    \n    if (hoverByte1) hoverByte1.textContent = '-';\n    if (hoverByte2) hoverByte2.textContent = '-';\n}\n\n// Add this function to analyze colors and offer palette reduction\nfunction analyzeAndReducePalette() {\n    if (!appState.spriteData || !appState.spriteData.sprites || appState.spriteData.sprites.length === 0) {\n        console.log('[Color Analysis] No sprite data available');\n        return;\n    }\n\n    console.log('[Color Analysis] Starting color analysis...');\n    // Create a Set to track unique color indices used in sprites\n    const usedColorIndices = new Set();\n    \n    // Scan all sprites for unique colors\n    appState.spriteData.sprites.forEach(sprite => {\n        if (sprite && sprite.pixels) {\n            // For each pixel in the sprite, add its color index to the set\n            sprite.pixels.forEach(colorIndex => {\n                // For 4-bit sprites, we need to adjust for the palette offset\n                let actualIndex = colorIndex;\n                if (appState.viewState.mode === 'sprite4' || appState.viewState.mode === 'tile8x8') {\n                    actualIndex = appState.viewState.paletteOffset + colorIndex;\n                }\n                usedColorIndices.add(actualIndex);\n            });\n        }\n    });\n    \n    // Convert set to array and sort\n    const uniqueColors = Array.from(usedColorIndices).sort((a, b) => a - b);\n    const totalColors = uniqueColors.length;\n    \n    console.log(`[Color Analysis] Found ${totalColors} unique colors: ${uniqueColors.join(', ')}`);\n    \n    // Create notification to ask user if they want to reduce the palette\n    if (totalColors < appState.palette.current.length) {\n        // Using vscode dialogs, ask user if they want to reduce the palette\n        vscode.postMessage({\n            command: 'showConfirmDialog',\n            title: 'Palette Reduction',\n            message: `Found ${totalColors} unique colors in sprites. Reduce palette to only used colors?`,\n            uniqueColors: uniqueColors, // Pass the unique colors to the provider\n            totalPaletteSize: appState.palette.current.length\n        });\n    } else {\n        // Already using exactly the needed colors\n        vscode.postMessage({\n            command: 'showInfoMessage',\n            message: `Found ${totalColors} unique colors. All current palette entries are in use.`\n        });\n    }\n}\n\nfunction handleKeyDown(event, appState, domElements, utils, vscode) {\n    if (!appState.spriteData || !appState.viewState) return;\n\n    const currentSelection = appState.viewState.currentSprite;\n    const numSprites = appState.spriteData.count;\n    let newIndex = currentSelection;\n    const SPRITES_PER_ROW = 16; // Assume 16 sprites per row for up/down navigation\n\n    if (event.key === 'ArrowLeft') {\n        newIndex = Math.max(0, currentSelection - 1);\n    } else if (event.key === 'ArrowRight') {\n        newIndex = Math.min(numSprites - 1, currentSelection + 1);\n    } else if (event.key === 'ArrowUp') {\n        newIndex = Math.max(0, currentSelection - SPRITES_PER_ROW);\n    } else if (event.key === 'ArrowDown') {\n        newIndex = Math.min(numSprites - 1, currentSelection + SPRITES_PER_ROW);\n    } else if (event.key.toLowerCase() === 'f') {\n        // Toggle fill mode\n        const fillButton = domElements.transformControls?.querySelector('button[data-action=\"fill\"]');\n        if (fillButton) {\n            fillButton.click(); // Simulate click to use existing toggle logic\n        }\n        event.preventDefault();\n        return; // Prevent further processing\n    } else if (event.key.toLowerCase() === 'c') {\n        // Activate color replace mode while 'c' is held\n        if (!localState.isColorReplaceActive) {\n            localState.isColorReplaceActive = true;\n            console.log('[Webview Handlers] Color replace mode activated');\n            \n            // Add visual feedback\n            if (domElements.mainSpriteDetailContainer) {\n                domElements.mainSpriteDetailContainer.classList.add('color-replace-mode');\n                domElements.mainSpriteDetailContainer.style.cursor = 'crosshair';\n            }\n        }\n        event.preventDefault();\n        return;\n    } else if (event.key.toLowerCase() === 'p') {\n        // Toggle priority for the currently selected primary color\n        if (domElements.primaryPriorityFlag) {\n            domElements.primaryPriorityFlag.click(); // Simulate click\n        }\n        event.preventDefault();\n        return;\n    } else if (event.key.toLowerCase() === 'r') {\n        // Analyze and reduce palette\n        vscode.postMessage({ command: 'analyzeDuplicates' }); // Or a more specific command if needed\n        event.preventDefault();\n        return;\n    }\n\n    if (newIndex !== currentSelection) {\n        appState.viewState.currentSprite = newIndex;\n\n        // Redraw the sprite grid to update selection and brush highlights\n        const spriteListContainer = domElements.spriteListContainer;\n        if (spriteListContainer && appState.spriteData && appState.palette) {\n            redrawSpriteGrid(spriteListContainer, appState.spriteData, appState.viewState, appState.palette.current, vscode, appState);\n        }\n\n        // Update detail view\n        const detailContainer = domElements.mainSpriteDetailContainer;\n        if (detailContainer && appState.spriteData && appState.palette) {\n            redrawDetailView(detailContainer, appState.spriteData, appState.viewState, appState.palette.current, !utils.isDefaultPaletteActive());\n        }\n        \n        vscode.postMessage({ command: 'viewSprite', index: newIndex });\n        event.preventDefault(); // Prevent default arrow key behavior (scrolling)\n    } else if (event.key === '+') { // Add new sprite on '+'\n        // Find the \"Add New Sprite\" button and simulate a click\n        const addSpriteButton = document.querySelector('.add-sprite-box');\n        if (addSpriteButton) {\n            addSpriteButton.click();\n        }\n        event.preventDefault();\n    } else if (event.ctrlKey && event.shiftKey && event.key === 'Delete') {\n        // Remove current sprite\n        if (appState.spriteData && typeof appState.viewState.currentSprite === 'number') {\n            vscode.postMessage({ command: 'removeSprite', index: appState.viewState.currentSprite });\n        }\n        event.preventDefault();\n    }\n}\n\nfunction handleTransform(action) {\n    if (!appState.spriteData || !appState.viewState || appState.viewState.currentSprite >= appState.spriteData.sprites.length) return;\n\n    const brush = appState.viewState.spriteBrush || { width: 1, height: 1 };\n    const SPRITES_PER_ROW = 16;\n    const topLeftSpriteIndex = appState.viewState.currentSprite;\n    const refSprite = appState.spriteData.sprites[topLeftSpriteIndex]; // For getting width/height\n\n    if (!refSprite) return;\n    const singleSpriteWidth = refSprite.width;\n    const singleSpriteHeight = refSprite.height;\n\n    console.log(`[Webview Handlers] Applying transform: ${action} to brush starting at sprite ${topLeftSpriteIndex}, brush size ${brush.width}x${brush.height}`);\n\n    const spritesToTransformInfo = []; // Store { index, newPixels, newWidth, newHeight }\n    let anySpriteChanged = false;\n\n    if (action === 'fill') {\n        // Fill mode is just a toggle, actual fill happens on mousedown\n        localState.isFillModeActive = !localState.isFillModeActive;\n        const fillButton = document.querySelector('#transformControls button[data-action=\"fill\"]');\n        if (fillButton) {\n            fillButton.classList.toggle('active', localState.isFillModeActive);\n            fillButton.setAttribute('aria-pressed', localState.isFillModeActive.toString());\n        }\n        \n        if (domElements.mainSpriteDetailContainer) {\n            if (localState.isFillModeActive) {\n                domElements.mainSpriteDetailContainer.classList.add('fill-mode');\n                domElements.mainSpriteDetailContainer.style.cursor = 'crosshair';\n            } else {\n                domElements.mainSpriteDetailContainer.classList.remove('fill-mode');\n                domElements.mainSpriteDetailContainer.style.cursor = '';\n            }\n        }\n        \n        if (localState.isFillModeActive) localState.isDrawing = false;\n        console.log(`[Webview Handlers] Fill mode ${localState.isFillModeActive ? 'activated' : 'deactivated'}`);\n        return; // Exit after toggling fill mode\n    }\n\n    // For brush-level transforms, treat entire brush as one unified pixel grid\n    if (['flipH', 'flipV', 'scrollL', 'scrollR', 'scrollU', 'scrollD', 'rotateLeft', 'rotateRight'].includes(action)) {\n        \n        if (['flipH', 'flipV', 'scrollL', 'scrollR', 'scrollU', 'scrollD', 'rotateLeft', 'rotateRight'].includes(action)) {\n            // UNIFIED PIXEL GRID operations: Treat entire brush as one large pixel grid\n            const totalWidth = brush.width * singleSpriteWidth;\n            const totalHeight = brush.height * singleSpriteHeight;\n            \n            // Collect all pixels into one large array\n            const combinedPixels = new Array(totalWidth * totalHeight);\n            \n            // Fill the combined pixel array from individual sprites\n            for (let brushRow = 0; brushRow < brush.height; brushRow++) {\n                for (let brushCol = 0; brushCol < brush.width; brushCol++) {\n                    const spriteIndex = topLeftSpriteIndex + (brushRow * brush.width) + brushCol;\n                    if (spriteIndex >= 0 && spriteIndex < appState.spriteData.count) {\n                        const sprite = appState.spriteData.sprites[spriteIndex];\n                        if (sprite && sprite.pixels && Array.isArray(sprite.pixels)) {\n                            // Copy sprite pixels to the correct position in combined array\n                            for (let spriteY = 0; spriteY < singleSpriteHeight; spriteY++) {\n                                for (let spriteX = 0; spriteX < singleSpriteWidth; spriteX++) {\n                                    const spritePixelIndex = spriteY * singleSpriteWidth + spriteX;\n                                    const globalX = brushCol * singleSpriteWidth + spriteX;\n                                    const globalY = brushRow * singleSpriteHeight + spriteY;\n                                    const globalPixelIndex = globalY * totalWidth + globalX;\n                                    combinedPixels[globalPixelIndex] = sprite.pixels[spritePixelIndex];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // Apply transform to the entire combined pixel array\n            let transformedPixels;\n            try {\n                switch (action) {\n                    case 'flipH':\n                        transformedPixels = flipHorizontal(combinedPixels, totalWidth, totalHeight);\n                        break;\n                    case 'flipV':\n                        transformedPixels = flipVertical(combinedPixels, totalWidth, totalHeight);\n                        break;\n                    case 'scrollL':\n                        transformedPixels = scrollHorizontal(combinedPixels, totalWidth, totalHeight, -1);\n                        break;\n                    case 'scrollR':\n                        transformedPixels = scrollHorizontal(combinedPixels, totalWidth, totalHeight, 1);\n                        break;\n                    case 'scrollU':\n                        transformedPixels = scrollVertical(combinedPixels, totalWidth, totalHeight, -1);\n                        break;\n                    case 'scrollD':\n                        transformedPixels = scrollVertical(combinedPixels, totalWidth, totalHeight, 1);\n                        break;\n                    case 'rotateLeft':\n                        if (totalWidth === totalHeight) {\n                            const rotateResult = rotateCounterClockwise(combinedPixels, totalWidth, totalHeight);\n                            transformedPixels = rotateResult.newPixels;\n                        } else {\n                            vscode.postMessage({ command: 'showInfoMessage', message: 'Rotation can only be applied to square brush areas.' });\n                            return;\n                        }\n                        break;\n                    case 'rotateRight':\n                        if (totalWidth === totalHeight) {\n                            const rotateResult = rotateClockwise(combinedPixels, totalWidth, totalHeight);\n                            transformedPixels = rotateResult.newPixels;\n                        } else {\n                            vscode.postMessage({ command: 'showInfoMessage', message: 'Rotation can only be applied to square brush areas.' });\n                            return;\n                        }\n                        break;\n                }\n            } catch (error) {\n                console.error(`[Webview Handlers] Error applying brush-wide transform ${action}:`, error);\n                return;\n            }\n            \n            // Split the transformed pixels back into individual sprites\n            for (let brushRow = 0; brushRow < brush.height; brushRow++) {\n                for (let brushCol = 0; brushCol < brush.width; brushCol++) {\n                    const spriteIndex = topLeftSpriteIndex + (brushRow * brush.width) + brushCol;\n                    if (spriteIndex >= 0 && spriteIndex < appState.spriteData.count) {\n                        const newSpritePixels = new Array(singleSpriteWidth * singleSpriteHeight);\n                        \n                        // Extract pixels for this sprite from the transformed array\n                        for (let spriteY = 0; spriteY < singleSpriteHeight; spriteY++) {\n                            for (let spriteX = 0; spriteX < singleSpriteWidth; spriteX++) {\n                                const globalX = brushCol * singleSpriteWidth + spriteX;\n                                const globalY = brushRow * singleSpriteHeight + spriteY;\n                                const globalPixelIndex = globalY * totalWidth + globalX;\n                                const spritePixelIndex = spriteY * singleSpriteWidth + spriteX;\n                                newSpritePixels[spritePixelIndex] = transformedPixels[globalPixelIndex];\n                            }\n                        }\n                        \n                        spritesToTransformInfo.push({\n                            index: spriteIndex,\n                            pixels: newSpritePixels,\n                            width: singleSpriteWidth,\n                            height: singleSpriteHeight\n                        });\n                        anySpriteChanged = true;\n                    }\n                }\n            }\n        }\n    } else {\n        // Handle individual sprite transforms (clear, rotate, etc.)\n        for (let r = 0; r < brush.height; r++) {\n            for (let c = 0; c < brush.width; c++) {\n                const spriteIndex = topLeftSpriteIndex + (r * brush.width) + c;\n                if (spriteIndex >= 0 && spriteIndex < appState.spriteData.count) {\n                    const sprite = appState.spriteData.sprites[spriteIndex];\n                    if (!sprite || !sprite.pixels || !Array.isArray(sprite.pixels)) continue;\n                    if (sprite.width !== singleSpriteWidth || sprite.height !== singleSpriteHeight) continue;\n\n                    let newPixels = null;\n\n                    try {\n                        switch (action) {\n                            case 'clear':\n                                {\n                                    let valueToStore = 0;\n                                    const primaryIndex = appState.selection.primaryColorIndex;\n                                    if (appState.viewState.mode === 'sprite4' || appState.viewState.mode === 'tile8x8') {\n                                        const baseOffset = appState.viewState.paletteOffset;\n                                        if (primaryIndex >= baseOffset && primaryIndex < baseOffset + 16) {\n                                            valueToStore = primaryIndex - baseOffset;\n                                        } else {\n                                            if (r === 0 && c === 0) {\n                                                vscode.postMessage({\n                                                    command: 'showColorOutOfBankWarning',\n                                                    selectedColorIndex: primaryIndex,\n                                                    paletteOffset: baseOffset,\n                                                    mode: appState.viewState.mode\n                                                });\n                                            }\n                                            valueToStore = 0;\n                                        }\n                                    } else {\n                                        valueToStore = primaryIndex;\n                                    }\n                                    newPixels = new Array(sprite.width * sprite.height).fill(valueToStore);\n                                }\n                                break;\n                            case 'rotateLeft':\n                                if (sprite.width === sprite.height) {\n                                    const rotationResult = rotateCounterClockwise(sprite.pixels, sprite.width, sprite.height);\n                                    newPixels = rotationResult.newPixels;\n                                } else {\n                                    if (r === 0 && c === 0) {\n                                        vscode.postMessage({ command: 'showInfoMessage', message: 'Rotation can only be applied to square sprites.' });\n                                    }\n                                }\n                                break;\n                            case 'rotateRight':\n                                if (sprite.width === sprite.height) {\n                                    const rotationResult = rotateClockwise(sprite.pixels, sprite.width, sprite.height);\n                                    newPixels = rotationResult.newPixels;\n                                } else {\n                                    if (r === 0 && c === 0) {\n                                        vscode.postMessage({ command: 'showInfoMessage', message: 'Rotation can only be applied to square sprites.' });\n                                    }\n                                }\n                                break;\n                            default:\n                                console.warn('[Webview Handlers] Unknown transform action:', action);\n                        }\n\n                        if (newPixels && Array.isArray(newPixels)) {\n                            spritesToTransformInfo.push({\n                                index: spriteIndex,\n                                pixels: newPixels,\n                                width: sprite.width,\n                                height: sprite.height\n                            });\n                            anySpriteChanged = true;\n                        }\n                    } catch (error) {\n                        console.error(`[Webview Handlers] Error applying transform ${action} to sprite ${spriteIndex}:`, error);\n                        if (r === 0 && c === 0) {\n                            vscode.postMessage({ command: 'showInfoMessage', message: `Failed to apply ${action}: ${error.message}`});\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (anySpriteChanged) {\n        spritesToTransformInfo.forEach(info => {\n            const sprite = appState.spriteData.sprites[info.index];\n            sprite.pixels = info.pixels;\n            sprite.width = info.width; \n            sprite.height = info.height;\n            vscode.postMessage({ \n                command: 'updateSpritePixels', \n                spriteIndex: info.index, \n                pixels: sprite.pixels,\n                skipVsCodeDirtyNotification: true // Don't notify VSCode of dirty state\n            });\n        });\n\n        utils.markAsDirty(); // Mark main dirty state once (internal only)\n        utils.requestFullRedraw(); // Redraw everything after all sprites in brush are updated\n    }\n}\n\n/**\n * Handles mouseover events on palette swatches to show detailed color information\n */\nfunction handlePaletteHover(event) {\n    const swatch = event.target.closest('.color-swatch');\n    if (!swatch) return;\n    \n    // The tooltip is already defined in the HTML via the title attribute\n    // But we can add a CSS class to enhance the visual feedback\n    swatch.classList.add('palette-hover');\n}\n\n/**\n * Removes hover styling from palette swatches\n */\nfunction handlePaletteLeave(event) {\n    const swatch = event.target.closest('.color-swatch');\n    if (swatch) {\n        swatch.classList.remove('palette-hover');\n    }\n}\n\n// --- NEW: Sprite Drag Handlers ---\n\nfunction handleSpriteDragStart(event) {\n    const spriteBox = event.target.closest('.sprite-box');\n    if (!spriteBox) return;\n    \n    localState.draggedSpriteIndex = parseInt(spriteBox.dataset.index, 10);\n    event.dataTransfer.effectAllowed = 'move';\n    // Set dummy data for Firefox compatibility\n    event.dataTransfer.setData('text/plain', localState.draggedSpriteIndex.toString()); \n    \n    // Add timeout to allow the browser to render the drag image before adding class\n    setTimeout(() => {\n        spriteBox.classList.add('dragging-sprite'); \n    }, 0);\n    \n    console.log(`[Webview Handlers] Sprite Drag Start: index=${localState.draggedSpriteIndex}`);\n}\n\nfunction handleSpriteDragOver(event) {\n    event.preventDefault(); // Necessary to allow dropping\n    event.dataTransfer.dropEffect = 'move';\n    \n    const targetBox = event.target.closest('.sprite-box');\n    const addBox = event.target.closest('.add-sprite-box');\n    \n    // Remove previous drag-over class\n    document.querySelectorAll('.sprite-box.drag-over-sprite').forEach(box => box.classList.remove('drag-over-sprite'));\n    \n    if (targetBox && parseInt(targetBox.dataset.index, 10) !== localState.draggedSpriteIndex) {\n        targetBox.classList.add('drag-over-sprite');\n    } else if (addBox) {\n        // Handle dragging over the 'add' box if needed (e.g., move to end)\n        // addBox.classList.add('drag-over-sprite'); // Optional visual cue\n    }\n}\n\nfunction handleSpriteDragLeave(event) {\n    const targetBox = event.target.closest('.sprite-box');\n    if (targetBox) {\n        targetBox.classList.remove('drag-over-sprite');\n    }\n    const addBox = event.target.closest('.add-sprite-box');\n    if (addBox) {\n        // addBox.classList.remove('drag-over-sprite'); // Optional visual cue\n    }\n}\n\nfunction handleSpriteDrop(event) {\n    event.preventDefault();\n    const targetBox = event.target.closest('.sprite-box');\n    const sourceIndex = localState.draggedSpriteIndex;\n    let targetIndex = -1;\n\n    if (targetBox) {\n        targetIndex = parseInt(targetBox.dataset.index, 10);\n    } else {\n        // Dropped outside a valid sprite box (e.g., in gap or on add button)\n        // Assume drop at the end if not on a specific sprite box\n        targetIndex = appState.spriteData.count; // Place after the last sprite\n    }\n\n    // Clean up visual styles\n    document.querySelectorAll('.sprite-box.drag-over-sprite').forEach(box => box.classList.remove('drag-over-sprite'));\n    const draggingElement = document.querySelector('.sprite-box.dragging-sprite');\n    if (draggingElement) draggingElement.classList.remove('dragging-sprite');\n\n    console.log(`[Webview Handlers] Sprite Drop: source=${sourceIndex}, target=${targetIndex}`);\n\n    if (sourceIndex === -1 || targetIndex === -1 || sourceIndex === targetIndex) {\n        console.log('[Webview Handlers] Sprite drop cancelled: Invalid indices or dropped on self.');\n        localState.draggedSpriteIndex = -1;\n        return;\n    }\n\n    // --- Reordering Logic ---\n    // Send message to extension to handle the actual reordering\n    vscode.postMessage({\n        command: 'reorderSprites',\n        sourceIndex: sourceIndex,\n        targetIndex: targetIndex \n    });\n\n    // --- Optimistic UI Update (Optional but recommended for responsiveness) ---\n    // 1. Find the sprite object being moved\n    const movedSprite = appState.spriteData.sprites.find(s => s.index === sourceIndex);\n    if (!movedSprite) {\n        console.error(\"Could not find sprite to move in local state!\");\n        localState.draggedSpriteIndex = -1;\n        return;\n    }\n    \n    // 2. Create a temporary ordered list based on current visual order\n    const spriteBoxes = Array.from(domElements.spriteListContainer.querySelectorAll('.sprite-box'));\n    let currentOrderIndices = spriteBoxes.map(box => parseInt(box.dataset.index, 10));\n    \n    // 3. Find the current visual positions\n    const currentVisualSourcePos = currentOrderIndices.indexOf(sourceIndex);\n    let currentVisualTargetPos = currentOrderIndices.indexOf(targetIndex);\n    \n    // If dropping onto the gap *after* the target sprite, adjust the target position\n    // We need to determine if the drop point is in the first or second half of the target box.\n    if (targetBox) {\n        const rect = targetBox.getBoundingClientRect();\n        const dropX = event.clientX;\n        const dropY = event.clientY; // Use clientY as sprites stack vertically in grid\n        \n        // Assuming grid layout, check if drop is past the midpoint vertically or horizontally depending on layout\n        // Let's keep it simple: if dropping on a box, insert *before* it.\n        // If the calculated targetIndex was the last sprite, adjust target position accordingly.\n        if(targetIndex === appState.spriteData.count) {\n           currentVisualTargetPos = currentOrderIndices.length; // Insert at the end\n        }\n        // Else: currentVisualTargetPos is already correct (index of the element we drop onto)\n    } else {\n         // Dropped outside a sprite box, assume end\n         currentVisualTargetPos = currentOrderIndices.length;\n    }\n\n\n    // 4. Remove from old visual position and insert into new visual position\n    currentOrderIndices.splice(currentVisualSourcePos, 1);\n    // Adjust target position if source was before target\n    const adjustedTargetPos = currentVisualSourcePos < currentVisualTargetPos ? currentVisualTargetPos -1 : currentVisualTargetPos;\n    currentOrderIndices.splice(adjustedTargetPos, 0, sourceIndex); \n\n    // 5. Update the appState.spriteData.sprites array based on the *new visual order*\n    // It's crucial that the local appState reflects the order the extension will create\n    const newSpritesArray = [];\n    let currentOriginalIndex = 0;\n    const spritesCopy = [...appState.spriteData.sprites]; // Work with a copy\n    \n    // Find the sprite object being moved\n    const spriteToMove = spritesCopy.find(s => s.index === sourceIndex);\n    if (!spriteToMove) {\n        console.error(\"Could not find sprite object for source index:\", sourceIndex);\n        localState.draggedSpriteIndex = -1;\n        return; // Exit if sprite not found\n    }\n\n    // Remove the sprite from its original position in the copy\n    const originalPosition = spritesCopy.indexOf(spriteToMove);\n    if (originalPosition > -1) {\n        spritesCopy.splice(originalPosition, 1);\n    } else {\n        console.error(\"Could not find sprite object to remove at original position for index:\", sourceIndex);\n         localState.draggedSpriteIndex = -1;\n        return; // Exit if sprite not found\n    }\n\n    // Find the sprite that will be *after* the moved sprite in the new order\n    // The target index needs to relate to the original indices *before* the move.\n    let effectiveTargetIndex = targetIndex;\n    // Adjust target index if source was before target in the original array\n    if (originalPosition < effectiveTargetIndex) {\n        effectiveTargetIndex--;\n    }\n\n    // Insert the sprite at the new position in the copy\n    spritesCopy.splice(effectiveTargetIndex, 0, spriteToMove);\n    \n    // Re-index the sprites array sequentially\n    spritesCopy.forEach((sprite, newIdx) => {\n        sprite.index = newIdx; // Update the index property\n    });\n\n    // Update the main sprites array and count\n    appState.spriteData.sprites = spritesCopy;\n    appState.spriteData.count = spritesCopy.length;\n\n    // Adjust the currently selected sprite index if it was affected by the reorder\n    if (appState.viewState.currentSprite === sourceIndex) {\n        // If the dragged sprite was selected, update selection to its new index\n        appState.viewState.currentSprite = spritesCopy.findIndex(s => s === spriteToMove); // Find new index\n    } else {\n        // If another sprite was selected, find its new index\n        const selectedSpriteOriginalIndex = appState.viewState.currentSprite;\n        const selectedSpriteObject = spritesCopy.find(s => {\n             // This logic is tricky because original indices are lost after re-indexing.\n             // We need a way to track the *object* that was originally selected.\n             // For now, let's assume the message to the extension handles selection update correctly.\n             // Or, we can just re-select based on the original index, which might be wrong after reorder.\n             // Safest bet: let the 'update' message from the provider fix the selection.\n             // TODO: Improve selection tracking during reorder if needed.\n        });\n       // if(selectedSpriteObject) {\n       //     appState.viewState.currentSprite = selectedSpriteObject.index;\n       // }\n    }\n\n\n    // 6. Redraw the UI based on the new appState\n    utils.requestFullRedraw(); \n    // --- End Optimistic Update ---\n\n    // Mark as dirty (let the extension handle this via the message)\n    // utils.markAsDirty(false); // Sprite change\n\n    // Reset state\n    localState.draggedSpriteIndex = -1;\n}\n\nfunction handleSpriteDragEnd(event) {\n    // Clean up visual styles in case drop didn't happen correctly\n    const draggingElement = document.querySelector('.sprite-box.dragging-sprite');\n    if (draggingElement) draggingElement.classList.remove('dragging-sprite');\n    document.querySelectorAll('.sprite-box.drag-over-sprite').forEach(box => box.classList.remove('drag-over-sprite'));\n    \n    // Reset state if it wasn't reset by drop\n    if (localState.draggedSpriteIndex !== -1) {\n        console.log('[Webview Handlers] Sprite Drag End (cleanup)');\n        localState.draggedSpriteIndex = -1;\n    }\n}\n\n// --- End Sprite Drag Handlers ---\n\n// --- Main Setup Function --- \n\nexport function setupEventListeners(passedAppState, passedDomElements, passedUtils, vsCodeApi) {\n    console.log(\"[Webview Handlers] >>> setupEventListeners START\"); // <<< ADDED LOG\n    // Store references\n    appState = passedAppState;\n    domElements = passedDomElements;\n    utils = passedUtils;\n    vscode = vsCodeApi;\n    \n    // console.log(\"[Webview Handlers] Received appState object\");\n    // console.log(\"[Webview Handlers] Received domElements:\", domElements ? Object.keys(domElements) : null);\n    // console.log(\"[Webview Handlers] Received utils:\", utils ? Object.keys(utils) : null);\n    // console.log(\"[Webview Handlers] Received vscode:\", !!vscode);\n\n    // Reset local state on setup\n    localState = {\n        isDrawing: false, lastDrawnPixelIndex: -1, draggedIndex: -1, drawButton: 0,\n        editTimeout: null, isCopyingColor: false, colorCopySourceIndex: -1,\n        colorUpdateTimeout: null, lastMessageTime: 0, isSwappingColor: false,\n        currentlyHoverHighlightedIndex: -1, isFillModeActive: false,\n        ctrlDragActive: false, ctrlDragSourceIndex: -1, ctrlDragTargetIndex: -1,\n        dragDisabledSwatch: null, // Store swatch element when disabling draggable\n        isColorReplaceActive: false\n    };\n\n    // --- Add global event listeners to track Ctrl key ---\n    document.addEventListener('keydown', (event) => {\n        if (event.key === 'Control') {\n            // Add class to all color swatches to indicate we're in swap mode\n            document.querySelectorAll('.color-swatch').forEach(\n                swatch => swatch.classList.add('ctrl-hover')\n            );\n        }\n    });\n    \n    document.addEventListener('keyup', (event) => {\n        if (event.key === 'Control') {\n            // Remove class from all color swatches\n            document.querySelectorAll('.color-swatch').forEach(\n                swatch => swatch.classList.remove('ctrl-hover')\n            );\n            \n            // Also cancel any active Ctrl+LMB drag operation\n            if (localState.ctrlDragActive) {\n                cancelCtrlDrag();\n            }\n        }\n    });\n\n    // --- Attach Global Palette Drag-Drop Handlers ---\n    document.addEventListener('dragend', handleDragEnd);\n    \n    // --- Check for palette element ---\n    const palettePicker = document.getElementById('palettePicker');\n    if (palettePicker) {\n        // Add event delegation for palette operations\n        palettePicker.addEventListener('dragover', handleDragOver);\n        palettePicker.addEventListener('dragleave', handleDragLeave);\n        \n        // Add palette hover events\n        palettePicker.addEventListener('mouseover', handlePaletteHover);\n        palettePicker.addEventListener('mouseout', handlePaletteLeave);\n\n        // Add Ctrl+LMB drag handlers for color swapping\n        palettePicker.addEventListener('mousedown', handleCtrlMouseDown);\n        palettePicker.addEventListener('mousemove', handleCtrlMouseMove);\n        palettePicker.addEventListener('mouseup', handleCtrlMouseUp);\n        \n        // Cancel Ctrl+LMB drag if mouse leaves palette area\n        palettePicker.addEventListener('mouseleave', () => {\n            if (localState.ctrlDragActive) {\n                cancelCtrlDrag();\n            }\n        });\n        \n        // Add global mouseup listener to handle case where mouse is released outside palette\n        document.addEventListener('mouseup', (event) => {\n            if (localState.ctrlDragActive) {\n                handleCtrlMouseUp(event);\n            }\n        });\n        \n        // Add global keyup listener to handle case where Ctrl key is released during drag\n        document.addEventListener('keyup', (event) => {\n            if (event.key === 'Control' && localState.ctrlDragActive) {\n                cancelCtrlDrag();\n            }\n        });\n        \n        // Handle dragstart at the container level\n        palettePicker.addEventListener('dragstart', (event) => {\n            // Don't start drag if Ctrl is pressed (we'll use our custom drag)\n            if (event.ctrlKey) {\n                event.preventDefault();\n                event.stopPropagation();\n                return;\n            }\n            \n            const swatch = event.target.closest('.color-swatch');\n            if (swatch) {\n                const index = parseInt(swatch.dataset.colorIndex, 10);\n                if (!isNaN(index)) {\n                    // Store the dragged index locally AND in window state\n                    localState.draggedIndex = index;\n                    localState.isSwappingColor = event.ctrlKey;\n                    \n                    // Set data for the drag operation\n                    event.dataTransfer.effectAllowed = 'move';\n                    event.dataTransfer.setData('text/plain', index.toString());\n                    swatch.classList.add('dragging');\n                    \n                    console.log(`[Webview Handlers] Drag started for color ${index}, CTRL: ${event.ctrlKey}`);\n                }\n            }\n        }, { capture: true });  // Add capture: true to handle the event before it bubbles\n        \n        // Handle contextmenu (right-click) to initiate copy state\n        palettePicker.addEventListener('contextmenu', (event) => {\n            event.preventDefault();\n            const swatch = event.target.closest('.color-swatch');\n            if (swatch) {\n                const index = parseInt(swatch.dataset.colorIndex, 10);\n                if (!isNaN(index)) {\n                    // Always select the color as secondary on right-click\n                    utils.selectSecondaryColor(index);\n                    \n                    // Only set up copy drag state if CTRL is pressed\n                    if (event.ctrlKey) {\n                        // Set up color copy state for CTRL+RMB drag\n                        if (!window.colorCopyState) window.colorCopyState = {};\n                        window.colorCopyState.isCopying = true;\n                        window.colorCopyState.sourceIndex = index;\n                        window.colorCopyState.isCopyDrag = true;\n                        \n                        // Show visual feedback that color is picked up\n                        swatch.classList.add('color-pickup');\n                        \n                        // Show notification\n                        const notification = document.createElement('div');\n                        notification.className = 'color-copy-notification';\n                        notification.textContent = `Color ${index} picked up - drag to copy`;\n                        notification.style.position = 'fixed';\n                        notification.style.top = `${event.clientY + 20}px`;\n                        notification.style.left = `${event.clientX + 10}px`;\n                        notification.style.backgroundColor = 'var(--vscode-editor-background)';\n                        notification.style.color = 'var(--vscode-editor-foreground)';\n                        notification.style.padding = '5px 10px';\n                        notification.style.borderRadius = '3px';\n                        notification.style.border = '1px solid var(--vscode-widget-border)';\n                        notification.style.zIndex = '1000';\n                        notification.style.pointerEvents = 'none';\n                        notification.id = 'color-copy-notification';\n                        \n                        // Remove any existing notification\n                        const existingNotification = document.getElementById('color-copy-notification');\n                        if (existingNotification) {\n                            existingNotification.remove();\n                        }\n                        \n                        document.body.appendChild(notification);\n                        \n                        console.log(`[Webview Handlers] CTRL+Right-click on color ${index} - ready for drag copy`);\n                    } else {\n                        // Regular right-click should not initiate copy state\n                        if (window.colorCopyState) {\n                            window.colorCopyState.isCopying = false;\n                            window.colorCopyState.sourceIndex = -1;\n                            window.colorCopyState.isCopyDrag = false;\n                        }\n                        \n                        console.log(`[Webview Handlers] Right-click selected color ${index} as secondary`);\n                    }\n                }\n            }\n        });\n        \n        // Handle mousemove to track CTRL+RMB drag operation\n        palettePicker.addEventListener('mousemove', (event) => {\n            // Only process if CTRL is still held down\n            if (window.colorCopyState && window.colorCopyState.isCopying && window.colorCopyState.isCopyDrag && event.ctrlKey) {\n                // RMB drag operation\n                const swatch = event.target.closest('.color-swatch');\n                \n                // Update notification position\n                const notification = document.getElementById('color-copy-notification');\n                if (notification) {\n                    notification.style.top = `${event.clientY + 20}px`;\n                    notification.style.left = `${event.clientX + 10}px`;\n                }\n                \n                // Remove previous target highlights\n                document.querySelectorAll('.color-swatch.copy-target').forEach(\n                    sw => sw.classList.remove('copy-target')\n                );\n                \n                if (swatch) {\n                    // Add visual feedback for the target\n                    swatch.classList.add('copy-target');\n                    \n                    const targetIndex = parseInt(swatch.dataset.colorIndex, 10);\n                    if (!isNaN(targetIndex) && targetIndex !== window.colorCopyState.sourceIndex) {\n                        // Update notification text\n                        if (notification) {\n                            notification.textContent = `Copy color ${window.colorCopyState.sourceIndex} to ${targetIndex}`;\n                        }\n                    }\n                }\n            } else if (window.colorCopyState && window.colorCopyState.isCopying && !event.ctrlKey) {\n                // CTRL was released, cancel the operation\n                cancelColorCopy();\n            }\n        });\n        \n        // Add helper function for canceling color copy\n        function cancelColorCopy() {\n            if (window.colorCopyState && window.colorCopyState.isCopying) {\n                window.colorCopyState.isCopying = false;\n                window.colorCopyState.sourceIndex = -1;\n                window.colorCopyState.isCopyDrag = false;\n                \n                // Remove visual feedback\n                document.querySelectorAll('.color-swatch.color-pickup').forEach(\n                    sw => sw.classList.remove('color-pickup')\n                );\n                document.querySelectorAll('.color-swatch.copy-target').forEach(\n                    sw => sw.classList.remove('copy-target')\n                );\n                \n                // Remove notification\n                const notification = document.getElementById('color-copy-notification');\n                if (notification) {\n                    notification.remove();\n                }\n                \n                console.log('[Webview Handlers] Color copy operation canceled');\n            }\n        }\n        \n        // Handle mouseup for completing the color copy\n        palettePicker.addEventListener('mouseup', (event) => {\n            // Only handle right mouse button (2) and if we're in a copy operation\n            if (event.button === 2 && window.colorCopyState && window.colorCopyState.isCopying && window.colorCopyState.isCopyDrag) {\n                const swatch = event.target.closest('.color-swatch');\n                if (swatch) {\n                    const sourceIndex = window.colorCopyState.sourceIndex;\n                    const targetIndex = parseInt(swatch.dataset.colorIndex, 10);\n                    \n                    if (!isNaN(sourceIndex) && !isNaN(targetIndex) && sourceIndex !== targetIndex) {\n                        console.log(`[Webview Handlers] CTRL+Right drag copy from ${sourceIndex} to ${targetIndex}`);\n                        \n                        if (utils.isDefaultPaletteActive()) {\n                            vscode.postMessage({ command: 'promptEditDefaultPalette' });\n                        } else if (targetIndex >= 256) {\n                            console.log('[Webview Handlers] Color copy cancelled: Target index beyond 256-color limit.');\n                        } else {\n                            const sourceColor = appState.palette.current[sourceIndex];\n                            if (sourceColor) {\n                                // Extend the palette if needed (if copying to index beyond current length)\n                                if (targetIndex >= appState.palette.current.length) {\n                                    // Pad the palette with black colors up to the target index\n                                    while (appState.palette.current.length <= targetIndex) {\n                                        appState.palette.current.push({ hex: '#000000', priority: false });\n                                    }\n                                    console.log(`[Webview Handlers] Extended palette to index ${targetIndex} for color copy`);\n                                }\n                                \n                                // Send message to main script to update state & trigger redraw\n                                vscode.postMessage({\n                                    command: 'paletteEdit',\n                                    index: targetIndex,\n                                    newHexColor: sourceColor.hex,\n                                    newPriority: sourceColor.priority\n                                });\n                                \n                                // Update local state immediately\n                                if (appState.palette.current[targetIndex]) {\n                                    appState.palette.current[targetIndex].hex = sourceColor.hex;\n                                    appState.palette.current[targetIndex].priority = sourceColor.priority;\n                                    \n                                    // Update tooltip for the swatch with color information\n                                    // Extract RGB components from hex\n                                    const r = parseInt(sourceColor.hex.substring(1, 3), 16);\n                                    const g = parseInt(sourceColor.hex.substring(3, 5), 16);\n                                    const b = parseInt(sourceColor.hex.substring(5, 7), 16);\n                                    \n                                    // Get RGB9 values\n                                    const rgb9 = utils.hexToRgb9(sourceColor.hex);\n                                    \n                                    // Calculate RGB9 bytes\n                                    const r9 = rgb9.r9;\n                                    const g9 = rgb9.g9;\n                                    const b9 = rgb9.b9;\n                                    \n                                    // Calculate RGB9 bytes for tooltip\n                                    const rgb9Byte1 = ((r9 & 0x7) << 5) | ((g9 & 0x7) << 2) | ((b9 & 0x3) >> 1);\n                                    const rgb9Byte2 = ((b9 & 0x1) << 7) | (sourceColor.priority ? 0x80 : 0);\n                                    \n                                    // Update the tooltip\n                                    swatch.title = `Index: ${targetIndex}\nHex: ${sourceColor.hex}\nRGB9 bytes: (${rgb9Byte1}, ${rgb9Byte2})\nRGB9: (${r9},${g9},${b9})\nRGB24: (${r},${g},${b})\nPriority: ${sourceColor.priority}`;\n                                }\n                                \n                                utils.markAsDirty(true); // Mark palette as dirty only\n                                swatch.style.backgroundColor = sourceColor.hex;\n                                \n                                // If we extended the palette, we need to update visible size\n                                if (targetIndex >= appState.palette.visibleSize) {\n                                    // Expand the visible palette size to include the new color\n                                    const newSize = Math.min(256, Math.max(appState.palette.visibleSize, targetIndex + 1));\n                                    appState.palette.visibleSize = newSize;\n                                    \n                                    // Update the palette size selector if it exists\n                                    const paletteSizeSelect = document.getElementById('paletteSizeSelect');\n                                    if (paletteSizeSelect) {\n                                        // Find or create an option for this size\n                                        let found = false;\n                                        for (let i = 0; i < paletteSizeSelect.options.length; i++) {\n                                            if (parseInt(paletteSizeSelect.options[i].value) === newSize) {\n                                                paletteSizeSelect.selectedIndex = i;\n                                                found = true;\n                                                break;\n                                            }\n                                        }\n                                        \n                                        if (!found && newSize !== 256) {\n                                            // Create a new option\n                                            const newOption = document.createElement('option');\n                                            newOption.value = newSize.toString();\n                                            newOption.text = `First ${newSize}`;\n                                            \n                                            // Insert in correct order\n                                            let inserted = false;\n                                            for (let i = 0; i < paletteSizeSelect.options.length; i++) {\n                                                const optionValue = parseInt(paletteSizeSelect.options[i].value);\n                                                if (optionValue > newSize) {\n                                                    paletteSizeSelect.add(newOption, paletteSizeSelect.options[i]);\n                                                    paletteSizeSelect.selectedIndex = i;\n                                                    inserted = true;\n                                                    break;\n                                                }\n                                            }\n                                            \n                                            if (!inserted) {\n                                                paletteSizeSelect.add(newOption);\n                                                paletteSizeSelect.selectedIndex = paletteSizeSelect.options.length - 1;\n                                            }\n                                        }\n                                    }\n                                    \n                                    // Request full redraw to show new visible size\n                                    utils.requestFullRedraw();\n                                }\n                                \n                                // Show feedback notification\n                                const notification = document.getElementById('color-copy-notification');\n                                if (notification) {\n                                    notification.textContent = `Color copied from ${sourceIndex} to ${targetIndex}`;\n                                    // Fade out notification\n                                    setTimeout(() => {\n                                        notification.style.opacity = '0';\n                                        setTimeout(() => notification.remove(), 500);\n                                    }, 1000);\n                                }\n                            }\n                        }\n                    }\n                }\n                \n                // Always clean up after RMB release\n                cancelColorCopy();\n            }\n        });\n        \n        // Add keyboard event to cancel on ESC\n        document.addEventListener('keydown', (event) => {\n            if (event.key === 'Escape' && window.colorCopyState && window.colorCopyState.isCopying) {\n                cancelColorCopy();\n            }\n        });\n        \n        // Add a global mouseup handler to cancel if clicking outside the palette\n        document.addEventListener('mouseup', (event) => {\n            if (event.button === 2 && window.colorCopyState && window.colorCopyState.isCopying) {\n                const isOverPalette = event.target.closest('#palettePicker');\n                if (!isOverPalette) {\n                    cancelColorCopy();\n                }\n            }\n        });\n        \n        // Add global keyup for CTRL release\n        document.addEventListener('keyup', (event) => {\n            if (event.key === 'Control' && window.colorCopyState && window.colorCopyState.isCopying && window.colorCopyState.isCopyDrag) {\n                cancelColorCopy();\n            }\n        });\n        \n        // Handle drop with existing drop handler\n        palettePicker.addEventListener('drop', (event) => {\n            // Use existing handler\n            handleDrop(event);\n        });\n    }\n    \n    // Global mouseup to reset states\n    window.addEventListener('mouseup', (event) => {\n        // Handle right-click copy cancellation\n        if (event.button === 2) {\n            if (window.colorCopyState && window.colorCopyState.isCopying) {\n                const target = event.target.closest('.color-swatch');\n                if (!target) {\n                    console.log('[Webview Handlers] Color copy cancelled - released outside swatch');\n                    window.colorCopyState.isCopying = false;\n                    window.colorCopyState.sourceIndex = -1;\n                }\n            }\n        }\n        \n        // Reset drawing state\n        if (localState.isDrawing && event.button === localState.drawButton) {\n            localState.isDrawing = false;\n        }\n    });\n\n    // --- Attach Sprite Grid Drag-Drop Handlers ---\n    if (domElements.spriteListContainer) {\n        console.log(\"[Webview Handlers] Attaching sprite drag/drop listeners to spriteListContainer\");\n        // Use event delegation on the container\n        domElements.spriteListContainer.addEventListener('dragstart', handleSpriteDragStart);\n        domElements.spriteListContainer.addEventListener('dragover', handleSpriteDragOver);\n        domElements.spriteListContainer.addEventListener('dragleave', handleSpriteDragLeave);\n        domElements.spriteListContainer.addEventListener('drop', handleSpriteDrop);\n        // Add dragend listener directly to the container as well for cleanup\n        domElements.spriteListContainer.addEventListener('dragend', handleSpriteDragEnd); \n    } else {\n        console.warn(\"[Webview Handlers] spriteListContainer not found for sprite drag/drop listeners.\");\n    }\n\n    // --- Attach Listeners --- \n    if (domElements.viewModeSelect) {\n        // console.log(\"[Webview Handlers] Attaching listener to viewModeSelect\");\n        domElements.viewModeSelect.addEventListener('change', e => {\n            const mode = e.target.value;\n            if (domElements.paletteOffsetInput) domElements.paletteOffsetInput.disabled = !['sprite4', 'tile8x8'].includes(mode);\n            vscode.postMessage({ command: 'changeMode', mode });\n        });\n    } else {\n        console.warn(\"[Webview Handlers] viewModeSelect not found\");\n    }\n\n    if (domElements.paletteOffsetInput) {\n        // console.log(\"[Webview Handlers] Attaching listener to paletteOffsetInput\");\n        domElements.paletteOffsetInput.addEventListener('change', e => {\n            let offsetBank = parseInt(e.target.value, 10);\n            if (isNaN(offsetBank) || offsetBank < 0) offsetBank = 0;\n            if (offsetBank > 15) offsetBank = 15;\n            e.target.value = offsetBank.toString();\n            const actualOffset = offsetBank * 16;\n            vscode.postMessage({ command: 'changePaletteOffset', offset: actualOffset });\n        });\n    } else {\n         console.warn(\"[Webview Handlers] paletteOffsetInput not found\");\n    }\n\n    if (domElements.scaleSlider && domElements.scaleValue) {\n        // console.log(\"[Webview Handlers] Attaching listeners to scaleSlider\");\n        domElements.scaleSlider.addEventListener('input', e => {\n            const currentScaleValue = e.target.value;\n            const currentScaleNumber = parseInt(currentScaleValue, 10);\n            domElements.scaleValue.textContent = currentScaleValue + 'x';\n            document.documentElement.style.setProperty('--sprite-scale', currentScaleNumber.toString());\n        });\n        domElements.scaleSlider.addEventListener('change', e => {\n            const scale = parseInt(e.target.value, 10);\n            vscode.postMessage({ command: 'changeScale', scale });\n        });\n    } else {\n         console.warn(\"[Webview Handlers] scaleSlider or scaleValue not found\");\n    }\n\n    if (domElements.gridCheckbox && domElements.spriteListContainer) {\n        domElements.gridCheckbox.addEventListener('change', e => {\n            domElements.spriteListContainer.classList.toggle('show-sprite-borders', e.target.checked);\n            vscode.postMessage({ command: 'toggleGrid', showGrid: e.target.checked });\n        });\n    }\n\n    if (domElements.loadPaletteButton) {\n        domElements.loadPaletteButton.addEventListener('click', () => {\n            vscode.postMessage({ command: 'loadPalette' });\n        });\n    }\n\n    if (domElements.useDefaultPaletteButton) {\n        domElements.useDefaultPaletteButton.addEventListener('click', () => {\n            vscode.postMessage({ command: 'useDefaultPalette' });\n        });\n    }\n\n    // Note: Listeners for sprite boxes are added dynamically in redrawSpriteGrid (in spriteRenderer.js)\n\n    if (domElements.mainSpriteDetailContainer) {\n        // console.log(\"[Webview Handlers] Attaching listeners to mainSpriteDetailContainer\");\n        domElements.mainSpriteDetailContainer.addEventListener('contextmenu', (event) => {\n            event.preventDefault();\n        });\n        \n        domElements.mainSpriteDetailContainer.addEventListener('mousedown', (event) => {\n            if (event.altKey) { // Eyedropper\n                event.preventDefault();\n                if (!appState.spriteData || !appState.palette.current) return;\n\n                const hoveredCompositePixel = event.target.closest('.detail-pixel');\n                if (!hoveredCompositePixel) return;\n\n                const originalSpriteIndexStr = hoveredCompositePixel.dataset.originalSpriteIndex;\n                const localPixelIndexStr = hoveredCompositePixel.dataset.localPixelIndex;\n\n                if (originalSpriteIndexStr === undefined || localPixelIndexStr === undefined) return; // Pixel is a placeholder\n\n                const originalSpriteIndex = parseInt(originalSpriteIndexStr, 10);\n                const localPixelIndex = parseInt(localPixelIndexStr, 10);\n\n                if (isNaN(originalSpriteIndex) || isNaN(localPixelIndex) || originalSpriteIndex < 0 || originalSpriteIndex >= appState.spriteData.count) return;\n                \n                const currentSprite = appState.spriteData.sprites[originalSpriteIndex];\n                if (!currentSprite || localPixelIndex < 0 || localPixelIndex >= currentSprite.pixels.length) return;\n                \n                const rawValue = currentSprite.pixels[localPixelIndex];\n                const finalPaletteIndex = utils.getDisplayColorIndex(rawValue);\n                if (event.button === 0) utils.selectPrimaryColor(finalPaletteIndex);\n                else if (event.button === 2) utils.selectSecondaryColor(finalPaletteIndex);\n                return; \n            } else if (localState.isFillModeActive) { // Fill mode\n                event.preventDefault();\n                if (event.button !== 0 && event.button !== 2) return;\n                \n                const clickedCompositePixel = event.target.closest('.detail-pixel');\n                if (!clickedCompositePixel) return;\n\n                const originalSpriteIndexStr = clickedCompositePixel.dataset.originalSpriteIndex;\n                const localPixelIndexStr = clickedCompositePixel.dataset.localPixelIndex;\n\n                if (originalSpriteIndexStr === undefined || localPixelIndexStr === undefined) return;\n\n                const originalSpriteIndex = parseInt(originalSpriteIndexStr, 10);\n                const localPixelIndex = parseInt(localPixelIndexStr, 10);\n\n                if (isNaN(originalSpriteIndex) || isNaN(localPixelIndex) || originalSpriteIndex < 0 || originalSpriteIndex >= appState.spriteData.count) return;\n\n                const spriteToFill = appState.spriteData.sprites[originalSpriteIndex];\n                if (!spriteToFill || localPixelIndex < 0 || localPixelIndex >= spriteToFill.pixels.length) return;\n\n                // Calculate fill coordinates\n                const spriteWidth = spriteToFill.width;\n                const fillX = localPixelIndex % spriteWidth;\n                const fillY = Math.floor(localPixelIndex / spriteWidth);\n\n                // Get fill color\n                let selectedPaletteIndex = event.button === 2 ? appState.selection.secondaryColorIndex : appState.selection.primaryColorIndex;\n                let fillColor;\n\n                if (appState.viewState.mode === 'sprite4' || appState.viewState.mode === 'tile8x8') {\n                    const baseOffset = appState.viewState.paletteOffset;\n                    if (selectedPaletteIndex >= baseOffset && selectedPaletteIndex < baseOffset + 16) {\n                        fillColor = selectedPaletteIndex - baseOffset;\n                    } else {\n                        vscode.postMessage({\n                            command: 'showColorOutOfBankWarning',\n                            selectedColorIndex: selectedPaletteIndex,\n                            paletteOffset: baseOffset,\n                            mode: appState.viewState.mode\n                        });\n                        return;\n                    }\n                } else {\n                    fillColor = selectedPaletteIndex;\n                }\n\n                // Make a copy of the pixels array for flood fill (since it modifies in-place)\n                const pixelsCopy = [...spriteToFill.pixels];\n                \n                // Perform flood fill (modifies pixelsCopy in-place, returns boolean)\n                const fillHappened = floodFill(pixelsCopy, spriteWidth, spriteToFill.height, fillX, fillY, fillColor);\n                if (fillHappened) {\n                    spriteToFill.pixels = pixelsCopy;\n                    utils.markAsDirty();\n                    \n                    // Update only the affected sprite in grid and detail view, not full redraw\n                    const displayIndex = utils.getDisplayColorIndex(fillColor);\n                    const colorEntry = appState.palette.current[displayIndex];\n                    const hexColor = colorEntry?.hex || '#FF00FF';\n                    \n                    // Update sprite in grid\n                    const gridSpriteBox = document.querySelector(`.sprite-box[data-index=\"${originalSpriteIndex}\"]`);\n                    if (gridSpriteBox) {\n                        const spritePixels = gridSpriteBox.querySelectorAll('.sprite-pixel');\n                        pixelsCopy.forEach((colorIndex, pixelIndex) => {\n                            if (spritePixels[pixelIndex]) {\n                                const displayColorIndex = utils.getDisplayColorIndex(colorIndex);\n                                const pixelColor = appState.palette.current[displayColorIndex]?.hex || '#FF00FF';\n                                spritePixels[pixelIndex].style.backgroundColor = pixelColor;\n                            }\n                        });\n                    }\n                    \n                    // Update detail view\n                    const detailPixels = document.querySelectorAll(`.detail-pixel[data-original-sprite-index=\"${originalSpriteIndex}\"]`);\n                    detailPixels.forEach(detailPixel => {\n                        const localPixelIndex = parseInt(detailPixel.dataset.localPixelIndex, 10);\n                        if (!isNaN(localPixelIndex) && localPixelIndex < pixelsCopy.length) {\n                            const colorIndex = pixelsCopy[localPixelIndex];\n                            const displayColorIndex = utils.getDisplayColorIndex(colorIndex);\n                            const pixelColor = appState.palette.current[displayColorIndex]?.hex || '#FF00FF';\n                            detailPixel.style.backgroundColor = pixelColor;\n                        }\n                    });\n                    \n                    vscode.postMessage({\n                        command: 'updateSpritePixels',\n                        spriteIndex: originalSpriteIndex,\n                        pixels: spriteToFill.pixels,\n                        skipVsCodeDirtyNotification: true\n                    });\n                }\n                return;\n            } else if (localState.isColorReplaceActive) { // Color Replace mode\n                event.preventDefault();\n                if (event.button !== 0 && event.button !== 2) return;\n                \n                const clickedCompositePixel = event.target.closest('.detail-pixel');\n                if (!clickedCompositePixel) return;\n\n                const originalSpriteIndexStr = clickedCompositePixel.dataset.originalSpriteIndex;\n                const localPixelIndexStr = clickedCompositePixel.dataset.localPixelIndex;\n\n                if (originalSpriteIndexStr === undefined || localPixelIndexStr === undefined) return;\n\n                const originalSpriteIndex = parseInt(originalSpriteIndexStr, 10);\n                const localPixelIndex = parseInt(localPixelIndexStr, 10);\n\n                if (isNaN(originalSpriteIndex) || isNaN(localPixelIndex) || originalSpriteIndex < 0 || originalSpriteIndex >= appState.spriteData.count) return;\n\n                const spriteToReplace = appState.spriteData.sprites[originalSpriteIndex];\n                if (!spriteToReplace || localPixelIndex < 0 || localPixelIndex >= spriteToReplace.pixels.length) return;\n\n                // Get the source color index (the color we're clicking on)\n                const sourceColorIndex = spriteToReplace.pixels[localPixelIndex];\n                \n                // Get the target color index (primary or secondary color)\n                let targetColorIndex = event.button === 2 ? appState.selection.secondaryColorIndex : appState.selection.primaryColorIndex;\n                \n                // Handle 4-bit mode color conversion\n                if (appState.viewState.mode === 'sprite4' || appState.viewState.mode === 'tile8x8') {\n                    const baseOffset = appState.viewState.paletteOffset;\n                    if (targetColorIndex >= baseOffset && targetColorIndex < baseOffset + 16) {\n                        targetColorIndex = targetColorIndex - baseOffset;\n                    } else {\n                        vscode.postMessage({\n                            command: 'showColorOutOfBankWarning',\n                            selectedColorIndex: targetColorIndex,\n                            paletteOffset: baseOffset,\n                            mode: appState.viewState.mode\n                        });\n                        return;\n                    }\n                }\n\n                // Only replace if source and target colors are different\n                if (sourceColorIndex !== targetColorIndex) {\n                    const colorChanged = replaceColorInSprite(sourceColorIndex, targetColorIndex, originalSpriteIndex);\n                    \n                    if (colorChanged) {\n                        utils.markAsDirty();\n                        \n                        // Update the visual representation\n                        const targetDisplayIndex = utils.getDisplayColorIndex(targetColorIndex);\n                        const colorEntry = appState.palette.current[targetDisplayIndex];\n                        const hexColor = colorEntry?.hex || '#FF00FF';\n                        \n                        // Update sprite in grid\n                        const gridSpriteBox = document.querySelector(`.sprite-box[data-index=\"${originalSpriteIndex}\"]`);\n                        if (gridSpriteBox) {\n                            const spritePixels = gridSpriteBox.querySelectorAll('.sprite-pixel');\n                            spriteToReplace.pixels.forEach((colorIndex, pixelIndex) => {\n                                if (spritePixels[pixelIndex]) {\n                                    const displayColorIndex = utils.getDisplayColorIndex(colorIndex);\n                                    const pixelColor = appState.palette.current[displayColorIndex]?.hex || '#FF00FF';\n                                    spritePixels[pixelIndex].style.backgroundColor = pixelColor;\n                                }\n                            });\n                        }\n                        \n                        // Update detail view\n                        const detailPixels = document.querySelectorAll(`.detail-pixel[data-original-sprite-index=\"${originalSpriteIndex}\"]`);\n                        detailPixels.forEach(detailPixel => {\n                            const localPixelIndex = parseInt(detailPixel.dataset.localPixelIndex, 10);\n                            if (!isNaN(localPixelIndex) && localPixelIndex < spriteToReplace.pixels.length) {\n                                const colorIndex = spriteToReplace.pixels[localPixelIndex];\n                                const displayColorIndex = utils.getDisplayColorIndex(colorIndex);\n                                const pixelColor = appState.palette.current[displayColorIndex]?.hex || '#FF00FF';\n                                detailPixel.style.backgroundColor = pixelColor;\n                            }\n                        });\n                        \n                        vscode.postMessage({\n                            command: 'updateSpritePixels',\n                            spriteIndex: originalSpriteIndex,\n                            pixels: spriteToReplace.pixels,\n                            skipVsCodeDirtyNotification: true\n                        });\n                        \n                        console.log(`[Webview Handlers] Color ${sourceColorIndex} replaced with ${targetColorIndex} in sprite ${originalSpriteIndex}`);\n                    }\n                }\n                return;\n            } else {\n                // Regular drawing\n                event.preventDefault();\n                if (event.button !== 0 && event.button !== 2) return;\n                localState.isDrawing = true;\n                localState.drawButton = event.button;\n                localState.lastDrawnPixelIndex = -1;\n                drawPixel(event, localState.drawButton);\n            }\n        });\n\n        // Separate handlers for drawing and hovering\n        domElements.mainSpriteDetailContainer.addEventListener('mousemove', (event) => {\n            // Hover logic needs to be adapted for composite view\n            const hoveredPixel = event.target.closest('.detail-pixel');\n            if (hoveredPixel && !localState.isDrawing) {\n                const originalSpriteIndexStr = hoveredPixel.dataset.originalSpriteIndex;\n                const localPixelIndexStr = hoveredPixel.dataset.localPixelIndex;\n                \n                // Only proceed if these data attributes exist (i.e., not a placeholder pixel)\n                if (originalSpriteIndexStr !== undefined && localPixelIndexStr !== undefined) {\n                    const originalSpriteIndex = parseInt(originalSpriteIndexStr, 10);\n                    const localPixelIndex = parseInt(localPixelIndexStr, 10);\n\n                    if (!isNaN(originalSpriteIndex) && !isNaN(localPixelIndex) && \n                        originalSpriteIndex >= 0 && originalSpriteIndex < appState.spriteData.count) {\n                        \n                        const currentSprite = appState.spriteData.sprites[originalSpriteIndex];\n                        if (currentSprite && localPixelIndex >= 0 && localPixelIndex < currentSprite.pixels.length) {\n                            const rawValue = currentSprite.pixels[localPixelIndex];\n                            const finalPaletteIndex = utils.getDisplayColorIndex(rawValue);\n                            const colorEntry = appState.palette.current[finalPaletteIndex] || { hex: '#FF00FF', priority: false };\n                            const hexColor = colorEntry.hex;\n                            const rgb9 = utils.hexToRgb9(hexColor);\n                            const [byte1Val, byte2Val] = rgb9ToBytes(rgb9.r9, rgb9.g9, rgb9.b9, colorEntry.priority); // Assuming rgb9ToBytes takes priority\n\n                            if (domElements.hoverPreviewBox) domElements.hoverPreviewBox.style.backgroundColor = hexColor;\n                            if (domElements.hoverRawValue) domElements.hoverRawValue.textContent = rawValue.toString();\n                            if (domElements.hoverPaletteIndex) domElements.hoverPaletteIndex.textContent = finalPaletteIndex.toString();\n                            if (domElements.hoverHexValue) domElements.hoverHexValue.textContent = hexColor;\n                            if (domElements.hoverByte1) domElements.hoverByte1.textContent = byte1Val.toString(2).padStart(8, '0');\n                            if (domElements.hoverByte2) domElements.hoverByte2.textContent = byte2Val.toString(2).padStart(8, '0');\n                            if (domElements.hoverInfoContainer) domElements.hoverInfoContainer.style.display = 'flex';\n\n                            if (localState.currentlyHoverHighlightedIndex !== -1) {\n                                const prevSwatch = domElements.palettePicker?.querySelector(`.color-swatch[data-color-index=\"${localState.currentlyHoverHighlightedIndex}\"]`);\n                                prevSwatch?.classList.remove('hover-highlight');\n                            }\n                            if (finalPaletteIndex < appState.palette.visibleSize) {\n                                const currentSwatch = domElements.palettePicker?.querySelector(`.color-swatch[data-color-index=\"${finalPaletteIndex}\"]`);\n                                currentSwatch?.classList.add('hover-highlight');\n                                localState.currentlyHoverHighlightedIndex = finalPaletteIndex;\n                            }\n                        } else {\n                            handleDetailGridLeave(); // Clear hover if data invalid\n                        }\n                    } else {\n                        handleDetailGridLeave(); // Clear hover if data invalid\n                    }\n                } else {\n                    handleDetailGridLeave(); // Clear hover if it's a placeholder pixel\n                }\n            } else if (!hoveredPixel && !localState.isDrawing) {\n                 handleDetailGridLeave(); // Clear hover if mouse is not over any pixel\n            }\n\n            // Drawing logic remains largely the same, just calls the modified drawPixel\n            if (localState.isDrawing) {\n                event.preventDefault();\n                drawPixel(event, localState.drawButton);\n            }\n        });\n        \n        // domElements.mainSpriteDetailContainer.addEventListener('mousemove', handleDetailGridHover);\n        domElements.mainSpriteDetailContainer.addEventListener('mouseleave', handleDetailGridLeave);\n        \n        domElements.mainSpriteDetailContainer.addEventListener('mousemove', (event) => {\n            if (localState.isDrawing) {\n                event.preventDefault();\n                drawPixel(event, localState.drawButton);\n            }\n        });\n        \n        // Add mouseleave handler to stop drawing if mouse leaves the container\n        domElements.mainSpriteDetailContainer.addEventListener('mouseleave', (event) => {\n            if (localState.isDrawing) {\n                localState.isDrawing = false;\n            }\n        });\n        \n        // Global mouseup to stop drawing\n        // console.log(\"[Webview Handlers] Attaching global mouseup listener\");\n        window.addEventListener('mouseup', (event) => {\n            if (localState.isDrawing && event.button === localState.drawButton) {\n                localState.isDrawing = false; \n            }\n            // Handle right-click copy cancellation\n            if (localState.isCopyingColor && event.button === 2) {\n                 if (!event.target || !(event.target instanceof Element) || !event.target.closest('.color-swatch')) {\n                    localState.isCopyingColor = false;\n                    localState.colorCopySourceIndex = -1;\n                }\n            }\n        });\n    } else {\n         console.warn(\"[Webview Handlers] mainSpriteDetailContainer not found\");\n    }\n\n    if (domElements.saveButton) {\n        domElements.saveButton.addEventListener('click', () => {\n             // Check the central state directly\n             if (appState.editor.isDirty) { \n                 vscode.postMessage({ command: 'saveChanges' });\n             } else {\n                 // console.log(\"[Webview Handlers] Save button clicked, but no changes detected (appState.editor.isDirty is false).\");\n              }\n         });\n    }\n\n    if (domElements.sliderR && domElements.sliderG && domElements.sliderB) {\n        [domElements.sliderR, domElements.sliderG, domElements.sliderB].forEach(slider => {\n            slider.addEventListener('input', () => {\n                const valueSpanId = 'value' + slider.id.slice(-1);\n                const valueSpan = document.getElementById(valueSpanId);\n                if (valueSpan) valueSpan.textContent = slider.value;\n                // console.log(`[Webview Handlers] Slider input detected: ${slider.id}`); // <<< REMOVE LOG\n                handleColorUpdate();\n            });\n        });\n    }\n\n    if (domElements.colorPickerInput && domElements.sliderR && domElements.sliderG && domElements.sliderB) {\n        domElements.colorPickerInput.addEventListener('input', (event) => {\n            if (utils.isDefaultPaletteActive()) {\n                vscode.postMessage({ command: 'promptEditDefaultPalette' });\n                const activeIndex = appState.selection.editorColorIndex;\n                if(activeIndex !== -1) event.target.value = appState.palette.current[activeIndex];\n                return;\n            }\n            if (appState.selection.editorColorIndex !== appState.selection.primaryColorIndex) {\n                 event.target.value = appState.palette.current[appState.selection.primaryColorIndex];\n                return; \n            }\n            const pickedHexColor = event.target.value;\n            const rgb9 = utils.hexToRgb9(pickedHexColor);\n            const quantizedHexColor = utils.rgb9ToHex(rgb9.r9, rgb9.g9, rgb9.b9);\n            domElements.sliderR.value = rgb9.r9.toString();\n            domElements.sliderG.value = rgb9.g9.toString();\n            domElements.sliderB.value = rgb9.b9.toString();\n            domElements.valueR.textContent = rgb9.r9.toString();\n            domElements.valueG.textContent = rgb9.g9.toString();\n            domElements.valueB.textContent = rgb9.b9.toString();\n            if (pickedHexColor !== quantizedHexColor) event.target.value = quantizedHexColor;\n            handleColorUpdate();\n        });\n    }\n\n    const savePaletteButton = document.getElementById('savePaletteButton');\n    if (savePaletteButton) {\n        savePaletteButton.addEventListener('click', () => {\n            if (!utils.isDefaultPaletteActive()) {\n                vscode.postMessage({ command: 'savePalette' }); \n                // When saving the palette, mark it as clean\n                appState.palette.isDirty = false;\n                savePaletteButton.classList.remove('save-button-dirty');\n            } else {\n                 vscode.postMessage({ command: 'promptEditDefaultPalette' });\n            }\n        });\n    }\n\n    if (domElements.reloadDataButton) {\n        domElements.reloadDataButton.addEventListener('click', () => {\n            // Add a loading indicator and disable the button to prevent multiple clicks\n            const button = domElements.reloadDataButton;\n            if (button.disabled) return; // Prevent multiple clicks\n            \n            // Add visual feedback\n            const originalText = button.textContent;\n            button.textContent = \"Reloading...\";\n            button.disabled = true;\n            \n            // Send reload message to extension\n            vscode.postMessage({ command: 'reloadData' });\n            \n            // Set a timeout to reset button state in case the reload fails\n            setTimeout(() => {\n                button.textContent = originalText;\n                button.disabled = false;\n            }, 5000); // 5 second timeout\n        });\n    }\n\n    if (domElements.paletteSizeSelect) {\n        // console.log(\"[Webview Handlers] Attaching listener to paletteSizeSelect\");\n        domElements.paletteSizeSelect.addEventListener('change', (event) => {\n            const newSize = parseInt(event.target.value, 10);\n            if (!isNaN(newSize)) {\n                appState.palette.visibleSize = newSize;\n                // console.log(`[Webview Handlers] Palette size changed to: ${newSize}`);\n                utils.requestPaletteRedraw();\n            }\n        });\n    } else {\n        console.warn(\"[Webview Handlers] paletteSizeSelect not found\");\n    }\n\n    if (domElements.mergePaletteButton) {\n        domElements.mergePaletteButton.addEventListener('click', () => {\n            if (utils.isDefaultPaletteActive()) {\n                vscode.postMessage({ command: 'promptEditDefaultPalette' });\n                return;\n            }\n            vscode.postMessage({ \n                command: 'requestPaletteMerge',\n                visiblePaletteSize: appState.palette.visibleSize,\n                startIndex: appState.selection.primaryColorIndex\n            });\n        });\n    } else {\n        console.warn(\"[Webview Handlers] mergePaletteButton not found.\");\n    }\n    \n    // Add transform button listeners (assuming #transformControls exists)\n    const transformControls = document.getElementById('transformControls');\n    if (transformControls) {\n        // console.log(\"[Webview Handlers] Attaching listeners to transformControls buttons\");\n        transformControls.querySelectorAll('button').forEach(btn => {\n            // Get action from data-action attribute\n            const action = btn.dataset.action;\n            if (action) {\n                btn.addEventListener('click', () => handleTransform(action));\n            } else {\n                console.warn(`[Webview Handlers] Button missing data-action attribute: ${btn.outerHTML}`);\n            }\n        });\n    } else {\n        console.warn('[Webview Handlers] Could not find #transformControls to attach listeners.');\n    }\n\n    // Attach listeners to dynamically created palette swatches\n    if (domElements.palettePicker) {\n        // console.log(\"[Webview Handlers] Attaching drag/drop listeners to palette swatches\");\n        domElements.palettePicker.querySelectorAll('.color-swatch').forEach(swatch => {\n            // Drag/Drop handlers defined earlier in this file\n            swatch.addEventListener('dragstart', handleDragStart);\n            swatch.addEventListener('dragover', handleDragOver);\n            swatch.addEventListener('dragleave', handleDragLeave);\n            swatch.addEventListener('drop', handleDrop);\n            swatch.addEventListener('dragend', handleDragEnd);\n        });\n    } else {\n        console.warn(\"[Webview Handlers] palettePicker not found for attaching swatch listeners.\");\n    }\n\n    // Keyboard listener\n    // console.log(\"[Webview Handlers] Attaching global keydown listener\");\n    document.addEventListener('keydown', (event) => {\n        console.log(`[Webview] Key pressed: ${event.key}`);\n        handleKeyDown(event, appState, domElements, utils, vscode);\n    });\n    \n    // Add keyup listener to reset color replace mode when 'c' key is released\n    document.addEventListener('keyup', (event) => {\n        if (event.key === 'c' || event.key === 'C') {\n            if (localState.isColorReplaceActive) {\n                localState.isColorReplaceActive = false;\n                console.log('[Webview Handlers] Color replace mode deactivated');\n                \n                // Remove visual feedback\n                if (domElements.mainSpriteDetailContainer) {\n                    domElements.mainSpriteDetailContainer.classList.remove('color-replace-mode');\n                    domElements.mainSpriteDetailContainer.style.cursor = '';\n                }\n            }\n        }\n    });\n\n    // Add listener for palette visibility slider\n    const paletteSizeSlider = document.getElementById('paletteSizeSlider');\n    const paletteSizeValue = document.getElementById('paletteSizeValue');\n    if (paletteSizeSlider && paletteSizeValue) {\n        paletteSizeSlider.addEventListener('input', (e) => {\n            const value = parseInt(e.target.value, 10);\n            paletteSizeValue.textContent = value;\n            appState.palette.visibleSize = value;\n            utils.requestFullRedraw(); // Need to redraw palette picker\n            // No need to message provider for this UI-only change\n        });\n    }\n\n    // Add listener for merge palette button\n    const mergeButton = document.getElementById('mergePaletteButton');\n    if (mergeButton) {\n        mergeButton.addEventListener('click', () => {\n            if (utils.isDefaultPaletteActive()) {\n                vscode.postMessage({ command: 'promptEditDefaultPalette' });\n            } else {\n                vscode.postMessage({ \n                    command: 'mergePalette', \n                    targetOffset: 0, // Example: always merge at start for now\n                    paletteSize: appState.palette.visibleSize // Use visible size\n                }); \n            }\n        });\n    }\n\n    // NEW: Add listener for Primary Priority Checkbox\n    const priorityCheckbox = document.getElementById('primaryPriorityFlag');\n    if (priorityCheckbox) {\n        priorityCheckbox.addEventListener('change', handlePriorityChange);\n    } else {\n        console.warn(\"[Webview Handlers] Primary priority checkbox (#primaryPriorityFlag) not found.\");\n    }\n\n    // --- Initial setup based on passed state ---\n    if (appState.viewState.showGrid && domElements.spriteListContainer) {\n        domElements.spriteListContainer.classList.add('show-sprite-borders');\n    }\n\n    // Add handler for analyze duplicates button\n    const analyzeDuplicatesButton = document.getElementById('analyzeDuplicatesButton');\n    if (analyzeDuplicatesButton) {\n        analyzeDuplicatesButton.addEventListener('click', () => {\n            vsCodeApi.postMessage({ command: 'analyzeDuplicates' });\n        });\n    }\n\n    // console.log(\"[Webview Handlers] Event listeners setup complete.\");\n    console.log(\"[Webview Handlers] >>> setupEventListeners END\"); // <<< ADDED LOG\n\n    // Add listener for sprite brush select\n    if (domElements.spriteBrushSelect) {\n        console.log(\"[Webview Handlers] Attaching listener to spriteBrushSelect\");\n        domElements.spriteBrushSelect.addEventListener('change', e => {\n            const selectedValue = e.target.value; // e.g., \"1x1\", \"1x2\", \"2x2\"\n            const parts = selectedValue.split('x');\n            if (parts.length === 2) {\n                const brushWidth = parseInt(parts[0], 10);\n                const brushHeight = parseInt(parts[1], 10);\n                if (!isNaN(brushWidth) && !isNaN(brushHeight)) {\n                    const newBrush = { width: brushWidth, height: brushHeight };\n                    console.log(`[Webview Handlers] Sprite brush changed to: ${newBrush.width}x${newBrush.height}`);\n                    // Update local appState immediately for responsiveness\n                    if (appState.viewState) {\n                        appState.viewState.spriteBrush = newBrush;\n                    }\n                    // Send message to the extension\n                    vscode.postMessage({\n                        command: 'changeSpriteBrush',\n                        brush: newBrush\n                    });\n                    // The extension will send back an 'update' message with the new viewState,\n                    // which will re-confirm this change and trigger any necessary UI updates\n                    // related to the viewState (though brush size primarily affects drawing logic).\n                } else {\n                    console.warn(\"[Webview Handlers] Invalid sprite brush value parsed:\", selectedValue);\n                }\n            } else {\n                console.warn(\"[Webview Handlers] Invalid sprite brush value format:\", selectedValue);\n            }\n        });\n    } else {\n        console.warn(\"[Webview Handlers] spriteBrushSelect DOM element not found.\");\n    }\n\n    return {\n        domElements,\n        utils,\n        vscode\n    };\n}\n\n// NEW: Handler for priority checkbox change\nfunction handlePriorityChange(event) {\n    // Skip handling if this change was triggered programmatically\n    if (event.target._isBeingUpdatedProgrammatically) {\n        console.log(`[handlePriorityChange] Ignoring event triggered by programmatic update`);\n        return;\n    }\n\n    const isChecked = event.target.checked;\n    const primaryIndex = appState.selection.primaryColorIndex;\n    console.log(`[handlePriorityChange] Priority checkbox changed for index ${primaryIndex} to ${isChecked}`);\n\n    if (utils.isDefaultPaletteActive()) {\n        vscode.postMessage({ command: 'promptEditDefaultPalette' });\n        // Revert checkbox state visually\n        event.target.checked = !isChecked;\n        return;\n    }\n\n    if (primaryIndex >= 0 && primaryIndex < appState.palette.current.length) {\n        // Find the palette entry object and update its priority\n        const colorEntry = appState.palette.current[primaryIndex];\n        if (colorEntry) {\n            console.log(`[handlePriorityChange] Before: priority=${colorEntry.priority}`);\n            colorEntry.priority = isChecked;\n            console.log(`[handlePriorityChange] After: priority=${colorEntry.priority}`);\n            utils.markAsDirty(true); // Mark only the palette as dirty, not the sprite\n            \n            // Send update to extension (reuse paletteEdit)\n            const message = {\n                command: 'paletteEdit',\n                index: primaryIndex,\n                newHexColor: colorEntry.hex, // Send hex as well\n                priority: isChecked        // Include new priority state\n            };\n            console.log(`[handlePriorityChange] Sending paletteEdit message:`, message);\n            vscode.postMessage(message);\n            \n            // Update tooltip of the corresponding swatch\n            const allSwatches = domElements.palettePicker?.querySelectorAll('.color-swatch');\n            let swatch = null;\n            \n            // Find the swatch with the matching index\n            if (allSwatches) {\n                console.log(`[Priority Change] Looking for swatch with index ${primaryIndex} among ${allSwatches.length} swatches`);\n                \n                allSwatches.forEach(sw => {\n                    const swatchIndex = parseInt(sw.dataset.colorIndex, 10);\n                    if (swatchIndex === primaryIndex) {\n                        swatch = sw;\n                        console.log(`[Priority Change] Found matching swatch for index ${primaryIndex}`);\n                    }\n                });\n            }\n            \n            if (swatch) {\n                console.log(`[Priority Change] Updating tooltip for index ${primaryIndex}, priority: ${isChecked}`);\n                \n                // Extract RGB components from hex\n                const r = parseInt(colorEntry.hex.substring(1, 3), 16);\n                const g = parseInt(colorEntry.hex.substring(3, 5), 16);\n                const b = parseInt(colorEntry.hex.substring(5, 7), 16);\n                \n                // Get RGB9 values\n                const rgb9 = utils.hexToRgb9(colorEntry.hex);\n                \n                // Calculate RGB9 bytes\n                const r9 = rgb9.r9;\n                const g9 = rgb9.g9;\n                const b9 = rgb9.b9;\n                \n                // Calculate RGB9 bytes for tooltip\n                const rgb9Byte1 = ((r9 & 0x7) << 5) | ((g9 & 0x7) << 2) | ((b9 & 0x3) >> 1);\n                const rgb9Byte2 = ((b9 & 0x1) << 7) | (isChecked ? 0x80 : 0);\n                \n                // Update the tooltip with all information\n                swatch.title = `Index: ${primaryIndex}\nHex: ${colorEntry.hex}\nRGB9 bytes: (${rgb9Byte1}, ${rgb9Byte2})\nRGB9: (${r9},${g9},${b9})\nRGB24: (${r},${g},${b})\nPriority: ${isChecked}`;\n            }\n        } else {\n            console.warn(`[Webview Handlers] Could not find palette entry for index ${primaryIndex} to update priority.`);\n        }\n    } else {\n        console.warn(`[Webview Handlers] Invalid primary color index (${primaryIndex}) for priority change.`);\n    }\n}\n\n// --- Ctrl+LMB Drag Handlers ---\nfunction handleCtrlMouseDown(event) {\n    // Only process left mouse button (0) with Ctrl key\n    if (event.button !== 0 || !event.ctrlKey) return;\n    \n    const swatch = event.target.closest('.color-swatch');\n    if (!swatch) return;\n    \n    const sourceIndex = parseInt(swatch.dataset.colorIndex, 10);\n    if (isNaN(sourceIndex)) return;\n    \n    // Start the drag operation\n    localState.ctrlDragActive = true;\n    localState.ctrlDragSourceIndex = sourceIndex;\n    \n    // Add visual indicator for dragged swatch\n    swatch.classList.add('ctrl-dragging');\n    \n    // Show visual feedback notification\n    const notification = document.createElement('div');\n    notification.className = 'color-swap-notification';\n    notification.textContent = `Swap color ${sourceIndex} with...`;\n    notification.style.position = 'fixed';\n    notification.style.top = `${event.clientY + 20}px`;\n    notification.style.left = `${event.clientX + 10}px`;\n    notification.style.backgroundColor = 'var(--vscode-editor-background)';\n    notification.style.color = 'var(--vscode-editor-foreground)';\n    notification.style.padding = '5px 10px';\n    notification.style.borderRadius = '3px';\n    notification.style.border = '1px solid var(--vscode-widget-border)';\n    notification.style.zIndex = '1000';\n    notification.style.pointerEvents = 'none';\n    notification.id = 'color-swap-notification';\n    \n    // Remove any existing notification\n    const existingNotification = document.getElementById('color-swap-notification');\n    if (existingNotification) {\n        existingNotification.remove();\n    }\n    \n    document.body.appendChild(notification);\n    \n    console.log(`[Webview Handlers] Ctrl+LMB drag started for color ${sourceIndex}`);\n    \n    // Prevent default to stop regular draggable behavior\n    event.preventDefault();\n    event.stopPropagation();\n    \n    // Disable native dragging for the duration of this operation\n    if (swatch.draggable) {\n        swatch.draggable = false;\n        // Store the swatch reference to re-enable draggable after operation\n        localState.dragDisabledSwatch = swatch;\n    }\n}\n\nfunction handleCtrlMouseMove(event) {\n    if (!localState.ctrlDragActive) return;\n    \n    // Verify Ctrl key is still held down\n    if (!event.ctrlKey) {\n        cancelCtrlDrag();\n        return;\n    }\n    \n    const swatch = event.target.closest('.color-swatch');\n    \n    // Update notification position\n    const notification = document.getElementById('color-swap-notification');\n    if (notification) {\n        notification.style.top = `${event.clientY + 20}px`;\n        notification.style.left = `${event.clientX + 10}px`;\n    }\n    \n    // Remove previous target highlights\n    document.querySelectorAll('.color-swatch.swap-target').forEach(\n        sw => sw.classList.remove('swap-target')\n    );\n    \n    if (swatch) {\n        const targetIndex = parseInt(swatch.dataset.colorIndex, 10);\n        if (!isNaN(targetIndex) && targetIndex !== localState.ctrlDragSourceIndex) {\n            // Add visual feedback for the target\n            swatch.classList.add('swap-target');\n            localState.ctrlDragTargetIndex = targetIndex;\n            \n            // Update notification text\n            if (notification) {\n                notification.textContent = `Swap color ${localState.ctrlDragSourceIndex} with ${targetIndex}`;\n            }\n        } else {\n            localState.ctrlDragTargetIndex = -1;\n        }\n    } else {\n        localState.ctrlDragTargetIndex = -1;\n    }\n}\n\nfunction handleCtrlMouseUp(event) {\n    if (!localState.ctrlDragActive) return;\n    \n    const sourceIndex = localState.ctrlDragSourceIndex;\n    const targetIndex = localState.ctrlDragTargetIndex;\n    \n    if (sourceIndex !== -1 && targetIndex !== -1 && sourceIndex !== targetIndex) {\n        console.log(`[Webview Handlers] Ctrl+LMB drag complete - swapping colors ${sourceIndex} and ${targetIndex}`);\n        \n        if (utils.isDefaultPaletteActive()) {\n            vscode.postMessage({ command: 'promptEditDefaultPalette' });\n        } else {\n            // First store the colors for swapping\n            const sourceColor = { ...appState.palette.current[sourceIndex] };\n            \n            // If we're swapping to a palette index beyond what's loaded, create a black color there\n            if (targetIndex >= appState.palette.current.length) {\n                // Create a new color at the target position if needed\n                while (appState.palette.current.length <= targetIndex) {\n                    appState.palette.current.push({ hex: '#000000', priority: false });\n                }\n                console.log(`[Webview Handlers] Extended palette to index ${targetIndex}`);\n            }\n            \n            const targetColor = { ...appState.palette.current[targetIndex] };\n            \n            // Now perform the swap in the local palette\n            appState.palette.current[sourceIndex] = targetColor;\n            appState.palette.current[targetIndex] = sourceColor;\n            \n            // Swap pixel indices in sprites\n            const modifiedSpriteIndices = utils.swapPixelIndices(sourceIndex, targetIndex);\n            \n            // Update UI - mark sprite as dirty because pixel values change\n            utils.markAsDirty(false); // false = this is a sprite change\n            \n            // Send message to extension to sync state\n            vscode.postMessage({\n                command: 'paletteSwap', \n                indexA: sourceIndex,\n                indexB: targetIndex,\n                newColorA: appState.palette.current[sourceIndex],\n                newColorB: appState.palette.current[targetIndex]\n            });\n            \n            // Send updated sprite data\n            modifiedSpriteIndices.forEach(spriteIdx => {\n                if (appState.spriteData && appState.spriteData.sprites && appState.spriteData.sprites[spriteIdx]) {\n                     vscode.postMessage({\n                         command: 'updateSpritePixels',\n                         spriteIndex: spriteIdx,\n                         pixels: appState.spriteData.sprites[spriteIdx].pixels,\n                         skipVsCodeDirtyNotification: true\n                     });\n                }\n            });\n            \n            // Redraw the UI\n            utils.requestFullRedraw();\n        }\n    }\n    \n    // Clean up\n    cancelCtrlDrag();\n}\n\nfunction cancelCtrlDrag() {\n    if (localState.ctrlDragActive) {\n        // Remove visual indicators\n        document.querySelectorAll('.color-swatch.ctrl-dragging').forEach(\n            sw => sw.classList.remove('ctrl-dragging')\n        );\n        document.querySelectorAll('.color-swatch.swap-target').forEach(\n            sw => sw.classList.remove('swap-target')\n        );\n        \n        // Remove notification\n        const notification = document.getElementById('color-swap-notification');\n        if (notification) {\n            notification.remove();\n        }\n        \n        // Re-enable draggable if it was disabled\n        if (localState.dragDisabledSwatch) {\n            localState.dragDisabledSwatch.draggable = true;\n            localState.dragDisabledSwatch = null;\n        }\n        \n        // Reset state\n        localState.ctrlDragActive = false;\n        localState.ctrlDragSourceIndex = -1;\n        localState.ctrlDragTargetIndex = -1;\n        \n        console.log('[Webview Handlers] Ctrl+LMB drag operation canceled/completed');\n    }\n}","/* eslint-disable curly */\n\n// --- Imports --- \nimport { flipVertical, flipHorizontal, scrollVertical, scrollHorizontal, floodFill } from '../drawingUtils';\nimport { hexToRgb9, rgb9ToHex, rgb9ToBytes, bytesToRgb9, rgbStringToHex } from '../paletteUtils';\nimport { populatePalettePicker, redrawSpriteGrid, redrawDetailView, updateSpritePixelColors } from './spriteRenderer.js';\nimport { setupEventListeners } from './eventHandlers.js'; // Import the setup function\n// --- End Imports --- \n\n// --- Central Application State --- \nlet appState = {\n    spriteData: null, \n    viewState: null, \n    palette: {\n        current: [], \n        isCustom: false, \n        default: [], // Store default palette\n        visibleSize: 256,\n        isDirty: false  // Add separate dirty tracking for palette\n    },\n    selection: {\n        primaryColorIndex: 0,\n        secondaryColorIndex: 0,\n        editorColorIndex: -1,\n    },\n    editor: {\n        isDirty: false,\n    }\n};\n\n// --- Global Element References (REMOVED - Moved inside initializeUI) --- \n/*\nlet scaleSlider, scaleValue, gridCheckbox, paletteOffsetInput, spriteListContainer, \n    mainSpriteDetailContainer, palettePicker, saveButton, viewModeSelect, \n    loadPaletteButton, paletteStatusSpan, useDefaultPaletteButton, primaryColorIndexSpan,\n    primaryPreviewBox, primaryHexValueSpan, secondaryColorIndexSpan, secondaryPreviewBox,\n    secondaryHexValueSpan, colorPickerInput, reloadDataButton, sliderR, sliderG, sliderB,\n    valueR, valueG, valueB, hoverInfoContainer, hoverPreviewBox, hoverRawValue,\n    hoverPaletteIndex, hoverHexValue, paletteSizeSelect, mergePaletteButton;\n*/\n\n(function() {\n    const vscode = acquireVsCodeApi();\n\n    // --- Get DOM Elements (MOVED to initializeUI) --- \n\n    // --- Helper Functions defined within IIFE scope --- \n    // These will now read/write to appState\n\n    function isDefaultPaletteActive() {\n        return !appState.palette.isCustom;\n    }\n\n    function requestFullRedraw() {\n        console.log(\"[Webview Redraw] >>> requestFullRedraw START\"); // <<< ADDED LOG\n        // Get fresh references inside redraw, as elements might be recreated\n        const currentPalettePicker = document.getElementById('palettePicker');\n        const currentSpriteListContainer = document.querySelector('.sprites-grid');\n        const currentMainSpriteDetailContainer = document.querySelector('.detail-container');\n\n        // Call rendering functions, passing appState or relevant parts\n        populatePalettePicker(\n            currentPalettePicker, \n            appState.palette,\n            appState.selection,\n            isDefaultPaletteActive(), \n            selectPrimaryColor, \n            selectSecondaryColor, \n            vscode // Pass vscode API here\n        ); \n        console.log(\"[Webview Redraw] --- requestFullRedraw: Populated Palette Picker\"); // <<< ADDED LOG\n        redrawSpriteGrid(currentSpriteListContainer, appState.spriteData, appState.viewState, appState.palette.current, vscode, appState); // Use appState\n        console.log(\"[Webview Redraw] --- requestFullRedraw: Redrew Sprite Grid\"); // <<< ADDED LOG\n        redrawDetailView(currentMainSpriteDetailContainer, appState.spriteData, appState.viewState, appState.palette.current, isDefaultPaletteActive()); // Use appState\n        console.log(\"[Webview Redraw] --- requestFullRedraw: Redrew Detail View\"); // <<< ADDED LOG\n        \n        // Use refreshPrimaryColorDisplay instead of selectPrimaryColor to ensure the checkbox updates\n        // even when the same color index is selected but the palette has changed\n        refreshPrimaryColorDisplay();\n        selectSecondaryColor(appState.selection.secondaryColorIndex);\n\n        // --- FOUC Fix: Make content visible after drawing ---\n        const mainContent = document.getElementById('mainContentContainer');\n        if (mainContent && mainContent.style.visibility === 'hidden') {\n            mainContent.style.visibility = 'visible';\n            console.log(\"[Webview Redraw] --- Made mainContentContainer visible.\");\n        }\n        // --- End FOUC Fix ---\n        console.log(\"[Webview Redraw] >>> requestFullRedraw END\"); // <<< ADDED LOG\n    }\n    function requestPaletteRedraw() {\n         const currentPalettePicker = document.getElementById('palettePicker');\n         populatePalettePicker(\n             currentPalettePicker, \n             appState.palette,\n             appState.selection,\n             isDefaultPaletteActive(), \n             selectPrimaryColor, \n             selectSecondaryColor, \n             vscode // Pass vscode API here\n         ); \n         // Update previews after redraw\n         refreshPrimaryColorDisplay(); \n         selectSecondaryColor(appState.selection.secondaryColorIndex);\n    }\n\n    // Wrapper for sendColorUpdateToExtension\n    function sendColorUpdateToExtension(colorIndex, hexColor, skipDirtyNotification = false) {\n        if (!skipDirtyNotification) {\n            markAsDirty(true); // This is a palette change only\n        }\n        const colorEntry = appState.palette.current[colorIndex];\n        const messagePayload = {\n            command: 'paletteEdit',\n            index: colorIndex,\n            newHexColor: colorEntry?.hex, // Send hex (safer access)\n            priority: colorEntry?.priority, // Send priority (safer access)\n            skipDirtyNotification: skipDirtyNotification // Add this flag to inform the provider\n        };\n        vscode.postMessage(messagePayload);\n    }\n\n    // Define updateColorPreviews helper\n    function updateColorPreviews(colorIndex, newHexColor) {\n        // Get fresh references\n        const currentPalettePicker = document.getElementById('palettePicker');\n        const currentSpriteListContainer = document.querySelector('.sprites-grid');\n        const currentMainSpriteDetailContainer = document.querySelector('.detail-container');\n        const currentPrimaryPreviewBox = document.getElementById('primaryPreviewBox');\n        const currentPrimaryHexValueSpan = document.getElementById('primaryHexValue');\n        const currentSecondaryPreviewBox = document.getElementById('secondaryPreviewBox');\n        const currentSecondaryHexValueSpan = document.getElementById('secondaryHexValue');\n\n         // Update palette swatch in the grid\n        const swatchInGrid = currentPalettePicker?.querySelector(`.color-swatch[data-color-index=\"${colorIndex}\"]`);\n        if (swatchInGrid) swatchInGrid.style.backgroundColor = newHexColor;\n\n        // Update L/R preview boxes if necessary\n        if(colorIndex === appState.selection.primaryColorIndex) { \n            if (currentPrimaryPreviewBox) currentPrimaryPreviewBox.style.backgroundColor = newHexColor;\n            if (currentPrimaryHexValueSpan) currentPrimaryHexValueSpan.textContent = newHexColor; \n        }\n        if(colorIndex === appState.selection.secondaryColorIndex) { \n             if (currentSecondaryPreviewBox) currentSecondaryPreviewBox.style.backgroundColor = newHexColor;\n            if (currentSecondaryHexValueSpan) currentSecondaryHexValueSpan.textContent = newHexColor; \n        }\n\n        // Update pixels in grid/detail using the renderer function\n        updateSpritePixelColors(\n            currentSpriteListContainer,\n            currentMainSpriteDetailContainer,\n            appState.spriteData, \n            appState.viewState,  \n            appState.palette.current, \n            colorIndex,\n            newHexColor\n        );\n    }\n\n    // Define swapPixelIndices helper\n    function swapPixelIndices(indexA, indexB) {\n        if (!appState.spriteData || !appState.spriteData.sprites) return []; \n        const modifiedSpriteIndices = [];\n        appState.spriteData.sprites.forEach((sprite, spriteIdx) => { \n            let pixelsModified = false;\n            const tempPixels = sprite.pixels.map(pixelValue => {\n                if (pixelValue === indexA) { pixelsModified = true; return indexB; }\n                else if (pixelValue === indexB) { pixelsModified = true; return indexA; }\n                else { return pixelValue; }\n            });\n            if (pixelsModified) {\n                sprite.pixels = tempPixels;\n                modifiedSpriteIndices.push(spriteIdx);\n            }\n        });\n        return modifiedSpriteIndices;\n    }\n\n    // Define updateEditorPanel\n    function updateEditorPanel(colorIndex) {\n        // Get fresh references\n        const currentSliderR = document.getElementById('sliderR');\n        const currentSliderG = document.getElementById('sliderG');\n        const currentSliderB = document.getElementById('sliderB');\n        const currentValueR = document.getElementById('valueR');\n        const currentValueG = document.getElementById('valueG');\n        const currentValueB = document.getElementById('valueB');\n        const currentPrimaryColorHexInput = document.getElementById('primaryColorHex'); // Assuming text input exists\n        const currentColorPickerInput = document.getElementById('colorPickerInput');\n        const currentPriorityCheckbox = document.getElementById('primaryPriorityFlag');\n\n        if (colorIndex < 0 || colorIndex >= appState.palette.current.length) { \n            appState.selection.editorColorIndex = -1; \n            // Optionally clear/disable editor controls\n            return;\n        }\n        appState.selection.editorColorIndex = colorIndex;\n        const colorEntry = appState.palette.current[colorIndex]; // Get PaletteColor object\n        const hexColor = colorEntry.hex;\n        const rgb9 = hexToRgb9(hexColor);\n\n        if(currentSliderR) currentSliderR.value = rgb9.r9.toString();\n        if(currentSliderG) currentSliderG.value = rgb9.g9.toString();\n        if(currentSliderB) currentSliderB.value = rgb9.b9.toString();\n        if(currentValueR) currentValueR.textContent = rgb9.r9.toString();\n        if(currentValueG) currentValueG.textContent = rgb9.g9.toString();\n        if(currentValueB) currentValueB.textContent = rgb9.b9.toString();\n        if(currentColorPickerInput) currentColorPickerInput.value = hexColor;\n        if(currentPrimaryColorHexInput) currentPrimaryColorHexInput.value = hexColor; // Update hex text input\n        if(currentPriorityCheckbox) currentPriorityCheckbox.checked = colorEntry.priority; // Update priority checkbox\n    }\n\n    // Define getDisplayColorIndex helper \n    function getDisplayColorIndex(rawIndex) {\n        if (!appState.viewState || !appState.palette.current) {\n            return 0; // Check appState\n        }\n        const mode = appState.viewState.mode;\n        const offset = appState.viewState.paletteOffset;\n        let finalIndex = rawIndex;\n        if (mode === 'sprite4' || mode === 'tile8x8') {\n            finalIndex = offset + rawIndex;\n        }\n        if (finalIndex < 0 || finalIndex >= appState.palette.current.length) {\n            console.warn(`Calculated display index ${finalIndex} out of bounds for palette length ${appState.palette.current.length}. Raw: ${rawIndex}, Offset: ${offset}`);\n            return 0;\n        }\n        return finalIndex;\n    }\n\n    // New function: Update primary color display without changing selection\n    function refreshPrimaryColorDisplay() {\n        const index = appState.selection.primaryColorIndex;\n        if (index < 0 || index >= appState.palette.current.length) {\n            return;\n        }\n        \n        const colorEntry = appState.palette.current[index];\n        const hexColor = colorEntry.hex;\n        \n        // Get fresh references\n        const currentPrimaryPreviewBox = document.getElementById('primaryPreviewBox');\n        const currentPrimaryHexValueSpan = document.getElementById('primaryHexValue');\n        const primaryR9Value = document.getElementById('primaryR9Value');\n        const primaryG9Value = document.getElementById('primaryG9Value');\n        const primaryB9Value = document.getElementById('primaryB9Value');\n        const primaryPriorityFlag = document.getElementById('primaryPriorityFlag');\n\n        if (currentPrimaryPreviewBox) currentPrimaryPreviewBox.style.backgroundColor = hexColor;\n        if (currentPrimaryHexValueSpan) currentPrimaryHexValueSpan.textContent = hexColor;\n\n        // Update editor panel\n        updateEditorPanel(index);\n\n        // Update 9-bit display and priority checkbox\n        const rgb9 = hexToRgb9(hexColor);\n        if (primaryR9Value) primaryR9Value.textContent = rgb9.r9.toString();\n        if (primaryG9Value) primaryG9Value.textContent = rgb9.g9.toString();\n        if (primaryB9Value) primaryB9Value.textContent = rgb9.b9.toString();\n        \n        // Update priority checkbox with flag to prevent event cycle\n        if (primaryPriorityFlag) {\n            console.log(`[refreshPrimaryColorDisplay] Updating priority checkbox for index ${index} to ${colorEntry.priority}`);\n            primaryPriorityFlag._isBeingUpdatedProgrammatically = true;\n            primaryPriorityFlag.checked = colorEntry.priority;\n            setTimeout(() => {\n                if (primaryPriorityFlag) {\n                    primaryPriorityFlag._isBeingUpdatedProgrammatically = false;\n                }\n            }, 0);\n        }\n    }\n\n    // Define markAsDirty helper with distinction between sprite and palette\n    function markAsDirty(isPaletteChange = false) {\n        if (isPaletteChange) {\n            // Mark palette as dirty\n            if (!appState.palette.isDirty) {\n                appState.palette.isDirty = true;\n                const savePaletteButton = document.getElementById('savePaletteButton');\n                if (savePaletteButton) {\n                    savePaletteButton.classList.add('save-button-dirty');\n                }\n                // Don't update the main save button\n            }\n        } else {\n            // Mark sprite as dirty (original behavior)\n        if (!appState.editor.isDirty) { \n            const saveButton = document.getElementById('saveButton'); // Get fresh reference\n            if (saveButton) {\n                saveButton.disabled = false;\n                saveButton.classList.add('save-button-dirty');\n            }\n            appState.editor.isDirty = true; \n            // Don't notify VSCode of dirty state - only use internal dirty tracking\n            }\n        }\n    }\n\n    // Define selectPrimaryColor and selectSecondaryColor\n    function selectPrimaryColor(index) {\n        if (index === null || index === undefined || index < 0 || index >= appState.palette.current.length) {\n            console.warn(`[Webview] Invalid primary color index: ${index}`);\n            return;\n        }\n        \n        // If this is already the primary color, do nothing\n        if (index === appState.selection.primaryColorIndex) {\n            return;\n        }\n        \n        appState.selection.primaryColorIndex = index;\n        const colorEntry = appState.palette.current[index]; // Get the PaletteColor object\n        const hexColor = colorEntry.hex;\n        \n        // Get fresh references\n        const currentPrimaryPreviewBox = document.getElementById('primaryPreviewBox');\n        const currentPrimaryColorIndexSpan = document.getElementById('primaryColorIndex');\n        const currentPrimaryHexValueSpan = document.getElementById('primaryHexValue');\n        const currentPalettePicker = document.getElementById('palettePicker');\n        // Add references for 9-bit display and priority checkbox\n        const primaryR9Value = document.getElementById('primaryR9Value');\n        const primaryG9Value = document.getElementById('primaryG9Value');\n        const primaryB9Value = document.getElementById('primaryB9Value');\n        const primaryPriorityFlag = document.getElementById('primaryPriorityFlag');\n\n        if (currentPrimaryPreviewBox) currentPrimaryPreviewBox.style.backgroundColor = hexColor;\n        if (currentPrimaryColorIndexSpan) currentPrimaryColorIndexSpan.textContent = index;\n        if (currentPrimaryHexValueSpan) currentPrimaryHexValueSpan.textContent = hexColor;\n        updateEditorPanel(index); // Update sliders/picker when primary changes\n\n        // Update palette picker selection styling\n        if(currentPalettePicker) {\n            // Remove previous primary selection\n            currentPalettePicker.querySelectorAll('.color-swatch.primary-selected').forEach(sw => sw.classList.remove('primary-selected'));\n            // Add new primary selection\n            const selectedSwatch = currentPalettePicker.querySelector(`.color-swatch[data-color-index=\"${index}\"]`);\n            if (selectedSwatch) selectedSwatch.classList.add('primary-selected');\n        }\n\n        // Update 9-bit display and priority checkbox\n        const rgb9 = hexToRgb9(hexColor);\n        if (primaryR9Value) primaryR9Value.textContent = rgb9.r9.toString();\n        if (primaryG9Value) primaryG9Value.textContent = rgb9.g9.toString();\n        if (primaryB9Value) primaryB9Value.textContent = rgb9.b9.toString();\n        \n        // Add a preventEvent flag to the checkbox before changing its state\n        if (primaryPriorityFlag) {\n            // Set a flag directly on the element to indicate programmatic change\n            primaryPriorityFlag._isBeingUpdatedProgrammatically = true;\n            primaryPriorityFlag.checked = colorEntry.priority;\n            // Clear the flag after a short delay to ensure event processing completes\n            setTimeout(() => {\n                if (primaryPriorityFlag) {\n                    primaryPriorityFlag._isBeingUpdatedProgrammatically = false;\n                }\n            }, 0);\n        }\n    }\n\n    function selectSecondaryColor(index) {\n        if (index === null || index === undefined || index < 0 || index >= appState.palette.current.length) {\n            console.warn(`[Webview] Invalid secondary color index: ${index}`);\n            return;\n        }\n        \n        // If this is already the secondary color, do nothing\n        if (index === appState.selection.secondaryColorIndex) {\n            return;\n        }\n        \n        appState.selection.secondaryColorIndex = index; \n        const colorEntry = appState.palette.current[index];\n        const colorHex = colorEntry ? colorEntry.hex : '#000000'; \n        \n        // Get fresh references\n        const currentSecondaryColorIndexSpan = document.getElementById('secondaryColorIndex');\n        const currentSecondaryPreviewBox = document.getElementById('secondaryPreviewBox');\n        const currentSecondaryHexValueSpan = document.getElementById('secondaryHexValue');\n        const currentPalettePicker = document.getElementById('palettePicker');\n        \n        if (currentSecondaryColorIndexSpan) currentSecondaryColorIndexSpan.textContent = index.toString();\n        if (currentSecondaryPreviewBox) currentSecondaryPreviewBox.style.backgroundColor = colorHex;\n        if (currentSecondaryHexValueSpan) currentSecondaryHexValueSpan.textContent = colorHex;\n        \n        // Update palette picker selection styling\n        if(currentPalettePicker) {\n            // Remove previous secondary selection\n            currentPalettePicker.querySelectorAll('.color-swatch.secondary-selected').forEach(sw => sw.classList.remove('secondary-selected'));\n            // Add new secondary selection\n            const selectedSwatch = currentPalettePicker.querySelector(`.color-swatch[data-color-index=\"${index}\"]`);\n            if (selectedSwatch) selectedSwatch.classList.add('secondary-selected');\n        }\n    }\n    \n    // Define handleTransformInternal here \n    function handleTransformInternal(action, sprite) {\n        if (!sprite || !appState.viewState) return; \n        let newPixels = null;\n        const width = sprite.width;\n        const height = sprite.height;\n        const spriteIndex = sprite.index; \n\n        try {\n            switch (action) {\n                case 'flipV': newPixels = flipVertical(sprite.pixels, width, height); break;\n                case 'flipH': newPixels = flipHorizontal(sprite.pixels, width, height); break;\n                case 'clear':\n                    {\n                        let valueToStore = 0;\n                        const primaryIndex = appState.selection.primaryColorIndex; \n                        if (appState.viewState.mode === 'sprite4' || appState.viewState.mode === 'tile8x8') {\n                             const baseOffset = appState.viewState.paletteOffset;\n                             if (primaryIndex >= baseOffset && primaryIndex < baseOffset + 16) {\n                                 valueToStore = primaryIndex - baseOffset;\n                             } else {\n                                 vscode.postMessage({ command: 'showColorOutOfBankWarning', selectedColorIndex: primaryIndex, paletteOffset: baseOffset, mode: appState.viewState.mode });\n                                 valueToStore = 0; \n                             }\n                         } else {\n                             valueToStore = primaryIndex;\n                        }\n                        newPixels = new Array(width * height).fill(valueToStore);\n                    }\n                    break;\n                case 'scrollU': newPixels = scrollVertical(sprite.pixels, width, height, -1); break;\n                case 'scrollD': newPixels = scrollVertical(sprite.pixels, width, height, 1); break;\n                case 'scrollL': newPixels = scrollHorizontal(sprite.pixels, width, height, -1); break;\n                case 'scrollR': newPixels = scrollHorizontal(sprite.pixels, width, height, 1); break;\n                case 'fill':\n                     console.warn(\"handleTransformInternal should not receive 'fill' action.\");\n                    return; \n                default:\n                    console.warn('[Webview JS] Unknown transform action:', action);\n                    return;\n            }\n\n            if (newPixels) {\n                sprite.pixels = newPixels;\n                markAsDirty();\n                requestFullRedraw(); \n                vscode.postMessage({ \n                    command: 'updateSpritePixels', \n                    spriteIndex: spriteIndex, \n                    pixels: sprite.pixels \n                });\n            }\n        } catch (error) {\n            console.error(`[Webview JS] Error applying transform ${action}:`, error);\n            vscode.postMessage({ command: 'showError', message: `Failed to apply ${action}: ${error.message}`}); \n        }\n    }\n    // --- End Helper Functions ---\n\n    // --- NEW HELPER for CSS Update ---\n    function updateDetailPixelSizeCss() {\n        if (appState.viewState && appState.viewState.spriteBrush && appState.spriteData && appState.spriteData.sprites && appState.spriteData.sprites.length > 0) {\n            // Use the dimensions of the *currently selected* sprite for base size calculation if sprites can have variable dimensions.\n            // For now, we assume appState.spriteData.width/height are the relevant base dimensions for the file.\n            const baseSpriteWidth = appState.spriteData.width;\n            const baseSpriteHeight = appState.spriteData.height;\n            \n            const brushW = appState.viewState.spriteBrush.width;\n            const brushH = appState.viewState.spriteBrush.height;\n            let newDetailPixelSize;\n\n            if (brushW === 1 && brushH === 1) {\n                newDetailPixelSize = (baseSpriteWidth === 8 && baseSpriteHeight === 8) ? '30px' : '18px';\n            } else {\n                newDetailPixelSize = (baseSpriteWidth === 8 && baseSpriteHeight === 8) ? '15px' : '10px';\n            }\n            // console.log(`[Webview CSS] Brush: ${brushW}x${brushH}, SpriteBase: ${baseSpriteWidth}x${baseSpriteHeight}, newDetailPixelSize: ${newDetailPixelSize}`);\n            document.documentElement.style.setProperty('--detail-pixel-size', newDetailPixelSize);\n        } else {\n            // console.warn(\"[Webview CSS] Could not update detail pixel size, missing state criteria.\");\n        }\n    }\n    window.updateDetailPixelSizeCss = updateDetailPixelSizeCss; // Expose to renderer via window object\n\n    // --- Initial UI Setup ---\n    function initializeUI() {\n        console.log(\"[Webview Init] >>> initializeUI START\"); // <<< ADDED LOG\n        // Get initial data passed from the extension\n        const initialData = window.initialData;\n        if (!initialData) {\n            console.error('[Webview] Initial data not found!');\n            // Display error message in the webview\n            document.body.innerHTML = '<div style=\"color: red; padding: 20px;\">Error: Failed to load initial sprite data.</div>';\n            return;\n        }\n\n        // Make sure the document body is focusable\n        document.body.setAttribute('tabindex', '0');\n\n        // --- Get DOM Elements AFTER initialData is confirmed ---\n        const scaleSlider = document.getElementById('scaleSlider');\n        const scaleValue = document.getElementById('scaleValue');\n        const gridCheckbox = document.getElementById('showGrid');\n        const paletteOffsetInput = document.getElementById('paletteOffset');\n        const spriteListContainer = document.querySelector('.sprites-grid');\n        const mainSpriteDetailContainer = document.querySelector('.detail-container');\n        const palettePicker = document.getElementById('palettePicker');\n        const saveButton = document.getElementById('saveButton');\n        const viewModeSelect = document.getElementById('viewMode');\n        const loadPaletteButton = document.getElementById('loadPalette');\n        const paletteStatusSpan = document.getElementById('paletteStatus');\n        const useDefaultPaletteButton = document.getElementById('useDefaultPalette');\n        const primaryColorIndexSpan = document.getElementById('primaryColorIndex');\n        const primaryPreviewBox = document.getElementById('primaryPreviewBox');\n        const primaryHexValueSpan = document.getElementById('primaryHexValue');\n        const secondaryColorIndexSpan = document.getElementById('secondaryColorIndex');\n        const secondaryPreviewBox = document.getElementById('secondaryPreviewBox');\n        const secondaryHexValueSpan = document.getElementById('secondaryHexValue');\n        const colorPickerInput = document.getElementById('colorPickerInput');\n        const reloadDataButton = document.getElementById('reloadDataButton');\n        const sliderR = document.getElementById('sliderR');\n        const sliderG = document.getElementById('sliderG');\n        const sliderB = document.getElementById('sliderB');\n        const valueR = document.getElementById('valueR');\n        const valueG = document.getElementById('valueG');\n        const valueB = document.getElementById('valueB');\n        const hoverInfoContainer = document.getElementById('hoverInfoContainer');\n        const hoverPreviewBox = document.getElementById('hoverPreviewBox');\n        const hoverRawValue = document.getElementById('hoverRawValue');\n        const hoverPaletteIndex = document.getElementById('hoverPaletteIndex');\n        const hoverHexValue = document.getElementById('hoverHexValue');\n        const hoverByte1 = document.getElementById('hoverByte1');\n        const hoverByte2 = document.getElementById('hoverByte2');\n        const paletteSizeSelect = document.getElementById('paletteSizeSelect');\n        const mergePaletteButton = document.getElementById('mergePaletteButton');\n        // Add 9-bit display refs\n        const primaryR9Value = document.getElementById('primaryR9Value');\n        const primaryG9Value = document.getElementById('primaryG9Value');\n        const primaryB9Value = document.getElementById('primaryB9Value');\n        const primaryPriorityFlag = document.getElementById('primaryPriorityFlag');\n        const savePaletteButton = document.getElementById('savePaletteButton');\n        const spriteBrushSelect = document.getElementById('spriteBrushSelect');\n\n        const domElements = {\n            scaleSlider, scaleValue, gridCheckbox, paletteOffsetInput, spriteListContainer,\n            mainSpriteDetailContainer, palettePicker, saveButton, viewModeSelect,\n            loadPaletteButton, paletteStatusSpan, useDefaultPaletteButton, primaryColorIndexSpan,\n            primaryPreviewBox, primaryHexValueSpan, secondaryColorIndexSpan, secondaryPreviewBox,\n            secondaryHexValueSpan, colorPickerInput, reloadDataButton, sliderR, sliderG, sliderB,\n            valueR, valueG, valueB, hoverInfoContainer, hoverPreviewBox, hoverRawValue,\n            hoverPaletteIndex, hoverHexValue, paletteSizeSelect, mergePaletteButton,\n            // Add 9-bit refs\n            primaryR9Value, primaryG9Value, primaryB9Value, primaryPriorityFlag, savePaletteButton,\n            hoverByte1, hoverByte2,\n            spriteBrushSelect\n        };\n\n        // Initialize central state (using smallInitialState initially)\n        appState.spriteData = null; // <<< Initialize spriteData as null\n        appState.viewState = initialData.viewState;\n        appState.palette.isCustom = initialData.isCustomPaletteMode;\n        appState.palette.current = initialData.palette; // Assuming initialData.palette is {hex, priority}[]\n        appState.palette.default = initialData.defaultPalette; // Store default\n        appState.selection.primaryColorIndex = 0; \n        appState.selection.secondaryColorIndex = 0; \n        appState.editor.isDirty = initialData.viewState?.isDirty ?? false;\n        // Log the palette state *after* initialization\n        console.log(`[Webview Init] Initialized appState.palette.current. isCustom: ${appState.palette.isCustom}. First 5 entries: ${JSON.stringify(appState.palette.current?.slice(0, 5))}`);\n        console.log(`[Webview Init] Stored appState.palette.default. First 5 entries: ${JSON.stringify(appState.palette.default?.slice(0, 5))}`);\n\n        // Update UI based on initial state\n        console.log(\"[Webview Init] Updating UI elements from initial state...\"); // <<< ADDED LOG\n        if (scaleSlider) scaleSlider.value = appState.viewState.scale.toString();\n        if (scaleValue) scaleValue.textContent = appState.viewState.scale + 'x';\n        if (gridCheckbox) gridCheckbox.checked = appState.viewState.showGrid;\n        if (paletteOffsetInput) {\n            const offsetBank = Math.floor(appState.viewState.paletteOffset / 16); // Calculate bank from offset\n            paletteOffsetInput.value = offsetBank.toString(); \n            paletteOffsetInput.disabled = !['sprite4', 'tile8x8'].includes(appState.viewState.mode);\n        }\n        if (viewModeSelect) viewModeSelect.value = appState.viewState.mode;\n        if (paletteStatusSpan) {\n            const paletteName = initialData.paletteName; // Get name from initial data\n            paletteStatusSpan.textContent = appState.palette.isCustom ? `Palette: ${paletteName}` : 'Default palette';\n            paletteStatusSpan.title = appState.palette.isCustom ? paletteName : '';\n        }\n\n        // Initialize save button states\n        if (saveButton) {\n            saveButton.disabled = !appState.editor.isDirty;\n            saveButton.classList.toggle('save-button-dirty', appState.editor.isDirty);\n        }\n        \n        if (savePaletteButton) { \n             savePaletteButton.disabled = !appState.palette.isCustom;\n            savePaletteButton.classList.toggle('save-button-dirty', appState.palette.isDirty);\n        }\n\n        // Initialize palette size dropdown\n        if (paletteSizeSelect) {\n            paletteSizeSelect.value = appState.palette.visibleSize.toString();\n        }\n\n        // Define utils object to pass to event handlers\n        const utils = {\n            isDefaultPaletteActive: isDefaultPaletteActive,\n            requestFullRedraw: requestFullRedraw,\n            requestPaletteRedraw: requestPaletteRedraw,\n            sendColorUpdateToExtension: sendColorUpdateToExtension,\n            updateColorPreviews: updateColorPreviews,\n            swapPixelIndices: swapPixelIndices,\n            updateEditorPanel: updateEditorPanel,\n            getDisplayColorIndex: getDisplayColorIndex,\n            markAsDirty: markAsDirty,\n            selectPrimaryColor: selectPrimaryColor,\n            selectSecondaryColor: selectSecondaryColor,\n            hexToRgb9: hexToRgb9, // Pass through palette utils\n            rgb9ToHex: rgb9ToHex,\n            rgbStringToHex: rgbStringToHex\n        };\n\n        // Initial UI render\n        console.log(\"[Webview Init] Rendering palette picker...\"); // <<< ADDED LOG\n        populatePalettePicker(palettePicker, appState.palette, appState.selection, isDefaultPaletteActive(), selectPrimaryColor, selectSecondaryColor, vscode);\n        console.log(`[Webview JS - initializeUI] After populatePalettePicker, #palettePicker has ${palettePicker?.childElementCount || 0} children.`); // Log swatch count\n        console.log(\"[Webview Init] Rendering sprite grid...\"); // <<< ADDED LOG\n        redrawSpriteGrid(spriteListContainer, appState.spriteData, appState.viewState, appState.palette.current, vscode, appState);\n        console.log(\"[Webview Init] Rendering detail view...\"); // <<< ADDED LOG\n        redrawDetailView(mainSpriteDetailContainer, appState.spriteData, appState.viewState, appState.palette.current, isDefaultPaletteActive());\n\n        // Select initial colors\n        console.log(\"[Webview Init] Selecting initial colors...\"); // <<< ADDED LOG\n        selectPrimaryColor(0);\n        selectSecondaryColor(1);\n\n        // Set initial dirty state for save button\n        if (saveButton) {\n            saveButton.disabled = !appState.editor.isDirty;\n            saveButton.classList.toggle('save-button-dirty', appState.editor.isDirty);\n        }\n\n        // Request full sprite data from the provider\n        console.log(\"[Webview Init] Requesting full sprite data...\"); // <<< ADDED LOG\n        vscode.postMessage({ command: 'requestFullSpriteData' }); // <<< ADDED REQUEST\n\n        // Setup all event listeners, passing necessary dependencies\n        console.log(\"[Webview Init] Calling setupEventListeners...\");\n        setupEventListeners(appState, domElements, utils, vscode);\n        \n        // Force focus on the document to ensure keyboard events work right away\n        setTimeout(() => {\n            console.log(\"[Webview Init] Setting focus to make keyboard navigation work\");\n            document.body.focus();\n            \n            // Make sure all containers are also focusable\n            const mainContainer = document.getElementById('mainContentContainer');\n            if (mainContainer) {\n                mainContainer.setAttribute('tabindex', '0');\n                mainContainer.focus();\n            }\n            \n            // Also make the sprite detail container focusable\n            const detailContainer = document.querySelector('.detail-container');\n            if (detailContainer) {\n                detailContainer.setAttribute('tabindex', '0');\n            }\n            \n            // Log key event status\n            console.log(\"[Webview Init] Keyboard handlers ready. Press arrow keys to navigate.\");\n        }, 300);\n\n        console.log(\"[Webview Init] >>> initializeUI END\"); // <<< ADDED LOG\n    }\n    // --- End Initial UI Setup ---\n\n    // --- Message Handling from Extension --- \n    window.addEventListener('message', async e => {\n        const message = e.data;\n        \n        // Handle messages from extension\n        switch (message.command) {\n            case 'initialize': \n                console.log('[Webview JS] Received initialize');\n                // Initialize application state with data from extension\n                if (message.initialState) {\n                    // Note: initialState now EXCLUDES spriteData\n                    appState.viewState = message.initialState.viewState;\n                    appState.palette.current = message.initialState.palette;\n                    appState.palette.isCustom = message.initialState.isCustomPaletteMode;\n                    appState.palette.default = message.initialState.defaultPalette;\n                    appState.editor.isDirty = message.initialState.viewState.isDirty; \n                    // Now initialize the UI with the loaded state (spriteData is still null)\n                    initializeUI(); \n                } else {\n                    // Handle case where initial state might be missing\n                    console.error('[Webview JS] Received initialize message but initialState is missing!');\n                    document.body.innerHTML = '<div class=\"error-message\">Error: Missing initial state from extension.</div>';\n                }\n                break;\n            case 'fullSpriteData': // <<< NEW HANDLER\n                console.log('[Webview JS] Received fullSpriteData');\n                if (message.spriteData) {\n                    appState.spriteData = message.spriteData;\n                    console.log(`[Webview JS] Stored full sprite data (${appState.spriteData.count} sprites).`);\n                    // --- FIX: Ensure viewState exists before redrawing ---\n                    if (appState.viewState) {\n                        console.log(\"[Webview JS] viewState exists, triggering redraw.\");\n                        updateDetailPixelSizeCss(); // Call after spriteData is available\n                        requestFullRedraw(); // Redraw UI now that we have sprite data AND viewState\n                    } else {\n                        console.warn(\"[Webview JS] Received fullSpriteData but viewState is still null. Redraw deferred.\");\n                        // Redraw will happen naturally when initializeUI completes if it hasn't already.\n                    }\n                    // --- END FIX ---\n                } else {\n                    console.error('[Webview JS] Received fullSpriteData message but spriteData is missing!');\n                    // Optionally display an error in the UI\n                }\n                break;\n            case 'getViewState':\n                console.log('[Webview JS] Responding to getViewState request');\n                // Send the current view state back to the extension\n                if (appState.viewState) {\n                    vscode.postMessage({\n                        command: 'viewStateResponse',\n                        viewState: {\n                            mode: appState.viewState.mode,\n                            paletteOffset: appState.viewState.paletteOffset,\n                            scale: appState.viewState.scale,\n                            showGrid: appState.viewState.showGrid,\n                            currentSprite: appState.viewState.currentSprite\n                        }\n                    });\n                }\n                break;\n            case 'viewSprite':\n                // Reset fill mode when changing sprites\n                if (window.localState && window.localState.isFillModeActive) {\n                    // Find the fill button and simulate a click to toggle it off\n                    const fillButton = document.querySelector('#transformControls button[data-action=\"fill\"]');\n                    if (fillButton) {\n                        // Call handleTransform directly if it's available globally\n                        if (typeof handleTransform === 'function') {\n                            handleTransform('fill');\n                        } else {\n                            // Otherwise, simulate a click\n                            fillButton.click();\n                        }\n                    }\n                    \n                    // Also manually reset the state and styling as a fallback\n                    const mainSpriteDetailContainer = document.querySelector('.detail-container');\n                    if (mainSpriteDetailContainer) {\n                        mainSpriteDetailContainer.classList.remove('fill-mode');\n                        mainSpriteDetailContainer.style.cursor = '';\n                    }\n                    if (window.localState) {\n                        window.localState.isFillModeActive = false;\n                    }\n                }\n                break;\n            case 'update':\n                console.log(\"[Webview Message] >>> Received 'update' message\", message); // <<< ADDED LOG\n                try {\n                    let isReloadUpdate = false; // Flag to track if this update comes from a reload\n                    if (message.viewState) {\n                        appState.viewState = message.viewState;\n                        appState.editor.isDirty = message.viewState.isDirty;\n                        \n                        // Update UI elements tied to viewState\n                        if (document.getElementById('paletteOffset')) {\n                            document.getElementById('paletteOffset').value = Math.floor(message.viewState.paletteOffset / 16);\n                            document.getElementById('paletteOffset').disabled = !['sprite4', 'tile8x8'].includes(message.viewState.mode);\n                        }\n                        if (document.getElementById('viewMode')) {\n                            document.getElementById('viewMode').value = message.viewState.mode;\n                        }\n                        if (document.getElementById('scaleSlider')) {\n                             document.getElementById('scaleSlider').value = message.viewState.scale.toString();\n                        }\n                        if (document.getElementById('scaleValue')) {\n                             document.getElementById('scaleValue').textContent = message.viewState.scale + 'x';\n                        }\n                        if (document.getElementById('showGrid')) {\n                             document.getElementById('showGrid').checked = message.viewState.showGrid;\n                        }\n                        // Update save button state\n                        const saveButton = document.getElementById('saveButton');\n                        if (saveButton) {\n                             saveButton.disabled = !message.viewState.isDirty;\n                             saveButton.classList.toggle('save-button-dirty', message.viewState.isDirty);\n                        }\n                        // Update sprite brush select if it exists and the value differs\n                        const currentSpriteBrushSelect = document.getElementById('spriteBrushSelect');\n                        if (currentSpriteBrushSelect && message.viewState.spriteBrush) {\n                            const brushValue = `${message.viewState.spriteBrush.width}x${message.viewState.spriteBrush.height}`;\n                            if (currentSpriteBrushSelect.value !== brushValue) {\n                                currentSpriteBrushSelect.value = brushValue;\n                            }\n                        }\n                    }\n                    if (message.spriteData) {\n                        isReloadUpdate = true; // Assume spriteData update means reload\n                        appState.spriteData = message.spriteData;\n                        // If this is from a reload, re-enable the reload button\n                        const reloadButton = document.getElementById('reloadDataButton');\n                        if (reloadButton) {\n                            if (reloadButton.disabled) {\n                                reloadButton.textContent = \"Reload Sprite Data\";\n                                reloadButton.disabled = false;\n                            } \n                        } \n                    } \n                    if (message.palette) {\n                        appState.palette.current = message.palette;\n                        appState.palette.isCustom = true; // Palette update implies custom\n                         const paletteStatusSpan = document.getElementById('paletteStatus');\n                        if (paletteStatusSpan && message.paletteName) paletteStatusSpan.textContent = 'Palette: ' + message.paletteName;\n                        const savePaletteButton = document.getElementById('savePaletteButton');\n                        if (savePaletteButton) savePaletteButton.disabled = false; // Enable save if custom palette loaded\n                        \n                        // Make sure to update the primary color display to reflect potential priority bit changes\n                        refreshPrimaryColorDisplay();\n                    } else if (message.hasOwnProperty('palette') && message.palette === null) {\n                         // Handle switching back to default palette\n                         appState.palette.current = appState.palette.default || [];\n                         appState.palette.isCustom = false;\n                         const paletteStatusSpan = document.getElementById('paletteStatus');\n                         if (paletteStatusSpan) paletteStatusSpan.textContent = 'Default palette';\n                         const savePaletteButton = document.getElementById('savePaletteButton');\n                         if (savePaletteButton) savePaletteButton.disabled = true; // Disable save for default\n                         \n                         // Make sure to update the primary color display to reflect priority bit changes\n                         refreshPrimaryColorDisplay();\n                    }\n                    \n                    // Update detail pixel size based on brush (and potentially new sprite data from reload)\n                    // This replaces the previous inline logic for this\n                    updateDetailPixelSizeCss();\n                    \n                    // Validate current sprite index after potential reload\n                    if (appState.viewState && appState.spriteData && \n                        typeof appState.viewState.currentSprite === 'number') {\n                        if (appState.viewState.currentSprite >= appState.spriteData.count) {\n                            const oldIndex = appState.viewState.currentSprite;\n                            const newIndex = Math.max(0, appState.spriteData.count - 1);\n                            appState.viewState.currentSprite = newIndex;\n                        } \n                    } \n                    \n                    // Full redraw\n                    console.log(\"[Webview Message] --- Calling requestFullRedraw after 'update'\"); // <<< ADDED LOG\n                    requestFullRedraw();\n                    console.log(\"[Webview Message] --- Returned from requestFullRedraw after 'update'\"); // <<< ADDED LOG\n                } catch (error) {\n                    console.error('[Webview JS] Error handling update message:', error);\n                    // Display an error message in the UI if possible\n                    const errorContainer = document.createElement('div');\n                    errorContainer.className = 'error-message';\n                    errorContainer.textContent = `Error updating UI: ${error.message}. Try reopening the file.`;\n                    document.body.prepend(errorContainer);\n                }\n                break;\n            case 'changesSaved':\n                console.log('[Webview JS] Changes saved');\n                if (message.isPaletteChange) {\n                    // Handle palette save\n                    appState.palette.isDirty = false;\n                    const savePaletteButton = document.getElementById('savePaletteButton');\n                    if (savePaletteButton) {\n                        savePaletteButton.classList.remove('save-button-dirty');\n                 }\n                } else {\n                    // Handle sprite save\n                    appState.editor.isDirty = false;\n                    const saveButton = document.getElementById('saveButton');\n                    if (saveButton) {\n                        saveButton.disabled = true;\n                        saveButton.classList.remove('save-button-dirty');\n                    }\n                }\n                break;\n            case 'spritePasted':\n                // Handle specifically targeted update for pasted sprite\n                if (message.targetIndex !== undefined && message.pixels && appState.spriteData && appState.spriteData.sprites) {\n                    const spriteToUpdate = appState.spriteData.sprites.find(s => s.index === message.targetIndex);\n                    if (spriteToUpdate) {\n                        // Replace only the pixel data\n                        spriteToUpdate.pixels = message.pixels;\n                        // Redraw just the sprite grid\n                        const currentSpriteListContainer = document.querySelector('.sprites-grid');\n                        redrawSpriteGrid(currentSpriteListContainer, appState.spriteData, appState.viewState, appState.palette.current, vscode, appState);\n                        \n                        // If this is the currently viewed sprite, also update detail view\n                        if (message.targetIndex === appState.viewState.currentSprite) {\n                            const currentMainSpriteDetailContainer = document.querySelector('.detail-container');\n                            redrawDetailView(currentMainSpriteDetailContainer, appState.spriteData, appState.viewState, appState.palette.current, !appState.palette.isCustom);\n                        }\n                        \n                        // Mark as dirty\n                        appState.editor.isDirty = true;\n                     const saveButton = document.getElementById('saveButton');\n                     if (saveButton) {\n                         saveButton.disabled = false;\n                         saveButton.classList.add('save-button-dirty');\n                     }\n                    }\n                }\n                break;\n            case 'markAsWebviewDirty':\n                // Just mark the webview as dirty (e.g., after adding/removing sprites)\n                     appState.editor.isDirty = true;\n                const saveButtonDirty = document.getElementById('saveButton');\n                if (saveButtonDirty) {\n                    saveButtonDirty.disabled = false;\n                    saveButtonDirty.classList.add('save-button-dirty');\n                }\n                break;\n            case 'dragStarted':\n                // Track drag state for color swatches\n                const { index, isSwapping } = message;\n                console.log(`[Webview JS] Drag started for color ${index}, swapping: ${isSwapping}`);\n                if (typeof index === 'number') {\n                    // Store this in a local state object accessible to the global scope\n                    window.dragState = {\n                        sourceIndex: index,\n                        isSwapping: !!isSwapping\n                    };\n                 }\n                 break;\n            case 'spriteSelected':\n                console.log(`[Webview Message] Received spriteSelected for index ${message.currentSpriteIndex}`);\n                \n                if (appState.viewState) {\n                    // Update the current sprite index in viewState\n                    appState.viewState.currentSprite = message.currentSpriteIndex;\n                    \n                    // Call the CSS update function as the selected sprite (and its base dimensions) might have changed\n                    updateDetailPixelSizeCss(); \n\n                    // Redraw the sprite grid to update selection and brush highlights\n                    const currentSpriteListContainer = document.querySelector('.sprites-grid');\n                    if (currentSpriteListContainer && appState.spriteData) {\n                        redrawSpriteGrid(currentSpriteListContainer, appState.spriteData, appState.viewState, appState.palette.current, vscode, appState);\n                    }\n\n                    // Only update what's necessary:\n                    \n                    // 1. Update the selected sprite in the grid\n                    // const allSpriteBoxes = document.querySelectorAll('.sprite-box');\n                    // allSpriteBoxes.forEach(box => {\n                    //     const boxIndex = parseInt(box.dataset.index, 10);\n                    //     if (boxIndex === message.currentSpriteIndex) {\n                    //         box.classList.add('selected');\n                    //     } else {\n                    //         box.classList.remove('selected');\n                    //     }\n                    // });\n                    \n                    // 2. Update only the detail view with the new sprite\n                    const detailContainer = document.querySelector('.detail-container');\n                    if (detailContainer && appState.spriteData) {\n                        redrawDetailView(\n                            detailContainer, \n                            appState.spriteData, \n                            appState.viewState, \n                            appState.palette.current, \n                            !appState.palette.isCustom\n                        );\n                    }\n                    \n                    // 3. Update detail title\n                    const detailTitle = document.querySelector('.sprite-detail h2');\n                    if (detailTitle) {\n                        detailTitle.textContent = `Sprite ${message.currentSpriteIndex} Detail`;\n                    }\n                }\n                break;\n            case 'highlightDuplicates':\n                if (message.duplicates && Array.isArray(message.duplicates)) {\n                    console.log(`[Webview JS] Received ${message.duplicates.length} duplicates to highlight`);\n                    highlightDuplicateSprites(message.duplicates);\n                } else {\n                    console.error('[Webview JS] Received highlightDuplicates but data is invalid');\n                }\n                break;\n            default:\n                console.log('[Webview JS] Unhandled message:', message);\n        }\n    });\n\n    // Function to highlight duplicate sprites in the grid\n    function highlightDuplicateSprites(duplicates) {\n        // Get all sprite boxes\n        const spriteBoxes = document.querySelectorAll('.sprite-box');\n        \n        // Clear any existing highlights first\n        spriteBoxes.forEach(box => {\n            box.classList.remove('duplicate-exact');\n            box.classList.remove('duplicate-flipped');\n            box.classList.remove('duplicate-rotated');\n            box.removeAttribute('data-original');\n            box.removeAttribute('data-match-type');\n        });\n        \n        // Add highlights for duplicates\n        duplicates.forEach(duplicate => {\n            const originalBox = document.querySelector(`.sprite-box[data-index=\"${duplicate.originalIndex}\"]`);\n            const duplicateBox = document.querySelector(`.sprite-box[data-index=\"${duplicate.duplicateIndex}\"]`);\n            \n            if (originalBox) {\n                originalBox.classList.add('original-sprite');\n            }\n            \n            if (duplicateBox) {\n                // Add highlight class based on match type\n                switch (duplicate.matchType) {\n                    case 'exact':\n                        duplicateBox.classList.add('duplicate-exact');\n                        break;\n                    case 'flippedH':\n                    case 'flippedV':\n                        duplicateBox.classList.add('duplicate-flipped');\n                        break;\n                    case 'rotated180':\n                        duplicateBox.classList.add('duplicate-rotated');\n                        break;\n                }\n                \n                // Store original reference and match type\n                duplicateBox.setAttribute('data-original', duplicate.originalIndex);\n                duplicateBox.setAttribute('data-match-type', duplicate.matchType);\n                \n                // Add tooltip\n                duplicateBox.title = `Duplicate of sprite #${duplicate.originalIndex} (${duplicate.matchType})`;\n            }\n        });\n    }\n\n})(); // End IIFE "],"names":["pixels","width","height","newPixels","Array","length","y","x","originalIndex","amount","actualAmount","newWidth","newHeight","startX","startY","fillColor","startIndex","console","error","targetColor","queue","processedPixels","maxProcess","changed","cx","cy","shift","neighbors","nx","ny","nIndex","push","hexColor","hexClean","startsWith","substring","r9","g9","b9","r8","parseInt","g8","b8","findClosest3BitValue","rgbString","match","r","g","b","toString","padStart","value","rgb9","priority","rrr","ggg","b3bit","rgb9To16BitValue","defaultPaletteRgb","i","rgb3to8Map","rgb9ToHex","rClamped","Math","max","min","round","gClamped","bClamped","value8bit","closestValue","minDifference","Infinity","difference","abs","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","getDisplayColorIndex","rawIndex","currentPalette","viewState","mode","offsetBank","paletteOffset","finalIndex","populatePalettePicker","palettePicker","paletteState","selectionState","isDefaultPaletteActive","selectPrimaryColor","selectSecondaryColor","vscode","log","innerHTML","current","warn","limit","visibleSize","index","color","swatch","document","createElement","className","style","backgroundColor","hex","dataset","colorIndex","draggable","rgb9Byte1","rgb9Byte2","title","primaryColorIndex","classList","add","secondaryColorIndex","addEventListener","event","ctrlKey","preventDefault","window","colorCopyState","isCopying","sourceIndex","appendChild","redrawSpriteGrid","spriteListContainer","spriteData","appState","sprites","brush","spriteBrush","gridColumnCount","gridTemplateColumns","topLeftBrushIndex","currentSprite","floor","forEach","sprite","spriteBox","isActuallyInBrushArea","by","bx","spriteContainer","rawPixelIndex","pixelDiv","displayIndex","spriteIndexDiv","textContent","altKey","postMessage","command","targetIndex","currentSpriteListContainer","querySelector","palette","detailContainer","redrawDetailView","isCustom","shiftKey","addBox","mainSpriteDetailContainer","isDefaultPaletteMode","topLeftSpriteIndex","refSpriteForDim","singleSpriteWidth","singleSpriteHeight","compositeWidthInSprites","compositeHeightInSprites","compositePixelWidth","compositePixelHeight","compositePixels","compositeRow","brushSpriteRow","pixelRowInSprite","brushSpriteCol","actualOriginalSpriteIndex","count","spriteIsValid","pixelColInSprite","pixelIndexInSourceSprite","rawPixelValue","displayPaletteIndex","raw","displayHex","spriteIndex","localPixelIndex","pixelData","originalSpriteIndex","compositePixelIndex","detailInfoDiv","paletteName","statusElement","getElementById","includes","replace","trim","infoText","footerDiv","detailTitleH2","updateDetailPixelSizeCss","updateSpritePixelColors","colorIndexToUpdate","newHexColor","displayIndexToUpdate","spriteBoxes","querySelectorAll","box","isNaN","pixelEl","pixelIdx","localState","isDrawing","lastDrawnPixelIndex","draggedIndex","draggedSpriteIndex","drawButton","editTimeout","isCopyingColor","colorCopySourceIndex","colorUpdateTimeout","lastMessageTime","isSwappingColor","currentlyHoverHighlightedIndex","isFillModeActive","ctrlDragActive","ctrlDragSourceIndex","ctrlDragTargetIndex","dragDisabledSwatch","isColorReplaceActive","domElements","utils","handleDragStart","target","dataTransfer","effectAllowed","setData","handleDragOver","dropEffect","targetSwatch","closest","handleDragLeave","remove","handleDrop","draggingElement","sourceColor","modifiedSpriteIndices","swapPixelIndices","markAsDirty","indexA","indexB","newColorA","newColorB","spriteIdx","skipVsCodeDirtyNotification","requestFullRedraw","splice","handleDragEnd","sw","handleColorUpdate","updateEditorPanel","selection","editorColorIndex","editorActiveIndex","sliderR","sliderG","sliderB","updateColorPreviews","colorPickerInput","primaryColorHexInput","now","Date","sendColorUpdateToExtension","clearTimeout","setTimeout","drawPixel","button","type","clickedCompositePixel","spriteToModify","valueToStore","selectedPaletteIndex","baseOffset","selectedColorIndex","colorEntry","gridPixelBox","gridPixel","editor","isDirty","saveButton","disabled","handleDetailGridLeave","prevSwatch","hoverPreviewBox","hoverRawValue","hoverPaletteIndex","hoverHexValue","hoverByte1","hoverByte2","handlePaletteHover","handlePaletteLeave","handleSpriteDragStart","handleSpriteDragOver","targetBox","handleSpriteDragLeave","handleSpriteDrop","find","s","currentOrderIndices","from","map","currentVisualSourcePos","indexOf","currentVisualTargetPos","getBoundingClientRect","clientX","clientY","adjustedTargetPos","spritesCopy","spriteToMove","originalPosition","effectiveTargetIndex","newIdx","findIndex","handleSpriteDragEnd","setupEventListeners","passedAppState","passedDomElements","passedUtils","vsCodeApi","key","cancelCtrlDrag","cancelColorCopy","isCopyDrag","notification","handleCtrlMouseDown","handleCtrlMouseMove","handleCtrlMouseUp","stopPropagation","capture","position","top","left","padding","borderRadius","border","zIndex","pointerEvents","id","existingNotification","body","newPriority","hexToRgb9","newSize","paletteSizeSelect","found","options","selectedIndex","newOption","text","inserted","opacity","viewModeSelect","e","paletteOffsetInput","actualOffset","offset","scaleSlider","scaleValue","currentScaleValue","currentScaleNumber","documentElement","setProperty","scale","gridCheckbox","toggle","checked","showGrid","loadPaletteButton","useDefaultPaletteButton","hoveredCompositePixel","originalSpriteIndexStr","localPixelIndexStr","rawValue","finalPaletteIndex","spriteToFill","spriteWidth","fillX","fillY","pixelsCopy","gridSpriteBox","spritePixels","pixelIndex","displayColorIndex","pixelColor","detailPixel","spriteToReplace","sourceColorIndex","targetColorIndex","colorChanged","replaceColorInSprite","targetDisplayIndex","hoveredPixel","byte1Val","byte2Val","hoverInfoContainer","display","currentSwatch","Element","slider","valueSpanId","slice","valueSpan","activeIndex","pickedHexColor","quantizedHexColor","valueR","valueG","valueB","savePaletteButton","reloadDataButton","originalText","requestPaletteRedraw","mergePaletteButton","visiblePaletteSize","transformControls","btn","action","refSprite","spritesToTransformInfo","anySpriteChanged","fillButton","setAttribute","cursor","totalWidth","totalHeight","combinedPixels","brushRow","brushCol","isArray","spriteY","spriteX","spritePixelIndex","transformedPixels","message","newSpritePixels","globalPixelIndex","c","primaryIndex","fill","info","outerHTML","currentSelection","numSprites","newIndex","toLowerCase","click","primaryPriorityFlag","addSpriteButton","handleKeyDown","paletteSizeSlider","paletteSizeValue","mergeButton","targetOffset","paletteSize","priorityCheckbox","handlePriorityChange","analyzeDuplicatesButton","spriteBrushSelect","selectedValue","parts","split","brushWidth","brushHeight","newBrush","_isBeingUpdatedProgrammatically","isChecked","allSwatches","default","acquireVsCodeApi","currentPalettePicker","currentMainSpriteDetailContainer","refreshPrimaryColorDisplay","mainContent","visibility","skipDirtyNotification","messagePayload","currentPrimaryPreviewBox","currentPrimaryHexValueSpan","currentSecondaryPreviewBox","currentSecondaryHexValueSpan","swatchInGrid","pixelsModified","tempPixels","pixelValue","currentSliderR","currentSliderG","currentSliderB","currentValueR","currentValueG","currentValueB","currentPrimaryColorHexInput","currentColorPickerInput","currentPriorityCheckbox","primaryR9Value","primaryG9Value","primaryB9Value","isPaletteChange","currentPrimaryColorIndexSpan","selectedSwatch","colorHex","currentSecondaryColorIndexSpan","baseSpriteWidth","baseSpriteHeight","brushW","brushH","newDetailPixelSize","async","data","initialState","isCustomPaletteMode","defaultPalette","initialData","paletteStatusSpan","primaryColorIndexSpan","primaryPreviewBox","primaryHexValueSpan","secondaryColorIndexSpan","secondaryPreviewBox","secondaryHexValueSpan","JSON","stringify","rgbStringToHex","childElementCount","focus","mainContainer","initializeUI","handleTransform","isReloadUpdate","currentSpriteBrushSelect","brushValue","reloadButton","hasOwnProperty","errorContainer","prepend","spriteToUpdate","saveButtonDirty","isSwapping","dragState","currentSpriteIndex","detailTitle","duplicates","removeAttribute","duplicate","originalBox","duplicateBox","duplicateIndex","matchType"],"sourceRoot":""}