{
    "name": "Multi File (Modules)",
    "description": "A modular NextBuild project with separate modules",
    "type": "custom",
    "directories": [
        "modules",
        "includes",
        "assets",
        "data",
        "build"
    ],
    "files": [
        {
            "name": "Master.bas",
            "template": "' Project: {projectName}\r\n' Type: Module Project - Master File\r\n' Generated by NextBuild Project Creator\r\n\r\n' ------------------------------------------------------------------------------\r\n' - NextBuild Studio\r\n' ------------------------------------------------------------------------------\r\n' - Main module ----------------------------------------------------------------\r\n' ------------------------------------------------------------------------------\r\n'\r\n'  This is the \"orchestrator\" or Master.NEX part of the module system. This is \r\n'  the main NEX that will be excuted and control which modules load and run. \r\n'  It *must* be call Master.bas for NBS to detect module compilation is required\r\n'  It is best to place any interrupt routines within the Master.NEX if you are \r\n'  using them. Load all your assets into the NEX file by using LoadSDBank() -  \r\n\r\n'!org=57344\t\t\t\t\r\n'!opt=4\r\n'!heap=1024\r\n\r\n' ORG 57344 - $E000 \r\n' Usable memory from $e000 to $ffff minus heap size\r\n\r\n' 1024 bytes reserved for variables @ $4000 bank 24\r\n' VarAddress located at $4000\r\n\r\n' ULA is paged out and banks 24/25 live in slots 2&3 on start of modules\r\n' For tilemap functions the relevants pages are put back \r\n\r\n' - Includes -------------------------------------------------------------------\r\n#define NOSP \t\t\t\t\t' do not use the default SP location \r\n#define DEBUG  \t\t\t\t\t' enable debug routines \r\n#define NEX \t\t\t\t\t' we are creating a NEX \r\n#include <nextlib.bas>\r\n#include \"includes/globals.bas\"\r\n\r\n' - Populate RAM banks for generating a NEX ------------------------------------\r\nLoadSDBank(\"[]font1.spr\",0,0,0,28)\t' font 8 into bank 28\r\n' - Main Entry -----------------------------------------------------------------\r\n\r\nMain()\r\n\r\nsub Main()\r\n\r\n\t' Initialization here...\r\n\t' Prepare empty RAM \r\n\r\n\tasm \r\n\t\t; ensure interrupts are disabled \r\n\t\tdi \r\n\t\tnextreg MMU2_4000_NR_52,24\t\t\t\t\t; page in alternate banks for $6000-$DFFF\r\n\t\tnextreg MMU3_6000_NR_53,25\t\t\t\t\t; we will use pages 24 & 25 \r\n\t\t; wipe ram \r\n\t\tld \t\thl,$4000 \t\t\t\t\t\t\t; lets make sure they're empty\r\n\t\tld \t\tde,$4001 \r\n\t\tld \t\thl,(0)\r\n\t\tld \t\tbc,$7d00 \r\n\t\tldir \t\r\n\tend asm \r\n\r\n\t' Start with module 1 \r\n\tSetLoadModule(ModuleSample1,0,0)\t\t\t\t' set the current module to module 1\r\n\t\r\n\t' Now control will be handed over to the modules \r\n\r\n\tdo \r\n\t\tExecModule(VarLoadModule)\r\n\tloop \r\n\r\nend sub\r\n\r\n' Execute module id\r\nsub ExecModule(id as ubyte)\r\n\r\n\t' This subroutine loads the correct module from SD\r\n\t' stores the stack and then jumps to $6000. when the \r\n\t' module has finished, execution should return and the\r\n\t' stack restored. \r\n\r\n\tdim file$ as string \r\n\r\n\t' we will use NStr() instead of Str(). NStr() does not rely on ROM routine\r\n\t' and is much smaller than the full string library \r\n\tcommon$=NStr(VarLoadModule)\t\t\t\t\t\r\n\r\n\tfile$=\"module\"+common$+\".bin\"\t\t\t\t' aseemble the complete filename to load\r\n\r\n\tLoadSD(file,24576,$7d00,0)\t\t\t\t\t' load from SD to $6000\r\n\r\n\tasm \r\n\t\t; call the routine\r\n\t\tld \t\t(execmodule_end+1),sp \t\t\t; write the current stack to the label below\r\n\t\tcall \t24576\t\t\t\t\t\t\t; call the module \r\n\texecmodule_end:\r\n\t\tld\t\tsp,0000\t\t\t\t\t\t\t; smc from above \r\n\tend asm \r\n\r\nend sub\r"
        },
        {
            "name": "Module001.bas",
            "template": "' Project: {projectName}\r\n' Type: Module Project - Module 001\r\n' Generated by NextBuild Project Creator\r\n\r\n' ------------------------------------------------------------------------------\r\n' Nextbuild Studio Module\r\n'\r\n' ORG 24576 - $6000\r\n' Usable memory from $6000 to $dd00 minus Heap size 32kB yeah\r\n\r\n'!master=Master.NEX\r\n'!org=24576\r\n'!heap=1024\r\n'!module \r\n'!noemu\r\n\r\n#define NOSP \r\n#include <nextlib.bas>\t\t\t\t\t' stanbdard nextlib include \r\n#include \"includes/globals.bas\"\t\t\t' Common routines used in all modules \r\n\r\nInit()\r\nMain()\r\n\r\nEnd \t\t' Exit module \r\n\r\n' This is the intialisation of the module \r\n\r\nSub Init()\r\n\r\n\tInitLayer2(MODE256X192)\r\n\r\nend sub \r\n\r\nSub Main()\r\n\t\r\n\t' Main module routine \r\n\r\n\tL2Text(0,0,\"THIS IS MODULE 1\",28,0)\t\t\t\t\t'\t\t\t show some infos \r\n    L2Text(0,1,\"PRESS ANY KEY TO EXIT\",28,0)\t\t\t\t\t' show some infos \r\n\t\r\n\tDo \r\n\r\n\t\tWaitRaster(192)\r\n        if GetKey2() <> 0 \r\n            exit do\r\n        endif \r\n\r\n\tLoop \r\n\r\n\tVarLoadModule=ModuleSample2\r\n\t\r\nend sub \r"
        },
        {
            "name": "Module002.bas",
            "template": "' Project: {projectName}\r\n' Type: Module Project - Module 002\r\n' Generated by NextBuild Project Creator\r\n\r\n' ------------------------------------------------------------------------------\r\n' Nextbuild Studio Module\r\n'\r\n' ORG 24576 - $6000\r\n' Usable memory from $6000 to $dd00 minus Heap size 32kB yeah\r\n\r\n'!master=Master.NEX\r\n'!org=24576\r\n'!heap=1024\r\n'!module \r\n'!noemu\r\n\r\n#define NOSP \r\n#include <nextlib.bas>\t\t\t\t\t' stanbdard nextlib include \r\n#include \"includes/globals.bas\"\t\t\t' Common routines used in all modules \r\n\r\nInit()\r\nMain()\r\n\r\nEnd \t\t' Exit module \r\n\r\n' This is the intialisation of the module \r\n\r\nSub Init()\r\n\r\n\tInitLayer2(MODE256X192)\r\n\r\nend sub \r\n\r\nSub Main()\r\n\t\r\n\t' Main module routine \r\n\r\n\tL2Text(0,10,\"THIS IS MODULE 2\",28,0)\t\t\t\t\t'\t\t\t show some infos \r\n    L2Text(0,11,\"PRESS ANY KEY TO EXIT\",28,0)\t\t\t\t\t' show some infos \r\n\t\r\n\tDo \r\n\r\n\t\tWaitRaster(192)\r\n        if GetKey2() <> 0 \r\n            exit do\r\n        endif \r\n\r\n\tLoop \r\n\r\n\tVarLoadModule=ModuleSample1\r\n\t\r\nend sub \r"
        },
        {
            "name": "includes/globals.bas",
            "template": "' Project: {projectName}\r\n' Shared constants\r\n' Generated by NextBuild Project Creator\r\n\r\n' - Global Includes \r\n' Must be included in all modules and master source files. \r\n\r\n' - Defines --------------------------------------------------------------------\r\n' extend this to add aditional modules. \r\n#define ModuleSample1 1\r\n#define ModuleSample2 2\r\n#define ModuleSample3 3\r\n#define ModuleSample4 4\r\n\r\n' base address of global vars\r\n#define VarAddress $4000\r\n\r\n' - Module manager vars --------------------------------------------------------\r\n' parameters to control active module\r\ndim VarLoadModule AS Ubyte AT VarAddress\t\t\t\t' Module to load\r\ndim VarLoadModuleParameter1 AS Ubyte AT VarAddress + 1\t' Parameter 1 for the module to load\r\ndim VarLoadModuleParameter2 AS Ubyte AT VarAddress + 2\t' Parameter 2 for the module to load\r\n\r\n' Global variables \r\ndim VarLifes \tAS UBYTE \tAT VarAddress + 3\r\ndim VarPoints \tAS UINTEGER AT VarAddress + 4\t\t' Two bytes\r\ndim VarPosX \tAS UBYTE \tAT VarAddress + 6\r\ndim VarPosY \tAS UBYTE \tAT VarAddress + 7\r\ndim VarBytesArray(100) AS UBYTE AT VarAddress + 8\t' 100 bytes\r\ndim VarLevel \tAS UBYTE \tAT VarAddress + 108\r\n\r\n' end of global variables \r\n#define VarsLength 512\t\t\t' Now define size of varibles to save\r\n\r\ndim common$=\" \"\r\n\r\n' - Common var tools -----------------------------------------------------------\r\n\r\n' Set the Next module to load\r\n' id = module ID to load and run \r\n' arg1 / 2 = arguments to pass \r\nsub SetLoadModule(byval module_id AS ubyte, byval arg1 AS ubyte, byval arg2 AS ubyte)\r\n\tVarLoadModule=module_id\r\n\tVarLoadModuleParameter1=arg1\r\n\tVarLoadModuleParameter2=arg2\r\nend sub\r\n\r\n' Save vars to disk\r\nSub SaveConfig()\r\n\tSaveSD(\"app.cfg\",VarAddress,VarsLength)\r\nEND sub\r\n\r\n' Load vars from disk\r\nSUB LoadConfig()\r\n\tLoadSD(\"app.cfg\",VarAddress,VarsLength,0)\r\nEND SUB\r\n\r\n\r\n' - Memory management ----------------------------------------------------------\r\n\r\nfunction fastcall GetKey2() AS ubyte \r\n\tasm \r\n\t; used for inkeys replacement \r\n\t; doesnt require ROM \r\n\t; from L BREAK INTO PROGRAM \r\n\tPROC \r\n\tLOCAL Read_Keyboard, Read_Keyboard_0, Read_Keyboard_1, Read_Keyboard_2, Keyboard_Map\r\n\r\n\tRead_Keyboard:          \r\n\t\tLD \t\tHL,Keyboard_Map              \t\t; Point HL at the keyboard list\r\n\t\tLD \t\tD,8                                 ; This is the number of ports (rows) to check\r\n\t\tLD \t\tC,$FE                            \t; C is always FEh for reading keyboard ports\r\n\tRead_Keyboard_0:        \r\n\t\tLD \t\tB,(HL)                              ; Get the keyboard port address from table\r\n\t\tINC \tHL                                  ; Increment to list of keys\r\n\t\tIN \t\tA,(C)                               ; Read the row of keys in\r\n\t\tAND \t$1F                                 ; We are only interested in the first five bits\r\n\t\tLD \t\tE,5                                 ; This is the number of keys in the row\r\n\tRead_Keyboard_1:        \r\n\t\tSRL \tA                                   ; Shift A right; bit 0 sets carry bit\r\n\t\tJR \t\tNC,Read_Keyboard_2   \t\t\t\t; If the bit is 0, we've found our key\r\n\t\tINC \tHL                                  ; Go to next table address\r\n\t\tDEC \tE                                   ; Decrement key loop counter\r\n\t\tJR \t\tNZ,Read_Keyboard_1   \t\t\t\t; Loop around until this row finished\r\n\t\tDEC \tD                                   ; Decrement row loop counter\r\n\t\tJR \t\tNZ,Read_Keyboard_0   \t\t\t\t; Loop around until we are done\r\n\t\tAND \tA                                   ; Clear A (no key found)\r\n\t\tRET\r\n\tRead_Keyboard_2:        \r\n\t\t \r\n\t\tLD \t\tA,(HL)                              ; We've found a key at this point; fetch the character code!\r\n\t\t\r\n\t\tRET\r\n\r\n\tKeyboard_Map:           \r\n\t\tDB \t\t$FE,\"#\",\"Z\",\"X\",\"C\",\"V\"\r\n\t\tDB \t\t$FD,\"A\",\"S\",\"D\",\"F\",\"G\"\r\n\t\tDB \t\t$FB,\"Q\",\"W\",\"E\",\"R\",\"T\"\r\n\t\tDB \t\t$F7,\"1\",\"2\",\"3\",\"4\",\"5\"\r\n\t\tDB \t\t$EF,\"0\",\"9\",\"8\",\"7\",\"6\"\r\n\t\tDB \t\t$DF,\"P\",\"O\",\"I\",\"U\",\"Y\"\r\n\t\tDB \t\t$BF,\"#\",\"L\",\"K\",\"J\",\"H\"\r\n\t\tDB \t\t$7F,\" \",\"#\",\"M\",\"N\",\"B\"\r\n\tENDP \r\n\r\n\tend asm \r\n\r\nend function \r\n\r\n' get key number value\r\nfunction GetKey(max AS ubyte) AS ubyte \r\n\tdim a \tAS ubyte \r\n\t' Wait to release key\r\n\tdo \t\t\r\n\t\twhile GetKey2()<>0\r\n\t\t\ta = 0 \r\n\t\twend\r\n\t\twhile a=0\r\n\t\t\ta = GetKey2() band %00001111\r\n\t\twend\r\n\t\t' Wait to press key\r\n\r\n\t\t' return numeric value of pressed key\r\n\t\tif a>0 and a<=max\r\n\t\t\treturn a \r\n\t\tendif \r\n\tloop \r\nend function\r\n\r\n\r\nfunction fastcall NStr(ins AS ubyte) AS string \r\n\r\n\tasm \r\n\t; alternate non-rom version of str(ubyte)\r\n\t; converts 8 bit decimal into ascii text 000 format \r\n\t; then assigns to common$ and is returned \r\n\t; \r\n\tPROC \r\n\tLOCAL Na1, Na2, skpinc, nst_finished\r\n\r\n\t\tld \t\thl,.LABEL._filename\t\t\t; our fave location\r\n\t\tld\t\td, 0 \r\n\t\tpush \thl \t\t\t\t\t\t\t; save start of string\r\n\t\tcall \tCharToAsc\t\t\t\t\t; do conversion \r\n\t\tld \t\t(hl), d\t\t\t\t\t\t; ensure we zero terminate\r\n\t\tpop \thl \t\t\t\t\t\t\t; jump back start of string\r\n\r\n\t\tld\t\ta,  3\t\t\t\t\t\t; add length \r\n\t\tld \t\t(hl), a \r\n\t\tinc \thl \r\n\t\tld \t\t(hl), d\r\n\t\tdec \thl  \r\n\r\n\t\tld\t\tde, _common\t\t\t\t\t; point to string we want to set\r\n\t\tex \t\tde, hl \t\t\t\t\t\t; swap hl & de - hl = string, de = source \r\n\t\tcall    .core.__STORE_STR \t\t\t; do call AS we need to return to complete\r\n\t\tjp \t\tnst_finished\t\t\t\t; the common$ assignment \r\n\r\n\tCharToAsc:\t\t\r\n\r\n\t\t; hl still pointing to pointer of memory \r\n\t\tld \t\thl,.LABEL._filename+2\t\t\t\r\n\t\tld\t\tc, -100\r\n\t\tcall\tNa1\r\n\t\tld\t\tc, -10\r\n\t\tcall\tNa1\r\n\t\tld\t\tc, -1\r\n\r\n\tNa1:\r\n\r\n\t\tld\t\tb, '0'-1\r\n\r\n\tNa2:\r\n\r\n\t\tinc\t\tb\r\n\t\tadd\t\ta, c\r\n\t\tjr\t\tc, Na2\r\n\t\tsub\t\tc\t\t\t\t\t; works AS add 100/10/1\r\n\t\tpush \taf\t\t\t\t\t; safer than ld c,a\r\n\t\tld\t\ta, b\t\t\t\t; char is in b\r\n\r\n\t\tld \t\t(hl), a\t\t\t\t; save char in memory \r\n\t\tinc \thl \t\t\t\t\t; move along one byte \r\n\r\n\tskpinc:\r\n\r\n\t\tpop \taf\t\t\t\t\t\r\n\r\n\t\tret\r\n\r\n\tnst_finished: \r\n\r\n\tENDP \r\n\r\n\tend asm \r\n\r\n\treturn common$\r\n\r\nend function \r"
        }
    ]
}