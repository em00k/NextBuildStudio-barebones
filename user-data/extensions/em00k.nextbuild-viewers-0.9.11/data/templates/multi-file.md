# Template Name: Multi File (Modules)
Description: A modular NextBuild project with separate modules

## Directories
- modules
- includes
- assets
- data
- build

## Files

### Master.bas
```nextbuild
' Project: {projectName}
' Type: Module Project - Master File
' Generated by NextBuild Project Creator

' ------------------------------------------------------------------------------
' - NextBuild Studio
' ------------------------------------------------------------------------------
' - Main module ----------------------------------------------------------------
' ------------------------------------------------------------------------------
'
'  This is the "orchestrator" or Master.NEX part of the module system. This is 
'  the main NEX that will be excuted and control which modules load and run. 
'  It *must* be call Master.bas for NBS to detect module compilation is required
'  It is best to place any interrupt routines within the Master.NEX if you are 
'  using them. Load all your assets into the NEX file by using LoadSDBank() -  

'!org=57344				
'!opt=4
'!heap=1024

' ORG 57344 - $E000 
' Usable memory from $e000 to $ffff minus heap size

' 1024 bytes reserved for variables @ $4000 bank 24
' VarAddress located at $4000

' ULA is paged out and banks 24/25 live in slots 2&3 on start of modules
' For tilemap functions the relevants pages are put back 

' - Includes -------------------------------------------------------------------
#define NOSP 					' do not use the default SP location 
#define DEBUG  					' enable debug routines 
#define NEX 					' we are creating a NEX 
#include <nextlib.bas>
#include "includes/globals.bas"

' - Populate RAM banks for generating a NEX ------------------------------------
LoadSDBank("[]font1.spr",0,0,0,28)	' font 8 into bank 28
' - Main Entry -----------------------------------------------------------------

Main()

sub Main()

	' Initialization here...
	' Prepare empty RAM 

	asm 
		; ensure interrupts are disabled 
		di 
		nextreg MMU2_4000_NR_52,24					; page in alternate banks for $6000-$DFFF
		nextreg MMU3_6000_NR_53,25					; we will use pages 24 & 25 
		; wipe ram 
		ld 		hl,$4000 							; lets make sure they're empty
		ld 		de,$4001 
		ld 		hl,(0)
		ld 		bc,$7d00 
		ldir 	
	end asm 

	' Start with module 1 
	SetLoadModule(ModuleSample1,0,0)				' set the current module to module 1
	
	' Now control will be handed over to the modules 

	do 
		ExecModule(VarLoadModule)
	loop 

end sub

' Execute module id
sub ExecModule(id as ubyte)

	' This subroutine loads the correct module from SD
	' stores the stack and then jumps to $6000. when the 
	' module has finished, execution should return and the
	' stack restored. 

	dim file$ as string 

	' we will use NStr() instead of Str(). NStr() does not rely on ROM routine
	' and is much smaller than the full string library 
	common$=NStr(VarLoadModule)					

	file$="module"+common$+".bin"				' aseemble the complete filename to load

	LoadSD(file,24576,$7d00,0)					' load from SD to $6000

	asm 
		; call the routine
		ld 		(execmodule_end+1),sp 			; write the current stack to the label below
		call 	24576							; call the module 
	execmodule_end:
		ld		sp,0000							; smc from above 
	end asm 

end sub
```

### Module001.bas
```nextbuild
' Project: {projectName}
' Type: Module Project - Module 001
' Generated by NextBuild Project Creator

' ------------------------------------------------------------------------------
' Nextbuild Studio Module
'
' ORG 24576 - $6000
' Usable memory from $6000 to $dd00 minus Heap size 32kB yeah

'!master=Master.NEX
'!org=24576
'!heap=1024
'!module 
'!noemu

#define NOSP 
#include <nextlib.bas>					' stanbdard nextlib include 
#include "includes/globals.bas"			' Common routines used in all modules 

Init()
Main()

End 		' Exit module 

' This is the intialisation of the module 

Sub Init()

	InitLayer2(MODE256X192)

end sub 

Sub Main()
	
	' Main module routine 

	L2Text(0,0,"THIS IS MODULE 1",28,0)					'			 show some infos 
    L2Text(0,1,"PRESS ANY KEY TO EXIT",28,0)					' show some infos 
	
	Do 

		WaitRaster(192)
        if GetKey2() <> 0 
            exit do
        endif 

	Loop 

	VarLoadModule=ModuleSample2
	
end sub 
```
### Module002.bas
```nextbuild
' Project: {projectName}
' Type: Module Project - Module 002
' Generated by NextBuild Project Creator

' ------------------------------------------------------------------------------
' Nextbuild Studio Module
'
' ORG 24576 - $6000
' Usable memory from $6000 to $dd00 minus Heap size 32kB yeah

'!master=Master.NEX
'!org=24576
'!heap=1024
'!module 
'!noemu

#define NOSP 
#include <nextlib.bas>					' stanbdard nextlib include 
#include "includes/globals.bas"			' Common routines used in all modules 

Init()
Main()

End 		' Exit module 

' This is the intialisation of the module 

Sub Init()

	InitLayer2(MODE256X192)

end sub 

Sub Main()
	
	' Main module routine 

	L2Text(0,10,"THIS IS MODULE 2",28,0)					'			 show some infos 
    L2Text(0,11,"PRESS ANY KEY TO EXIT",28,0)					' show some infos 
	
	Do 

		WaitRaster(192)
        if GetKey2() <> 0 
            exit do
        endif 

	Loop 

	VarLoadModule=ModuleSample1
	
end sub 
```

### includes/globals.bas
```nextbuild
' Project: {projectName}
' Shared constants
' Generated by NextBuild Project Creator

' - Global Includes 
' Must be included in all modules and master source files. 

' - Defines --------------------------------------------------------------------
' extend this to add aditional modules. 
#define ModuleSample1 1
#define ModuleSample2 2
#define ModuleSample3 3
#define ModuleSample4 4

' base address of global vars
#define VarAddress $4000

' - Module manager vars --------------------------------------------------------
' parameters to control active module
dim VarLoadModule AS Ubyte AT VarAddress				' Module to load
dim VarLoadModuleParameter1 AS Ubyte AT VarAddress + 1	' Parameter 1 for the module to load
dim VarLoadModuleParameter2 AS Ubyte AT VarAddress + 2	' Parameter 2 for the module to load

' Global variables 
dim VarLifes 	AS UBYTE 	AT VarAddress + 3
dim VarPoints 	AS UINTEGER AT VarAddress + 4		' Two bytes
dim VarPosX 	AS UBYTE 	AT VarAddress + 6
dim VarPosY 	AS UBYTE 	AT VarAddress + 7
dim VarBytesArray(100) AS UBYTE AT VarAddress + 8	' 100 bytes
dim VarLevel 	AS UBYTE 	AT VarAddress + 108

' end of global variables 
#define VarsLength 512			' Now define size of varibles to save

dim common$=" "

' - Common var tools -----------------------------------------------------------

' Set the Next module to load
' id = module ID to load and run 
' arg1 / 2 = arguments to pass 
sub SetLoadModule(byval module_id AS ubyte, byval arg1 AS ubyte, byval arg2 AS ubyte)
	VarLoadModule=module_id
	VarLoadModuleParameter1=arg1
	VarLoadModuleParameter2=arg2
end sub

' Save vars to disk
Sub SaveConfig()
	SaveSD("app.cfg",VarAddress,VarsLength)
END sub

' Load vars from disk
SUB LoadConfig()
	LoadSD("app.cfg",VarAddress,VarsLength,0)
END SUB


' - Memory management ----------------------------------------------------------

function fastcall GetKey2() AS ubyte 
	asm 
	; used for inkeys replacement 
	; doesnt require ROM 
	; from L BREAK INTO PROGRAM 
	PROC 
	LOCAL Read_Keyboard, Read_Keyboard_0, Read_Keyboard_1, Read_Keyboard_2, Keyboard_Map

	Read_Keyboard:          
		LD 		HL,Keyboard_Map              		; Point HL at the keyboard list
		LD 		D,8                                 ; This is the number of ports (rows) to check
		LD 		C,$FE                            	; C is always FEh for reading keyboard ports
	Read_Keyboard_0:        
		LD 		B,(HL)                              ; Get the keyboard port address from table
		INC 	HL                                  ; Increment to list of keys
		IN 		A,(C)                               ; Read the row of keys in
		AND 	$1F                                 ; We are only interested in the first five bits
		LD 		E,5                                 ; This is the number of keys in the row
	Read_Keyboard_1:        
		SRL 	A                                   ; Shift A right; bit 0 sets carry bit
		JR 		NC,Read_Keyboard_2   				; If the bit is 0, we've found our key
		INC 	HL                                  ; Go to next table address
		DEC 	E                                   ; Decrement key loop counter
		JR 		NZ,Read_Keyboard_1   				; Loop around until this row finished
		DEC 	D                                   ; Decrement row loop counter
		JR 		NZ,Read_Keyboard_0   				; Loop around until we are done
		AND 	A                                   ; Clear A (no key found)
		RET
	Read_Keyboard_2:        
		 
		LD 		A,(HL)                              ; We've found a key at this point; fetch the character code!
		
		RET

	Keyboard_Map:           
		DB 		$FE,"#","Z","X","C","V"
		DB 		$FD,"A","S","D","F","G"
		DB 		$FB,"Q","W","E","R","T"
		DB 		$F7,"1","2","3","4","5"
		DB 		$EF,"0","9","8","7","6"
		DB 		$DF,"P","O","I","U","Y"
		DB 		$BF,"#","L","K","J","H"
		DB 		$7F," ","#","M","N","B"
	ENDP 

	end asm 

end function 

' get key number value
function GetKey(max AS ubyte) AS ubyte 
	dim a 	AS ubyte 
	' Wait to release key
	do 		
		while GetKey2()<>0
			a = 0 
		wend
		while a=0
			a = GetKey2() band %00001111
		wend
		' Wait to press key

		' return numeric value of pressed key
		if a>0 and a<=max
			return a 
		endif 
	loop 
end function


function fastcall NStr(ins AS ubyte) AS string 

	asm 
	; alternate non-rom version of str(ubyte)
	; converts 8 bit decimal into ascii text 000 format 
	; then assigns to common$ and is returned 
	; 
	PROC 
	LOCAL Na1, Na2, skpinc, nst_finished

		ld 		hl,.LABEL._filename			; our fave location
		ld		d, 0 
		push 	hl 							; save start of string
		call 	CharToAsc					; do conversion 
		ld 		(hl), d						; ensure we zero terminate
		pop 	hl 							; jump back start of string

		ld		a,  3						; add length 
		ld 		(hl), a 
		inc 	hl 
		ld 		(hl), d
		dec 	hl  

		ld		de, _common					; point to string we want to set
		ex 		de, hl 						; swap hl & de - hl = string, de = source 
		call    .core.__STORE_STR 			; do call AS we need to return to complete
		jp 		nst_finished				; the common$ assignment 

	CharToAsc:		

		; hl still pointing to pointer of memory 
		ld 		hl,.LABEL._filename+2			
		ld		c, -100
		call	Na1
		ld		c, -10
		call	Na1
		ld		c, -1

	Na1:

		ld		b, '0'-1

	Na2:

		inc		b
		add		a, c
		jr		c, Na2
		sub		c					; works AS add 100/10/1
		push 	af					; safer than ld c,a
		ld		a, b				; char is in b

		ld 		(hl), a				; save char in memory 
		inc 	hl 					; move along one byte 

	skpinc:

		pop 	af					

		ret

	nst_finished: 

	ENDP 

	end asm 

	return common$

end function 
``` 