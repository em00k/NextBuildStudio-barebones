' Project: ModuleDemoII
' Shared constants
' Generated by NextBuild Project Creator

' - Global Includes 
' Must be included in all modules and master source files. 

' - Defines --------------------------------------------------------------------
' extend this to add aditional modules. 
#define ModuleSample1 1
#define ModuleSample2 2
#define ModuleSample3 3
#define ModuleSample4 4

' base address of global vars
#define VarAddress $4000

' - Module manager vars --------------------------------------------------------
' parameters to control active module
dim VarLoadModule AS Ubyte AT VarAddress				' Module to load
dim VarLoadModuleParameter1 AS Ubyte AT VarAddress + 1	' Parameter 1 for the module to load
dim VarLoadModuleParameter2 AS Ubyte AT VarAddress + 2	' Parameter 2 for the module to load

' Global variables 
dim VarLifes 	AS UBYTE 	AT VarAddress + 3
dim VarPoints 	AS UINTEGER AT VarAddress + 4		' Two bytes
dim VarPosX 	AS UBYTE 	AT VarAddress + 6
dim VarPosY 	AS UBYTE 	AT VarAddress + 7
dim VarBytesArray(100) 		AS UBYTE AT VarAddress + 8	' 100 bytes
Dim Mouse 		as ubyte 	at VarAddress + 9
DIM VarLevel 	AS UBYTE 	AT VarAddress + 108

' end of global variables 
#define VarsLength 512			' Now define size of varibles to save

dim common$=" "

asm 
	Mouse		EQU ._Mouse 
end asm 

' - Common var tools -----------------------------------------------------------

' Set the Next module to load
' id = module ID to load and run 
' arg1 / 2 = arguments to pass 
sub SetLoadModule(byval module_id AS ubyte, byval arg1 AS ubyte, byval arg2 AS ubyte)
	VarLoadModule=module_id
	VarLoadModuleParameter1=arg1
	VarLoadModuleParameter2=arg2
end sub

' Save vars to disk
Sub SaveConfig()
	SaveSD("app.cfg",VarAddress,VarsLength)
END sub

' Load vars from disk
SUB LoadConfig()
	LoadSD("app.cfg",VarAddress,VarsLength,0)
END SUB


' - Memory management ----------------------------------------------------------

function fastcall GetKey2() AS ubyte 
	asm 
	; used for inkeys replacement 
	; doesnt require ROM 
	; from L BREAK INTO PROGRAM 
	PROC 
	LOCAL Read_Keyboard, Read_Keyboard_0, Read_Keyboard_1, Read_Keyboard_2, Keyboard_Map

	Read_Keyboard:          
		LD 		HL,Keyboard_Map              		; Point HL at the keyboard list
		LD 		D,8                                 ; This is the number of ports (rows) to check
		LD 		C,$FE                            	; C is always FEh for reading keyboard ports
	Read_Keyboard_0:        
		LD 		B,(HL)                              ; Get the keyboard port address from table
		INC 	HL                                  ; Increment to list of keys
		IN 		A,(C)                               ; Read the row of keys in
		AND 	$1F                                 ; We are only interested in the first five bits
		LD 		E,5                                 ; This is the number of keys in the row
	Read_Keyboard_1:        
		SRL 	A                                   ; Shift A right; bit 0 sets carry bit
		JR 		NC,Read_Keyboard_2   				; If the bit is 0, we've found our key
		INC 	HL                                  ; Go to next table address
		DEC 	E                                   ; Decrement key loop counter
		JR 		NZ,Read_Keyboard_1   				; Loop around until this row finished
		DEC 	D                                   ; Decrement row loop counter
		JR 		NZ,Read_Keyboard_0   				; Loop around until we are done
		AND 	A                                   ; Clear A (no key found)
		RET
	Read_Keyboard_2:        
		 
		LD 		A,(HL)                              ; We've found a key at this point; fetch the character code!
		
		RET

	Keyboard_Map:           
		DB 		$FE,"#","Z","X","C","V"
		DB 		$FD,"A","S","D","F","G"
		DB 		$FB,"Q","W","E","R","T"
		DB 		$F7,"1","2","3","4","5"
		DB 		$EF,"0","9","8","7","6"
		DB 		$DF,"P","O","I","U","Y"
		DB 		$BF,"#","L","K","J","H"
		DB 		$7F," ","#","M","N","B"
	ENDP 

	end asm 

end function 

' get key number value
function GetKey(max AS ubyte) AS ubyte 
	dim a 	AS ubyte 
	' Wait to release key
	do 		
		while GetKey2()<>0
			a = 0 
		wend
		while a=0
			a = GetKey2() band %00001111
		wend
		' Wait to press key

		' return numeric value of pressed key
		if a>0 and a<=max
			return a 
		endif 
	loop 
end function


function fastcall NStr(ins AS ubyte) AS string 

	asm 
	; alternate non-rom version of str(ubyte)
	; converts 8 bit decimal into ascii text 000 format 
	; then assigns to common$ and is returned 
	; 
	PROC 
	LOCAL Na1, Na2, skpinc, nst_finished

		ld 		hl,.LABEL._filename			; our fave location
		ld		d, 0 
		push 	hl 							; save start of string
		call 	CharToAsc					; do conversion 
		ld 		(hl), d						; ensure we zero terminate
		pop 	hl 							; jump back start of string

		ld		a,  3						; add length 
		ld 		(hl), a 
		inc 	hl 
		ld 		(hl), d
		dec 	hl  

		ld		de, _common					; point to string we want to set
		ex 		de, hl 						; swap hl & de - hl = string, de = source 
		call    .core.__STORE_STR 			; do call AS we need to return to complete
		jp 		nst_finished				; the common$ assignment 

	CharToAsc:		

		; hl still pointing to pointer of memory 
		ld 		hl,.LABEL._filename+2			
		ld		c, -100
		call	Na1
		ld		c, -10
		call	Na1
		ld		c, -1

	Na1:

		ld		b, '0'-1

	Na2:

		inc		b
		add		a, c
		jr		c, Na2
		sub		c					; works AS add 100/10/1
		push 	af					; safer than ld c,a
		ld		a, b				; char is in b

		ld 		(hl), a				; save char in memory 
		inc 	hl 					; move along one byte 

	skpinc:

		pop 	af					

		ret

	nst_finished: 

	ENDP 

	end asm 

	return common$

end function 

