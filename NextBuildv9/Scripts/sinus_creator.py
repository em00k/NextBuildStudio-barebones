#!/usr/bin/env python3
"""
8-Bit Game Wave Generator
Creates sine/cosine wave tables for sprite movement in 8-bit games

Usage Examples:
    # Basic usage - generate default waves (256 samples)
    python3 sinus_creator.py

    # Custom parameters
    python3 sinus_creator.py --amplitude 100 --offset 0 --resolution 128

    # Save to file
    python3 sinus_creator.py -f my_waves.asm

    # Launch interactive GUI (tkinter only)
    python3 sinus_creator.py --gui
"""

import math
import sys
import argparse
from typing import List, Tuple, Optional

# GUI imports - using only built-in modules
try:
    import tkinter as tk
    from tkinter import ttk, messagebox, filedialog
    HAS_GUI = True
except ImportError:
    HAS_GUI = False


class WaveGenerator:
    def __init__(self, amplitude: int = 127, offset: int = 128, resolution: int = 256):
        """
        Initialize wave generator

        Args:
            amplitude: Maximum amplitude of the wave (0-127 for signed, 0-255 for unsigned)
            offset: DC offset for the wave (typically 128 for unsigned 8-bit)
            resolution: Number of samples per period (typically 256 for full circle)
        """
        self.amplitude = amplitude
        self.offset = offset
        self.resolution = resolution

    def generate_sine(self, phase_offset: float = 0.0) -> List[int]:
        """Generate sine wave data"""
        data = []
        for i in range(self.resolution):
            angle = (2 * math.pi * i / self.resolution) + phase_offset
            value = int(self.offset + self.amplitude * math.sin(angle))
            # Clamp to valid range
            value = max(0, min(255, value))
            data.append(value)
        return data

    def generate_cosine(self, phase_offset: float = 0.0) -> List[int]:
        """Generate cosine wave data"""
        data = []
        for i in range(self.resolution):
            angle = (2 * math.pi * i / self.resolution) + phase_offset
            value = int(self.offset + self.amplitude * math.cos(angle))
            # Clamp to valid range
            value = max(0, min(255, value))
            data.append(value)
        return data

    def format_as_assembly(self, data: List[int], label: str, comment: str = "") -> str:
        """Format data as assembly db statements"""
        lines = []
        lines.append(f"{label}:")
        if comment:
            lines.append(f"    ; {comment}")
        lines.append(f"    ; {len(data)} bytes")

        # Format data in rows of 16 values
        for i in range(0, len(data), 16):
            chunk = data[i:i+16]
            hex_values = [f"{val:3d}" for val in chunk]
            lines.append(f"    db {', '.join(hex_values)}")

        lines.append("")
        return "\n".join(lines)


def create_dual_waves(amplitude: int = 127, offset: int = 128, resolution: int = 256,
                      sine_phase: float = 0.0, cosine_phase: float = 0.0) -> str:
    """
    Create both sine and cosine waves with the specified parameters

    Args:
        amplitude: Wave amplitude
        offset: DC offset
        resolution: Number of samples
        sine_phase: Phase offset for sine wave (in radians)
        cosine_phase: Phase offset for cosine wave (in radians)

    Returns:
        Formatted assembly code string
    """
    generator = WaveGenerator(amplitude, offset, resolution)

    sine_data = generator.generate_sine(sine_phase)
    cosine_data = generator.generate_cosine(cosine_phase)

    sine_asm = generator.format_as_assembly(
        sine_data,
        "sine_wave_table",
        f"Sine wave: amp={amplitude}, offset={offset}, phase={sine_phase:.2f}"
    )

    cosine_asm = generator.format_as_assembly(
        cosine_data,
        "cosine_wave_table",
        f"Cosine wave: amp={amplitude}, offset={offset}, phase={cosine_phase:.2f}"
    )

    return f"; Generated by sinus_creator.py\n; {resolution} samples per period\n\n{sine_asm}\n{cosine_asm}"


def visualize_waves(amplitude: int = 127, offset: int = 128, resolution: int = 256,
                   sine_phase: float = 0.0, cosine_phase: float = 0.0) -> None:
    """
    Visualize the generated sine and cosine waves using matplotlib (if available)
    """
    try:
        import matplotlib.pyplot as plt

        generator = WaveGenerator(amplitude, offset, resolution)

        sine_data = generator.generate_sine(sine_phase)
        cosine_data = generator.generate_cosine(cosine_phase)

        # Create x-axis values (angles in radians)
        x_values = [(2 * math.pi * i / resolution) for i in range(resolution)]

        # Plot the waves
        plt.figure(figsize=(12, 8))

        # Plot sine wave
        plt.subplot(2, 2, 1)
        plt.plot(x_values, sine_data, 'b-', linewidth=2)
        plt.title(f'Sine Wave (amp={amplitude}, offset={offset}, phase={sine_phase:.2f})')
        plt.xlabel('Angle (radians)')
        plt.ylabel('Value')
        plt.grid(True, alpha=0.3)
        plt.axhline(y=offset, color='r', linestyle='--', alpha=0.7, label=f'Offset ({offset})')
        plt.legend()

        # Plot cosine wave
        plt.subplot(2, 2, 2)
        plt.plot(x_values, cosine_data, 'g-', linewidth=2)
        plt.title(f'Cosine Wave (amp={amplitude}, offset={offset}, phase={cosine_phase:.2f})')
        plt.xlabel('Angle (radians)')
        plt.ylabel('Value')
        plt.grid(True, alpha=0.3)
        plt.axhline(y=offset, color='r', linestyle='--', alpha=0.7, label=f'Offset ({offset})')
        plt.legend()

        # Plot both waves together
        plt.subplot(2, 2, 3)
        plt.plot(x_values, sine_data, 'b-', linewidth=2, label='Sine')
        plt.plot(x_values, cosine_data, 'g-', linewidth=2, label='Cosine')
        plt.title('Sine and Cosine Waves Overlay')
        plt.xlabel('Angle (radians)')
        plt.ylabel('Value')
        plt.grid(True, alpha=0.3)
        plt.axhline(y=offset, color='r', linestyle='--', alpha=0.7, label=f'Offset ({offset})')
        plt.legend()

        # Plot wave data as bar chart (first 64 samples)
        plt.subplot(2, 2, 4)
        sample_indices = list(range(min(64, resolution)))
        plt.bar(sample_indices, sine_data[:64], alpha=0.7, color='blue', label='Sine')
        plt.bar(sample_indices, cosine_data[:64], alpha=0.7, color='green', label='Cosine')
        plt.title('Wave Data Values (First 64 Samples)')
        plt.xlabel('Sample Index')
        plt.ylabel('Value')
        plt.legend()
        plt.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    except ImportError:
        print("Visualization not available. Install matplotlib and numpy:")
        print("pip install matplotlib numpy")
        print("Or use the GUI: python3 sinus_creator.py --gui")


class WaveGUI:
    def __init__(self):
        if not HAS_GUI:
            raise ImportError("GUI not available - tkinter required")

        self.root = tk.Tk()
        self.root.title("8-Bit Game Wave Generator")
        self.root.geometry("800x600")
        self.root.resizable(False, False)

        # Wave parameters
        self.min_value = tk.IntVar(value=0)
        self.max_value = tk.IntVar(value=255)
        self.resolution = tk.IntVar(value=256)
        self.wave_type = tk.StringVar(value="sine")
        self.phase = tk.DoubleVar(value=0.0)

        self.setup_gui()
        self.update_preview()

    def setup_gui(self):
        # Main container
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Control panel (top)
        control_frame = ttk.LabelFrame(main_frame, text="Wave Settings", padding=10)
        control_frame.pack(fill=tk.X, pady=(0, 10))

        # Row 1: Min/Max values
        ttk.Label(control_frame, text="Min Value:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
        ttk.Spinbox(control_frame, from_=0, to=255, textvariable=self.min_value, width=8,
                   command=self.update_preview).grid(row=0, column=1, padx=(0, 10))

        ttk.Label(control_frame, text="Max Value:").grid(row=0, column=2, sticky=tk.W, padx=(0, 5))
        ttk.Spinbox(control_frame, from_=0, to=255, textvariable=self.max_value, width=8,
                   command=self.update_preview).grid(row=0, column=3, padx=(0, 10))

        # Row 2: Resolution and Wave Type
        ttk.Label(control_frame, text="Resolution:").grid(row=1, column=0, sticky=tk.W, padx=(0, 5))
        ttk.Spinbox(control_frame, from_=8, to=512, textvariable=self.resolution, width=8,
                   command=self.update_preview).grid(row=1, column=1, padx=(0, 10))

        ttk.Label(control_frame, text="Wave Type:").grid(row=1, column=2, sticky=tk.W, padx=(0, 5))
        wave_combo = ttk.Combobox(control_frame, textvariable=self.wave_type, width=8,
                                values=["sine", "cosine", "triangle", "square"])
        wave_combo.grid(row=1, column=3, padx=(0, 10))
        wave_combo.bind('<<ComboboxSelected>>', lambda e: self.update_preview())

        # Row 3: Phase
        ttk.Label(control_frame, text="Phase:").grid(row=2, column=0, sticky=tk.W, padx=(0, 5))
        ttk.Scale(control_frame, from_=0, to=2*math.pi, orient=tk.HORIZONTAL,
                 variable=self.phase, command=self.update_preview).grid(row=2, column=1, columnspan=3, sticky=tk.EW, padx=(0, 10))

        # Preview area (middle)
        preview_frame = ttk.LabelFrame(main_frame, text="Wave Preview", padding=5)
        preview_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))

        self.canvas = tk.Canvas(preview_frame, bg='white', width=600, height=200)
        self.canvas.pack(fill=tk.BOTH, expand=True)

        # Output area (bottom)
        output_frame = ttk.LabelFrame(main_frame, text="Generated Code", padding=5)
        output_frame.pack(fill=tk.X)

        # Buttons
        button_frame = ttk.Frame(output_frame)
        button_frame.pack(fill=tk.X, pady=(0, 5))

        ttk.Button(button_frame, text="Generate Code", command=self.update_preview).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(button_frame, text="Copy to Clipboard", command=self.copy_to_clipboard).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(button_frame, text="Export to File", command=self.export_assembly).pack(side=tk.LEFT)

        # Text output
        self.code_text = tk.Text(output_frame, height=12, font=('Courier', 9))
        scrollbar = ttk.Scrollbar(output_frame, orient=tk.VERTICAL, command=self.code_text.yview)
        self.code_text.configure(yscrollcommand=scrollbar.set)

        self.code_text.pack(side=tk.LEFT, fill=tk.X, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    def update_preview(self, *args):
        # Get current parameters
        min_val = self.min_value.get()
        max_val = self.max_value.get()
        resolution = self.resolution.get()
        wave_type = self.wave_type.get()
        phase = self.phase.get()

        # Generate wave data based on type
        wave_data = self.generate_wave_data(wave_type, min_val, max_val, resolution, phase)

        # Update canvas preview
        self.draw_wave_preview(wave_data, min_val, max_val)

        # Update code output
        self.update_code_output(wave_data, wave_type, min_val, max_val, resolution, phase)

    def generate_wave_data(self, wave_type, min_val, max_val, resolution, phase):
        """Generate wave data based on type"""
        data = []
        amplitude = (max_val - min_val) // 2
        offset = min_val + amplitude

        for i in range(resolution):
            angle = (2 * math.pi * i / resolution) + phase

            if wave_type == "sine":
                value = int(offset + amplitude * math.sin(angle))
            elif wave_type == "cosine":
                value = int(offset + amplitude * math.cos(angle))
            elif wave_type == "triangle":
                # Triangle wave
                normalized = (angle % (2 * math.pi)) / (2 * math.pi)
                if normalized < 0.25:
                    value = int(min_val + 4 * amplitude * normalized)
                elif normalized < 0.75:
                    value = int(max_val - 4 * amplitude * (normalized - 0.25))
                else:
                    value = int(min_val + 4 * amplitude * (normalized - 0.75))
            elif wave_type == "square":
                # Square wave
                value = max_val if math.sin(angle) >= 0 else min_val

            # Clamp to min/max range
            value = max(min_val, min(max_val, value))
            data.append(value)

        return data

    def draw_wave_preview(self, data, min_val, max_val):
        """Draw the wave preview on canvas"""
        self.canvas.delete("all")

        if not data:
            return

        # Canvas dimensions
        canvas_width = self.canvas.winfo_width() or 600
        canvas_height = self.canvas.winfo_height() or 200

        # Plot area (with margins)
        margin = 20
        plot_width = canvas_width - 2 * margin
        plot_height = canvas_height - 2 * margin

        # Draw grid lines
        for i in range(0, 11):
            x = margin + (i * plot_width // 10)
            self.canvas.create_line(x, margin, x, canvas_height - margin, fill='#f0f0f0')
            y = margin + (i * plot_height // 10)
            self.canvas.create_line(margin, y, canvas_width - margin, y, fill='#f0f0f0')

        # Draw wave
        points = []
        for i, value in enumerate(data):
            x = margin + (i * plot_width // len(data))
            # Convert value to canvas coordinates (invert Y axis)
            y = margin + plot_height - ((value - min_val) * plot_height // (max_val - min_val))
            points.extend([x, y])

        if len(points) >= 4:
            self.canvas.create_line(points, fill='blue', width=2, smooth=True)

        # Draw min/max labels
        self.canvas.create_text(margin, margin - 5, text=f"Min: {min_val}", anchor=tk.W, fill='red')
        self.canvas.create_text(margin, canvas_height - margin + 5, text=f"Max: {max_val}", anchor=tk.W, fill='green')

    def update_code_output(self, data, wave_type, min_val, max_val, resolution, phase):
        """Update the code output text box"""
        self.code_text.delete(1.0, tk.END)

        # Generate assembly code
        code_lines = []
        code_lines.append(f"; 8-bit {wave_type} wave table")
        code_lines.append(f"; Generated by sinus_creator.py")
        code_lines.append(f"; Range: {min_val}-{max_val}, Samples: {resolution}")
        code_lines.append(f"; Phase: {phase:.3f}")
        code_lines.append("")

        # Table name based on wave type
        table_name = f"{wave_type}_wave_table"

        code_lines.append(f"{table_name}:")
        code_lines.append(f"    ; {len(data)} bytes")

        # Format data in rows of 16 values
        for i in range(0, len(data), 16):
            chunk = data[i:i+16]
            hex_values = [f"{val:3d}" for val in chunk]
            code_lines.append(f"    db {', '.join(hex_values)}")

        # Add end marker
        code_lines.append("")
        code_lines.append(f"{table_name}_end:")

        # Insert into text box
        self.code_text.insert(tk.END, "\n".join(code_lines))

    def copy_to_clipboard(self):
        """Copy code from text box to clipboard"""
        code_content = self.code_text.get(1.0, tk.END).strip()
        if code_content:
            self.root.clipboard_clear()
            self.root.clipboard_append(code_content)
            messagebox.showinfo("Success", "Code copied to clipboard!")

    def export_assembly(self):
        """Export the generated code to a file"""
        try:
            filename = filedialog.asksaveasfilename(
                defaultextension=".asm",
                filetypes=[("Assembly files", "*.asm"), ("Text files", "*.txt"), ("All files", "*.*")],
                title="Export Wave Table"
            )

            if filename:
                code_content = self.code_text.get(1.0, tk.END).strip()
                with open(filename, 'w') as f:
                    f.write(code_content)

                messagebox.showinfo("Export Successful", f"Wave table exported to {filename}")

        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export: {str(e)}")

    def run(self):
        self.root.mainloop()


def launch_gui():
    """Launch the GUI application"""
    if not HAS_GUI:
        print("GUI not available. tkinter is required but usually comes pre-installed with Python.")
        return

    try:
        gui = WaveGUI()
        gui.run()
    except Exception as e:
        print(f"Error launching GUI: {e}")


def main():
    parser = argparse.ArgumentParser(description="8-Bit Game Wave Generator")
    parser.add_argument("--min", type=int, default=0,
                       help="Minimum value (0-255, default: 0)")
    parser.add_argument("--max", type=int, default=255,
                       help="Maximum value (0-255, default: 255)")
    parser.add_argument("--resolution", "-r", type=int, default=256,
                       help="Samples per period (default: 256)")
    parser.add_argument("--type", "-t", choices=["sine", "cosine", "triangle", "square"],
                       default="sine", help="Wave type (default: sine)")
    parser.add_argument("--phase", "-p", type=float, default=0.0,
                       help="Phase offset in radians (default: 0.0)")
    parser.add_argument("--output", "-f", type=str, default=None,
                       help="Output file (default: stdout)")
    parser.add_argument("--gui", "-g", action="store_true",
                       help="Launch interactive GUI")

    args = parser.parse_args()

    # Validate ranges
    if args.min < 0 or args.min > 255:
        print("Error: min value must be between 0 and 255")
        return
    if args.max < 0 or args.max > 255:
        print("Error: max value must be between 0 and 255")
        return
    if args.min >= args.max:
        print("Error: min value must be less than max value")
        return

    # Launch GUI if requested
    if args.gui:
        if not HAS_GUI:
            print("GUI not available. tkinter is required but usually comes pre-installed with Python.")
            return
        launch_gui()
        return

    # Generate the wave data
    amplitude = (args.max - args.min) // 2
    offset = args.min + amplitude

    generator = WaveGenerator(amplitude, offset, args.resolution)

    if args.type == "sine":
        wave_data = generator.generate_sine(args.phase)
    elif args.type == "cosine":
        wave_data = generator.generate_cosine(args.phase)
    elif args.type == "triangle":
        # Generate triangle wave
        wave_data = []
        for i in range(args.resolution):
            angle = (2 * math.pi * i / args.resolution) + args.phase
            normalized = (angle % (2 * math.pi)) / (2 * math.pi)
            if normalized < 0.25:
                value = int(args.min + 4 * amplitude * normalized)
            elif normalized < 0.75:
                value = int(args.max - 4 * amplitude * (normalized - 0.25))
            else:
                value = int(args.min + 4 * amplitude * (normalized - 0.75))
            wave_data.append(max(args.min, min(args.max, value)))
    elif args.type == "square":
        # Generate square wave
        wave_data = []
        for i in range(args.resolution):
            angle = (2 * math.pi * i / args.resolution) + args.phase
            value = args.max if math.sin(angle) >= 0 else args.min
            wave_data.append(value)

    # Format as assembly code
    code_lines = []
    code_lines.append(f"; 8-bit {args.type} wave table")
    code_lines.append(f"; Generated by sinus_creator.py")
    code_lines.append(f"; Range: {args.min}-{args.max}, Samples: {args.resolution}")
    code_lines.append(f"; Phase: {args.phase:.3f}")
    code_lines.append("")

    table_name = f"{args.type}_wave_table"
    code_lines.append(f"{table_name}:")
    code_lines.append(f"    ; {len(wave_data)} bytes")

    # Format data in rows of 16 values
    for i in range(0, len(wave_data), 16):
        chunk = wave_data[i:i+16]
        hex_values = [f"{val:3d}" for val in chunk]
        code_lines.append(f"    db {', '.join(hex_values)}")

    code_lines.append("")
    code_lines.append(f"{table_name}_end:")
    assembly_code = "\n".join(code_lines)

    # Output the result
    if args.output:
        with open(args.output, 'w') as f:
            f.write(assembly_code)
        print(f"Wave table written to {args.output}")
    else:
        print(assembly_code)


if __name__ == "__main__":
    main()
